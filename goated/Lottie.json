{"v":"5.12.1","fr":30,"ip":0,"op":721,"w":1080,"h":1080,"nm":"Scene","ddd":0,"assets":[{"id":"comp_0","nm":"Kiss_Face","fr":30,"layers":[{"ddd":0,"ind":1,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [3]","refId":"comp_1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [2]","refId":"comp_2","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":3,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [1]","refId":"comp_3","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":4,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [0]","refId":"comp_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":5,"ty":0,"nm":"MAP || Dice || square_1 || BACK","refId":"comp_5","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('square_1').effect('Extrudalizer')('Back opacity readout');"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[150,150],"ix":1,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst is_front = false;\nconst precomp_width = 300;\nlet extr_data_arr = [];\nlet is_facing_us = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    $bm_rt = is_facing_us = extr_data_arr[8];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    $bm_rt = is_facing_us = extr_data_arr[8] == 'true';\n}\nfunction logicalXOR(input1, input2) {\n    return input1 && !input2 || !input1 && input2;\n}\nif (logicalXOR(is_front, is_facing_us)) {\n    $bm_rt = value = [\n        precomp_width,\n        0\n    ];\n} else {\n    $bm_rt = value = [\n        0,\n        0\n    ];\n}"}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst POS_INDEX_LOTTIE = 0;\nconst POS_INDEX_1 = 0;\nconst POS_INDEX_2 = 1;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let pos = [\n        0,\n        0\n    ];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        $bm_rt = pos = transform_effect_controls[POS_INDEX_LOTTIE];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        $bm_rt = pos = [\n            transform_effect_controls[POS_INDEX_1],\n            transform_effect_controls[POS_INDEX_2]\n        ];\n    }\n}"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 3;\nconst control_index_ae = 4;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.height;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 4;\nconst control_index_ae = 5;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = $bm_neg(thisLayer.width);\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 2;\nconst control_index_ae = 3;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 1;\nconst control_index_ae = 2;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'Back';\nconst face_opacity = ex_layer.effect('Extrudalizer')(face + ' opacity readout').value;\n$bm_rt = face_opacity;"}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":6,"ty":0,"nm":"MAP || Dice || square_1 || FRONT","refId":"comp_6","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('square_1').effect('Extrudalizer')('Front opacity readout');"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[150,150],"ix":1,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst is_front = true;\nconst precomp_width = 300;\nlet extr_data_arr = [];\nlet is_facing_us = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    $bm_rt = is_facing_us = extr_data_arr[8];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    $bm_rt = is_facing_us = extr_data_arr[8] == 'true';\n}\nfunction logicalXOR(input1, input2) {\n    return input1 && !input2 || !input1 && input2;\n}\nif (logicalXOR(is_front, is_facing_us)) {\n    $bm_rt = value = [\n        precomp_width,\n        0\n    ];\n} else {\n    $bm_rt = value = [\n        0,\n        0\n    ];\n}"}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst POS_INDEX_LOTTIE = 0;\nconst POS_INDEX_1 = 0;\nconst POS_INDEX_2 = 1;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let pos = [\n        0,\n        0\n    ];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        $bm_rt = pos = transform_effect_controls[POS_INDEX_LOTTIE];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        $bm_rt = pos = [\n            transform_effect_controls[POS_INDEX_1],\n            transform_effect_controls[POS_INDEX_2]\n        ];\n    }\n}"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 3;\nconst control_index_ae = 4;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.height;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 4;\nconst control_index_ae = 5;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.width;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 2;\nconst control_index_ae = 3;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 1;\nconst control_index_ae = 2;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'Front';\nconst face_opacity = ex_layer.effect('Extrudalizer')(face + ' opacity readout').value;\n$bm_rt = face_opacity;"}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":7,"ty":4,"nm":"square_1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[540,540,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":1,"k":[{"i":{"x":[0.667,0.667,0.667],"y":[1,1,1]},"o":{"x":[0.333,0.333,0.333],"y":[0,0,0]},"t":60,"s":[100,100,100]},{"t":90,"s":[180,180,100]}],"ix":6,"l":2}},"ao":0,"ef":[{"ty":5,"nm":"Extrudalizer","np":70,"mn":"Pseudo/Extrudalizer","ix":1,"en":1,"ef":[{"ty":6,"nm":"3D Transform","mn":"Pseudo/Extrudalizer-0001","ix":1,"v":0},{"ty":0,"nm":"Extrusion depth","mn":"Pseudo/Extrudalizer-0002","ix":2,"v":{"a":0,"k":300,"ix":2}},{"ty":3,"nm":"Position","mn":"Pseudo/Extrudalizer-0003","ix":3,"v":{"a":0,"k":[0,0,0],"ix":3}},{"ty":6,"nm":"Scale","mn":"Pseudo/Extrudalizer-0004","ix":4,"v":0},{"ty":0,"nm":"Front scale","mn":"Pseudo/Extrudalizer-0005","ix":5,"v":{"a":0,"k":100,"ix":5}},{"ty":0,"nm":"Back scale","mn":"Pseudo/Extrudalizer-0006","ix":6,"v":{"a":0,"k":100,"ix":6}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0007","ix":7,"v":0},{"ty":6,"nm":"Pitch/Roll/Yaw","mn":"Pseudo/Extrudalizer-0008","ix":8,"v":0},{"ty":0,"nm":"Pitch (x)","mn":"Pseudo/Extrudalizer-0009","ix":9,"v":{"a":1,"k":[{"i":{"x":[0.401],"y":[1]},"o":{"x":[0.333],"y":[0]},"t":0,"s":[-30]},{"t":60,"s":[-720]}],"ix":9}},{"ty":0,"nm":"Yaw (y)","mn":"Pseudo/Extrudalizer-0010","ix":10,"v":{"a":1,"k":[{"i":{"x":[0.401],"y":[1]},"o":{"x":[0.333],"y":[0]},"t":0,"s":[30]},{"t":60,"s":[720]}],"ix":10}},{"ty":0,"nm":"Roll (z)","mn":"Pseudo/Extrudalizer-0011","ix":11,"v":{"a":1,"k":[{"i":{"x":[0.401],"y":[1]},"o":{"x":[0.333],"y":[0]},"t":0,"s":[0]},{"t":60,"s":[-360]}],"ix":11}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0012","ix":12,"v":0},{"ty":6,"nm":"Orbit control","mn":"Pseudo/Extrudalizer-0013","ix":13,"v":0},{"ty":0,"nm":"X Rotation","mn":"Pseudo/Extrudalizer-0014","ix":14,"v":{"a":0,"k":0,"ix":14}},{"ty":0,"nm":"Y Rotation","mn":"Pseudo/Extrudalizer-0015","ix":15,"v":{"a":0,"k":0,"ix":15}},{"ty":0,"nm":"Z Rotation","mn":"Pseudo/Extrudalizer-0016","ix":16,"v":{"a":0,"k":0,"ix":16}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0017","ix":17,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0018","ix":18,"v":0},{"ty":6,"nm":"Appearance","mn":"Pseudo/Extrudalizer-0019","ix":19,"v":0},{"ty":7,"nm":"Hide anchor point","mn":"Pseudo/Extrudalizer-0020","ix":20,"v":{"a":0,"k":1,"ix":20}},{"ty":7,"nm":"Wireframe mode","mn":"Pseudo/Extrudalizer-0021","ix":21,"v":{"a":0,"k":0,"ix":21}},{"ty":2,"nm":"Edge stroke color","mn":"Pseudo/Extrudalizer-0022","ix":22,"v":{"a":0,"k":[0.996078491211,0.98431378603,0.917647123337,1],"ix":22}},{"ty":0,"nm":"Edge stroke width","mn":"Pseudo/Extrudalizer-0023","ix":23,"v":{"a":0,"k":0,"ix":23}},{"ty":0,"nm":"Translucency","mn":"Pseudo/Extrudalizer-0024","ix":24,"v":{"a":0,"k":0,"ix":24}},{"ty":6,"nm":"Front & Back ","mn":"Pseudo/Extrudalizer-0025","ix":25,"v":0},{"ty":2,"nm":"Front color","mn":"Pseudo/Extrudalizer-0026","ix":26,"v":{"a":0,"k":[0.996078491211,0.98431378603,0.917647123337,1],"ix":26}},{"ty":0,"nm":"Front opacity","mn":"Pseudo/Extrudalizer-0027","ix":27,"v":{"a":0,"k":100,"ix":27}},{"ty":0,"nm":"Front gradient opacity","mn":"Pseudo/Extrudalizer-0028","ix":28,"v":{"a":0,"k":0,"ix":28}},{"ty":0,"nm":"Front gradient direction","mn":"Pseudo/Extrudalizer-0029","ix":29,"v":{"a":0,"k":0,"ix":29}},{"ty":6,"nm":"   ","mn":"Pseudo/Extrudalizer-0030","ix":30,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0031","ix":31,"v":0},{"ty":2,"nm":"Back color","mn":"Pseudo/Extrudalizer-0032","ix":32,"v":{"a":0,"k":[0.945098102093,0.917647123337,0.776470661163,1],"ix":32}},{"ty":0,"nm":"Back opacity","mn":"Pseudo/Extrudalizer-0033","ix":33,"v":{"a":0,"k":100,"ix":33}},{"ty":0,"nm":"Back gradient opacity","mn":"Pseudo/Extrudalizer-0034","ix":34,"v":{"a":0,"k":0,"ix":34}},{"ty":0,"nm":"Back gradient direction","mn":"Pseudo/Extrudalizer-0035","ix":35,"v":{"a":0,"k":0,"ix":35}},{"ty":6,"nm":"    ","mn":"Pseudo/Extrudalizer-0036","ix":36,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0037","ix":37,"v":0},{"ty":3,"nm":"Gradient start point","mn":"Pseudo/Extrudalizer-0038","ix":38,"v":{"a":0,"k":[0,0],"ix":38}},{"ty":3,"nm":"Gradient end point","mn":"Pseudo/Extrudalizer-0039","ix":39,"v":{"a":0,"k":[0,0],"ix":39}},{"ty":6,"nm":"Edit gradient start/end points o","mn":"Pseudo/Extrudalizer-0040","ix":40,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0041","ix":41,"v":0},{"ty":6,"nm":"at 3D rotation set to [0,0,0]","mn":"Pseudo/Extrudalizer-0042","ix":42,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0043","ix":43,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0044","ix":44,"v":0},{"ty":6,"nm":"Sides","mn":"Pseudo/Extrudalizer-0045","ix":45,"v":0},{"ty":2,"nm":"Sides color","mn":"Pseudo/Extrudalizer-0046","ix":46,"v":{"a":0,"k":[0,1,1,1],"ix":46}},{"ty":0,"nm":"Sides opacity","mn":"Pseudo/Extrudalizer-0047","ix":47,"v":{"a":0,"k":100,"ix":47}},{"ty":0,"nm":"Sides gradient opacity","mn":"Pseudo/Extrudalizer-0048","ix":48,"v":{"a":0,"k":25,"ix":48}},{"ty":0,"nm":"Sides gradient direction","mn":"Pseudo/Extrudalizer-0049","ix":49,"v":{"a":0,"k":0,"ix":49}},{"ty":0,"nm":"Sides gradient length","mn":"Pseudo/Extrudalizer-0050","ix":50,"v":{"a":0,"k":0,"ix":50}},{"ty":2,"nm":"Sides fill shadow color","mn":"Pseudo/Extrudalizer-0051","ix":51,"v":{"a":0,"k":[0,0,0,1],"ix":51}},{"ty":0,"nm":"Sides fill shadow opacity","mn":"Pseudo/Extrudalizer-0052","ix":52,"v":{"a":0,"k":50,"ix":52}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0053","ix":53,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0054","ix":54,"v":0},{"ty":6,"nm":"Parenting Data","mn":"Pseudo/Extrudalizer-0055","ix":55,"v":0},{"ty":0,"nm":"Front opacity readout","mn":"Pseudo/Extrudalizer-0056","ix":56,"v":{"a":0,"k":100,"ix":56,"x":"var $bm_rt;\ntry {\n    $bm_rt = content('--- EXTRUDALIZER ---').content('FRONT').transform.opacity;\n} catch (e) {\n    $bm_rt = 0;\n}"}},{"ty":0,"nm":"Back opacity readout","mn":"Pseudo/Extrudalizer-0057","ix":57,"v":{"a":0,"k":100,"ix":57,"x":"var $bm_rt;\ntry {\n    $bm_rt = content('--- EXTRUDALIZER ---').content('BACK').transform.opacity;\n} catch (e) {\n    $bm_rt = 0;\n}"}},{"ty":7,"nm":"Compute 3D front bounding box","mn":"Pseudo/Extrudalizer-0058","ix":58,"v":{"a":0,"k":1,"ix":58}},{"ty":3,"nm":"Front upper left","mn":"Pseudo/Extrudalizer-0059","ix":59,"v":{"a":0,"k":[0,0],"ix":59,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[0];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[0],\n            front_bb[1]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front upper right","mn":"Pseudo/Extrudalizer-0060","ix":60,"v":{"a":0,"k":[0,0],"ix":60,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[1];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[2],\n            front_bb[3]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front lower left","mn":"Pseudo/Extrudalizer-0061","ix":61,"v":{"a":0,"k":[0,0],"ix":61,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[2];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[4],\n            front_bb[5]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front lower right","mn":"Pseudo/Extrudalizer-0062","ix":62,"v":{"a":0,"k":[0,0],"ix":62,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[3];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[6],\n            front_bb[7]\n        ];\n    }\n}"}},{"ty":7,"nm":"Compute 3D back bounding box","mn":"Pseudo/Extrudalizer-0063","ix":63,"v":{"a":0,"k":1,"ix":63}},{"ty":3,"nm":"Back upper left","mn":"Pseudo/Extrudalizer-0064","ix":64,"v":{"a":0,"k":[0,0],"ix":64,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[0];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[0],\n            back_bb[1]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back upper right","mn":"Pseudo/Extrudalizer-0065","ix":65,"v":{"a":0,"k":[0,0],"ix":65,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[1];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[2],\n            back_bb[3]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back lower left","mn":"Pseudo/Extrudalizer-0066","ix":66,"v":{"a":0,"k":[0,0],"ix":66,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[2];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[4],\n            back_bb[5]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back lower right","mn":"Pseudo/Extrudalizer-0067","ix":67,"v":{"a":0,"k":[0,0],"ix":67,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[3];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[6],\n            back_bb[7]\n        ];\n    }\n}"}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0068","ix":68,"v":0}]},{"ty":5,"nm":"FACE 0","np":3,"mn":"ADBE Color Control","ix":2,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.945098042488,0.919524788857,0.774609744549,1],"ix":1}}]},{"ty":5,"nm":"FACE 1","np":3,"mn":"ADBE Color Control","ix":3,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.996078431606,0.984313726425,0.917647063732,1],"ix":1}}]},{"ty":5,"nm":"FACE 2","np":3,"mn":"ADBE Color Control","ix":4,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.945098042488,0.919524788857,0.774609744549,1],"ix":1}}]},{"ty":5,"nm":"FACE 3","np":3,"mn":"ADBE Color Control","ix":5,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.996078431606,0.984313726425,0.917647063732,1],"ix":1}}]}],"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[150,-150],[150,150],[-150,150],[-150,-150]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":true},{"ty":"st","c":{"a":0,"k":[0,0.925924921971,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":78,"ix":5},"lc":2,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"ORIGIN SHAPE","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nlet extr_data_arr;\nlet points_3D = [];\nlet isPathClosed;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_3D = extr_data_arr[5];\n    isPathClosed = extr_data_arr[4] === true;\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let points_arr = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    isPathClosed = extr_data_arr[4] === 'true';\n    for (var i = 0, il = points_arr.length / 3; i < il; i++) {\n        points_3D.push(points_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst points_2D = points_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst num_pts = points_2D.length;\nconst zeroArr = Array(num_pts).fill([\n    0,\n    0\n]);\n$bm_rt = createPath(points_2D, zeroArr, zeroArr, isPathClosed);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Front color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":2,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Front color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"FRONT","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 0;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = true ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[0][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[0];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = false ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[0][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[0];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 0 - 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 1;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = true ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[1][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[1];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = false ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[1][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[1];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 1 - 2","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDES","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"--- EXTRUDALIZER ---","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":300,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":8,"ty":5,"nm":"EXTRUDALIZER DATA || square_1","hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[540,540,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"t":{"d":{"k":[{"s":{"s":36,"f":"TrajanPro-Bold","t":"","ca":0,"j":0,"tr":0,"lh":43.2000007629395,"ls":0,"fc":[0.267,0.722,0.765]},"t":0}],"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, arraysEqual, getNormal, get2D_projection, getBoundingBox, getPositionMatrix, getRotationMatrix, getScaleMatrix, getIdentity, translate, rotateX, rotateY, rotateZ, multiplyMatrixVector, multiplyMatrices, multiplyArrayOfMatrices, transformMatrix, make_transform, getPoint, getArea, isClockwise, getCentroid, getCentroidPro, hasNoneZeroValues, angle_between, angle_between_cw, angle_between_cw_te, isStraightLine_w_delta, isFacingTowardsUs, isVectorFacingTowardsUs, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_shape_matrix, get_transforms_from_bb, num_pts, compare_sides, sorted_sides_indices, adjustColorBrightness, lambertShader, stringify;\n'use native operators';\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\narraysEqual = function (arr1, arr2) {\n    for (var i = 0, il = arr1.length; i < il; i++) {\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n};\ngetNormal = function (pts, normalized) {\n    let dir = cross_vec(sub(pts[1], pts[0]), sub(pts[2], pts[0]));\n    let len_dir = len_vec(dir);\n    if (len_dir === 0) {\n        return [\n            0,\n            0,\n            0\n        ];\n    }\n    if (normalized) {\n        return div(dir, len_dir);\n    } else {\n        return dir;\n    }\n};\nget2D_projection = function (points) {\n    return points.map(v => [\n        v[0],\n        v[1]\n    ]);\n};\ngetBoundingBox = function (points) {\n    const boundingBox = {\n        left: Number.POSITIVE_INFINITY,\n        top: Number.POSITIVE_INFINITY,\n        right: Number.NEGATIVE_INFINITY,\n        bottom: Number.NEGATIVE_INFINITY,\n        width: undefined,\n        height: undefined,\n        center: undefined\n    };\n    points.forEach(point => {\n        boundingBox.left = Math.min(boundingBox.left, point[0]);\n        boundingBox.top = Math.min(boundingBox.top, point[1]);\n        boundingBox.right = Math.max(boundingBox.right, point[0]);\n        boundingBox.bottom = Math.max(boundingBox.bottom, point[1]);\n    });\n    boundingBox.width = sub(boundingBox.right, boundingBox.left);\n    boundingBox.height = sub(boundingBox.bottom, boundingBox.top);\n    boundingBox.center = [\n        add(boundingBox.left, $bm_div(boundingBox.width, 2)),\n        add(boundingBox.top, $bm_div(boundingBox.height, 2))\n    ];\n    boundingBox.left_top = [\n        boundingBox.left,\n        boundingBox.top\n    ];\n    boundingBox.left_bottom = [\n        boundingBox.left,\n        boundingBox.bottom\n    ];\n    boundingBox.right_top = [\n        boundingBox.right,\n        boundingBox.top\n    ];\n    boundingBox.right_bottom = [\n        boundingBox.right,\n        boundingBox.bottom\n    ];\n    return boundingBox;\n};\ngetPositionMatrix = function (value) {\n    return translate(getIdentity(), value[0], value[1], $bm_neg(value[2]));\n};\ngetRotationMatrix = function (angles) {\n    const angleX = angles[0];\n    const angleY = angles[1];\n    const angleZ = angles[2];\n    var matrix = getIdentity();\n    matrix = rotateZ(matrix, $bm_div($bm_mul(angleZ, Math.PI), 180));\n    matrix = rotateY(matrix, $bm_div($bm_mul(angleY, Math.PI), 180));\n    matrix = rotateX(matrix, $bm_div($bm_mul(angleX, Math.PI), 180));\n    return matrix;\n};\ngetScaleMatrix = function (sc) {\n    return [\n        sc,\n        0,\n        0,\n        0,\n        0,\n        sc,\n        0,\n        0,\n        0,\n        0,\n        sc,\n        0,\n        0,\n        0,\n        0,\n        1\n    ];\n};\ngetIdentity = function () {\n    return [\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n    ];\n};\ntranslate = function (matrix, x, y, z) {\n    return multiplyMatrices(matrix, [\n        1,\n        0,\n        0,\n        x,\n        0,\n        1,\n        0,\n        y,\n        0,\n        0,\n        1,\n        z,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateX = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        1,\n        0,\n        0,\n        0,\n        0,\n        cos_th,\n        $bm_neg(sin_th),\n        0,\n        0,\n        sin_th,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateY = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        cos_th,\n        0,\n        sin_th,\n        0,\n        0,\n        1,\n        0,\n        0,\n        $bm_neg(sin_th),\n        0,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateZ = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        cos_th,\n        $bm_neg(sin_th),\n        0,\n        0,\n        sin_th,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nmultiplyMatrixVector = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 4; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 4; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 4), j)], vector[j]));\n        }\n    }\n    return result;\n};\nmultiplyMatrices = function (matrixB, matrixA) {\n    let result = new Array(16).fill(0);\n    for (let i = 0; i < 4; i++) {\n        for (let j = 0; j < 4; j++) {\n            for (let k = 0; k < 4; k++) {\n                result[$bm_sum($bm_mul(i, 4), j)] = $bm_sum(result[$bm_sum($bm_mul(i, 4), j)], $bm_mul(matrixA[$bm_sum($bm_mul(i, 4), k)], matrixB[$bm_sum($bm_mul(k, 4), j)]));\n            }\n        }\n    }\n    return result;\n};\nmultiplyArrayOfMatrices = function (matrices) {\n    var result = matrices[0];\n    for (var i = 1, il = matrices.length; i < il; i++) {\n        result = multiplyMatrices(result, matrices[i]);\n    }\n    return result;\n};\ntransformMatrix = function (move, sc, pivot, pitch_angles, anch, orbit_angles) {\n    var mat_array = [];\n    if (sc !== 1) {\n        if (!arraysEqual(pivot, [\n                0,\n                0,\n                0\n            ])) {\n            mat_array = mat_array.concat([\n                getPositionMatrix(pivot.map(i => -i)),\n                getScaleMatrix(sc),\n                getPositionMatrix(pivot)\n            ]);\n        } else {\n            mat_array.push(getScaleMatrix(sc));\n        }\n    }\n    mat_array.push(getPositionMatrix(move));\n    if (!arraysEqual(pitch_angles, [\n            0,\n            0,\n            0\n        ])) {\n        if (!arraysEqual(pivot, [\n                0,\n                0,\n                0\n            ])) {\n            mat_array = mat_array.concat([\n                getPositionMatrix(pivot.map(i => -i)),\n                getRotationMatrix(pitch_angles),\n                getPositionMatrix(pivot)\n            ]);\n        } else {\n            mat_array.push(getRotationMatrix(pitch_angles));\n        }\n    }\n    if (!arraysEqual(anch, [\n            0,\n            0,\n            0\n        ])) {\n        mat_array.push(getPositionMatrix(anch.map(i => -i)));\n    }\n    if (!arraysEqual(orbit_angles, [\n            0,\n            0,\n            0\n        ])) {\n        mat_array.push(getRotationMatrix(orbit_angles));\n    }\n    return multiplyArrayOfMatrices(mat_array);\n};\nmake_transform = function (transform_matrix, vector) {\n    if (vector.length == 2) {\n        vector = [\n            ...vector,\n            0,\n            1\n        ];\n    } else if (vector.length == 3) {\n        vector = [\n            ...vector,\n            1\n        ];\n    }\n    var result_vector_4d = multiplyMatrixVector(transform_matrix, vector);\n    return result_vector_4d.slice(0, 3);\n};\ngetPoint = function (p1, cp1, cp2, p2, t) {\n    const x = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[0]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[0])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[0])), $bm_mul(Math.pow(t, 3), p2[0]));\n    const y = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[1]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[1])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[1])), $bm_mul(Math.pow(t, 3), p2[1]));\n    return [\n        x,\n        y\n    ];\n};\ngetArea = function (points) {\n    var area = 0;\n    for (var i = 0, il = points.length; i < il; i++) {\n        var p1 = points[i];\n        var p2 = points[(i + 1) % il];\n        area = $bm_sum(area, $bm_sub($bm_mul(p1[0], p2[1]), $bm_mul(p2[0], p1[1])));\n    }\n    return $bm_div(area, 2);\n};\nisClockwise = function (points) {\n    return getArea(points) > 0;\n};\ngetCentroid = function (vertices) {\n    var area = getArea(vertices);\n    if (area === 0) {\n        function findCenter(points) {\n            let sumX = 0;\n            let sumY = 0;\n            for (let i = 0, il = points.length; i < il; i++) {\n                const point = points[i];\n                sumX = $bm_sum(sumX, point[0]);\n                sumY = $bm_sum(sumY, point[1]);\n            }\n            const meanX = $bm_div(sumX, points.length);\n            const meanY = $bm_div(sumY, points.length);\n            return [\n                meanX,\n                meanY\n            ];\n        }\n        return findCenter(vertices);\n    }\n    let centroidX = 0;\n    let centroidY = 0;\n    const numVertices = vertices.length;\n    for (var i = 0; i < numVertices; i++) {\n        var currentVertex = vertices[i];\n        var nextVertex = vertices[(i + 1) % numVertices];\n        var commonFactor = $bm_sub($bm_mul(currentVertex[0], nextVertex[1]), $bm_mul(nextVertex[0], currentVertex[1]));\n        centroidX = $bm_sum(centroidX, $bm_mul($bm_sum(currentVertex[0], nextVertex[0]), commonFactor));\n        centroidY = $bm_sum(centroidY, $bm_mul($bm_sum(currentVertex[1], nextVertex[1]), commonFactor));\n    }\n    var scaleFactor = $bm_div(1, $bm_mul(6, area));\n    centroidX *= scaleFactor;\n    centroidY *= scaleFactor;\n    return [\n        centroidX,\n        centroidY\n    ];\n};\ngetCentroidPro = function (vertices) {\n    const bb = getBoundingBox(vertices);\n    return {\n        0: bb.left_top,\n        1: [\n            (bb.left_top[0] + bb.right_top[0]) / 2,\n            bb.left_top[1]\n        ],\n        2: bb.right_top,\n        3: [\n            (bb.left_top[0] + bb.left_bottom[0]) / 2,\n            (bb.left_top[1] + bb.left_bottom[1]) / 2\n        ],\n        4: getCentroid(vertices),\n        5: [\n            (bb.right_top[0] + bb.right_bottom[0]) / 2,\n            (bb.right_top[1] + bb.right_bottom[1]) / 2\n        ],\n        6: bb.left_bottom,\n        7: [\n            (bb.left_bottom[0] + bb.right_bottom[0]) / 2,\n            bb.left_bottom[1]\n        ],\n        8: bb.right_bottom\n    };\n};\nhasNoneZeroValues = function (array2D) {\n    return array2D.some(array => array.some(value => value !== 0));\n};\nangle_between = function (a, b) {\n    const dot_prod = dot_(a, b);\n    const mag_a = len_vec(a);\n    const mag_b = len_vec(b);\n    const cos_ = $bm_div(dot_prod, $bm_mul(mag_a, mag_b));\n    return cos_;\n};\nangle_between_cw = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    angle = angle >= 0 ? angle : $bm_sum($bm_mul(2, Math.PI), angle);\n    const degrees = $bm_mul(angle, $bm_div(180, Math.PI));\n    return degrees;\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nisStraightLine_w_delta = function (cp1, cp2, delta) {\n    return angle_between(cp1, cp2) <= -delta;\n};\nisFacingTowardsUs = function (p1, p2) {\n    return dot_(sub(p2, p1), [\n        0,\n        0,\n        1\n    ]) > 0;\n};\nisVectorFacingTowardsUs = function (v) {\n    return dot_(v, [\n        0,\n        0,\n        -1\n    ]) > 0;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_shape_matrix = function (anchor, pos, scale, rot, skew, skew_axis) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (skew !== 0) {\n        const sk_angle = $bm_div($bm_mul(skew, Math.PI), 180);\n        const Sk = [\n            1,\n            Math.tan(-sk_angle),\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            1\n        ];\n        if (skew_axis !== 0) {\n            const sk_axis_angle = $bm_div($bm_mul(skew_axis, Math.PI), 180);\n            const cos_sk = Math.cos(sk_axis_angle);\n            const sin_sk = Math.sin(sk_axis_angle);\n            const Rz = [\n                cos_sk,\n                -sin_sk,\n                0,\n                sin_sk,\n                cos_sk,\n                0,\n                0,\n                0,\n                1\n            ];\n            const Rz_inv = [\n                cos_sk,\n                sin_sk,\n                0,\n                -sin_sk,\n                cos_sk,\n                0,\n                0,\n                0,\n                1\n            ];\n            const SkM = multiplyArrayOfMatrices3x3([\n                Rz_inv,\n                Sk,\n                Rz\n            ]);\n            mat_array.push(SkM);\n        } else {\n            mat_array.push(Sk);\n        }\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nget_transforms_from_bb = function (bb, extr_transform_matrix, layer_transform_matrix, parent_transform_matrix, is_front, front_facing_towards_us, mode) {\n    let bb_transformed_3D = [];\n    if (front_facing_towards_us) {\n        bb_transformed_3D = [\n            bb.left_top,\n            bb.right_top,\n            bb.left_bottom,\n            bb.right_bottom\n        ];\n    } else {\n        bb_transformed_3D = [\n            bb.right_top,\n            bb.left_top,\n            bb.right_bottom,\n            bb.left_bottom\n        ];\n    }\n    bb_transformed_3D = bb_transformed_3D.map(pnt => make_transform(extr_transform_matrix, pnt));\n    let bb_transformed_2D = get2D_projection(bb_transformed_3D);\n    bb_transformed_2D = bb_transformed_2D.map(p => transform2D_apply(layer_transform_matrix, p));\n    if (parent_transform_matrix) {\n        bb_transformed_2D = bb_transformed_2D.map(p => transform2D_apply(parent_transform_matrix, p));\n    }\n    const ex_left_top = bb_transformed_2D[0], ex_right_top = bb_transformed_2D[1], ex_left_bottom = bb_transformed_2D[2], ex_right_bottom = bb_transformed_2D[3];\n    let transform_effect_controls = [];\n    if (mode & 1) {\n        const bb_pos = ex_left_top;\n        const ex_AD = sub(ex_left_bottom, ex_left_top);\n        const rot = angle_between_cw_te(ex_AD, [\n            0,\n            1\n        ]);\n        const ex_AB = sub(ex_right_top, ex_left_top);\n        const rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\n        const x_rot = [\n            Math.cos(rot_rad),\n            Math.sin(rot_rad)\n        ];\n        let skw = angle_between_cw_te(ex_AB, x_rot);\n        if (!front_facing_towards_us) {\n            skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n            skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n        }\n        ;\n        let extra_skew_arr = [];\n        if (Math.abs(skw) > 70) {\n            const max_count = 7;\n            let count = 1;\n            let skew_ = Math.abs(skw);\n            const tan_70 = Math.tan(degreesToRadians(70));\n            while (skew_ > 70 && count < max_count) {\n                skew_ = radiansToDegrees(Math.atan($bm_sub(Math.tan(degreesToRadians(skew_)), tan_70)));\n                extra_skew_arr.push(skw > 0 ? skew_ : -skew_);\n                count++;\n            }\n        }\n        const scaleY = $bm_mul(100, len_vec(ex_AD));\n        const angle_AB_AD = angle_between_cw_te(ex_AD, ex_AB);\n        const beta = $bm_sub($bm_sub(180, angle_AB_AD), skw);\n        const scaleX_coeff = $bm_div(Math.sin($bm_div($bm_mul(beta, Math.PI), 180)), Math.sin($bm_div($bm_mul(angle_AB_AD, Math.PI), 180)));\n        let scaleX = $bm_div($bm_mul(100, len_vec(ex_AB)), scaleX_coeff);\n        if (!front_facing_towards_us) {\n            scaleX = $bm_neg(scaleX);\n        }\n        transform_effect_controls = [\n            bb_pos,\n            rot,\n            skw,\n            scaleY,\n            scaleX,\n            extra_skew_arr\n        ];\n    }\n    let transform_layer_controls = [];\n    if (mode & 2) {\n        const tl_AB = sub(bb.right_top, bb.left_top);\n        const tl_AD = sub(bb.left_bottom, bb.left_top);\n        const tl_scaleX_coeff = 100;\n        const tl_scaleY_coeff = 100;\n        const tl_bb_anchor = bb.left_top;\n        let tl_bb_pos = ex_left_top;\n        const tl_ex_AB = sub(ex_right_top, ex_left_top);\n        let tl_bb_theta = angle_between_cw(tl_AB, tl_ex_AB);\n        let tl_bb_scx = $bm_div($bm_mul(tl_scaleX_coeff, len_vec(tl_ex_AB)), len_vec(tl_AB));\n        const tl_ex_AD = sub(ex_left_bottom, ex_left_top);\n        const tl_bb_th_rad = $bm_mul(tl_bb_theta, $bm_div(Math.PI, 180));\n        const tl_cos_th = Math.cos(tl_bb_th_rad);\n        const tl_sin_th = Math.sin(tl_bb_th_rad);\n        const tl_AD_rot = [\n            tl_AD[0] * tl_cos_th - tl_AD[1] * tl_sin_th,\n            tl_AD[0] * tl_sin_th + tl_AD[1] * tl_cos_th\n        ];\n        let tl_skew = angle_between_cw(tl_AD_rot, tl_ex_AD);\n        tl_skew = tl_skew < 90 ? tl_skew : $bm_sub(tl_skew, 360);\n        const tl_sk_rad = $bm_div($bm_mul(tl_skew, Math.PI), 180);\n        const tl_AD_skew = [\n            tl_AD[0] + Math.tan(-tl_sk_rad) * tl_AD[1],\n            tl_AD[1]\n        ];\n        const tl_bb_scy = $bm_div($bm_mul(tl_scaleY_coeff, len_vec(tl_ex_AD)), len_vec(tl_AD_skew));\n        if (front_facing_towards_us && !is_front || !front_facing_towards_us && is_front) {\n            tl_bb_scx = $bm_neg(tl_bb_scx);\n            tl_bb_pos = $bm_sum(tl_bb_pos, tl_ex_AB);\n        }\n        transform_layer_controls = [\n            tl_bb_anchor[0],\n            tl_bb_anchor[1],\n            tl_bb_pos[0],\n            tl_bb_pos[1],\n            tl_bb_theta,\n            tl_bb_scx,\n            tl_bb_scy,\n            tl_skew\n        ];\n    }\n    return {\n        'boundingBoxTransformed': bb_transformed_2D,\n        'transformEffectControls': transform_effect_controls,\n        'transformLayerControls': transform_layer_controls\n    };\n};\nconst shape_layer = thisComp.layer('square_1');\nconst shape = shape_layer(2)(1);\nconst shape_contents = shape(2);\nconst targetPath = shape_contents(1)(2);\nconst is_path_closed = targetPath.isClosed();\nconst extrudalizer = shape_layer('ADBE Effect Parade')('Pseudo/Extrudalizer');\nconst depth = extrudalizer('Extrusion depth').value;\nlet anchor = extrudalizer('Position').value;\nanchor = [\n    $bm_neg(anchor[0]),\n    anchor[1],\n    anchor[2]\n];\nconst angleX = extrudalizer('X Rotation').value;\nconst angleY = extrudalizer('Y Rotation').value;\nconst angleZ = extrudalizer('Z Rotation').value;\nconst pivot_angleX = extrudalizer('Pitch (x)').value;\nconst pivot_angleY = extrudalizer('Yaw (y)').value;\nconst pivot_angleZ = extrudalizer('Roll (z)').value;\nconst scale_front = $bm_div(extrudalizer('Front scale').value, 100);\nconst scale_back = $bm_div(extrudalizer('Back scale').value, 100);\nconst use_bb_front = extrudalizer('Compute 3D front bounding box').value;\nconst use_bb_back = extrudalizer('Compute 3D back bounding box').value;\nlet pnts = targetPath.points();\nlet inTangents = targetPath.inTangents();\nlet outTangents = targetPath.outTangents();\nconst is_front_clockwise = isClockwise(pnts);\nconst shape_transform = shape.transform;\nconst s_anchor = shape_transform.anchorPoint;\nconst s_pos = shape_transform.position;\nconst s_scale = shape_transform.scale;\nconst s_rot = shape_transform.rotation;\nconst s_skew = shape_transform.skew;\nconst s_skew_axis = shape_transform.skewAxis;\nconst shape_transform_matrix = get_transform_shape_matrix(s_anchor, s_pos, s_scale, s_rot, s_skew, s_skew_axis);\nconst layer_transform = shape_layer.transform;\nconst l_anchor = layer_transform.anchorPoint;\nconst l_pos = layer_transform.position;\nconst l_scale = layer_transform.scale;\nconst l_rot = layer_transform.rotation;\nconst layer_transform_matrix = get_transform_shape_matrix(l_anchor, l_pos, l_scale, l_rot, 0, 0);\nlet subdivs = 1;\nlet num_pnts = pnts.length;\nif (hasNoneZeroValues(inTangents) || hasNoneZeroValues(outTangents)) {\n    subdivs = 5;\n    let pointsF = [];\n    for (var i = 0; i < num_pnts; i++) {\n        pointsF.push(pnts[i]);\n        if (!is_path_closed && i == num_pnts - 1) {\n            break;\n        }\n        var p1 = pnts[i], p2 = pnts[(i + 1) % num_pnts];\n        var out1 = outTangents[i], in2 = inTangents[(i + 1) % num_pnts];\n        var cp1 = add(p1, out1), cp2 = add(p2, in2);\n        var len_out1 = len_vec(out1), len_in2 = len_vec(in2);\n        var len_p1p2 = len_vec(sub(p2, p1));\n        if (len_out1 !== 0 || len_in2 !== 0) {\n            var a = len_out1 === 0 ? sub(p2, p1) : out1;\n            var b = len_in2 === 0 ? sub(p1, p2) : in2;\n            if (!isStraightLine_w_delta(a, b, 0.999) && (len_out1 > len_p1p2 * 0.02 || len_in2 > len_p1p2 * 0.02)) {\n                for (var j = 1; j < subdivs; j++) {\n                    var t = $bm_div(j, subdivs);\n                    pointsF.push(getPoint(p1, cp1, cp2, p2, t));\n                }\n            }\n        }\n    }\n    pnts = pointsF;\n}\npnts = pnts.map(p => transform2D_apply(shape_transform_matrix, p));\nnum_pts = pnts.length;\nconst zero_center_point = getCentroidPro(pnts)[4];\nlet z_coord = 0;\nswitch (1) {\ncase 0:\n    z_coord = $bm_div($bm_neg(depth), 2);\n    break;\ncase 1:\n    z_coord = 0;\n    break;\ncase 2:\n    z_coord = $bm_div(depth, 2);\n    break;\n}\n;\nconst zero_center_point_3D = [\n    ...zero_center_point,\n    z_coord\n];\nconst pivot_matrix = transformMatrix([\n    0,\n    0,\n    z_coord\n], 1, [\n    0,\n    0,\n    0\n], [\n    0,\n    0,\n    0\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst pivot_position = make_transform(pivot_matrix, zero_center_point);\nconst tr_front_mat = transformMatrix([\n    0,\n    0,\n    $bm_div($bm_neg(depth), 2)\n], scale_front, zero_center_point_3D, [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst tr_back_mat = transformMatrix([\n    0,\n    0,\n    $bm_div(depth, 2)\n], scale_back, zero_center_point_3D, [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst rot_matrix = transformMatrix([\n    0,\n    0,\n    0\n], 1, [\n    0,\n    0,\n    0\n], [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], [\n    0,\n    0,\n    0\n], [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst z1_transformed = make_transform(rot_matrix, [\n    0,\n    0,\n    -1\n]);\nconst front_facing_towards_us = isVectorFacingTowardsUs(z1_transformed);\nlet points_front_3D = pnts.map(pnt => make_transform(tr_front_mat, pnt));\nlet points_back_3D = pnts.map(pnt => make_transform(tr_back_mat, pnt));\nlet winding_sides = [];\nlet sorted_sides = [];\nlet sorted_side_colors = [];\nlet num_sides_towards_us = 0;\nfor (var i = 0; i < num_pts; i++) {\n    if (!is_path_closed && i == num_pts - 1) {\n        break;\n    }\n    var F1 = points_front_3D[i], F2 = points_front_3D[(i + 1) % num_pts];\n    var B1 = points_back_3D[i], B2 = points_back_3D[(i + 1) % num_pts];\n    let abs_side_normal = getNormal([\n        F2,\n        F1,\n        B1\n    ], true);\n    let real_side_normal = !is_front_clockwise ? mul(abs_side_normal, -1) : abs_side_normal;\n    const sideIsFacingUs = isFacingTowardsUs([\n        0,\n        0,\n        0\n    ], real_side_normal);\n    if (sideIsFacingUs) {\n        num_sides_towards_us++;\n    }\n    winding_sides.push(sideIsFacingUs);\n    let side_sorted = [\n        F2,\n        F1,\n        B1,\n        B2\n    ];\n    side_sorted.sort((a, b) => b[2] - a[2]);\n    sorted_sides.push([\n        side_sorted,\n        i,\n        $bm_mod($bm_sum(i, 1), num_pts),\n        abs_side_normal\n    ]);\n}\ncompare_sides = function (side1, side2) {\n    const s1_vertices_z = side1[0].map(v => v[2]), s2_vertices_z = side2[0].map(v => v[2]);\n    for (var i = 0, il = side1[0].length; i < il; i++) {\n        if (s1_vertices_z[i] != s2_vertices_z[i]) {\n            return $bm_sub(s2_vertices_z[i], s1_vertices_z[i]);\n        }\n    }\n};\nsorted_sides.sort((a, b) => compare_sides(a, b));\nsorted_sides.sort(function (a, b) {\n    const fa = winding_sides[a[1]], fb = winding_sides[b[1]];\n    if (fa && !fb) {\n        return -1;\n    } else if (!fa && fb) {\n        return 1;\n    } else {\n        return 0;\n    }\n});\nsorted_sides_indices = sorted_sides.map(p => [\n    p[1],\n    p[2]\n]);\nif (true) {\n    const lambert_max = extrudalizer('Sides fill shadow opacity').value;\n    const rgba = extrudalizer('Sides color').value;\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    lambertShader = function (normal, max_value, multiplier) {\n        return $bm_div($bm_mul($bm_mul(multiplier, $bm_sub(100, max_value)), Math.abs(dot_(normal, [\n            0,\n            0,\n            1\n        ]))), 100);\n    };\n    sorted_side_colors = sorted_sides.map(p => adjustColorBrightness(rgba, lambertShader(p[3], lambert_max, 2)));\n}\nconst front_normal = div(z1_transformed, len_vec(z1_transformed));\nlet bb_front_2D = [], bb_back_2D = [], bb_front_transforms_te = [], bb_back_transforms_te = [], bb_front_transforms_tl = [], bb_back_transforms_tl = [];\nif (use_bb_back || use_bb_front) {\n    const bb = getBoundingBox(pnts);\n    let hasParent = shape_layer.hasParent;\n    let parent_transform_matrix = null;\n    if (hasParent) {\n        let p_pos = shape_layer.parent.transform.position;\n        let p_anchor = shape_layer.parent.transform.anchorPoint;\n        let p_rot = shape_layer.parent.transform.rotation;\n        let p_sca = shape_layer.parent.transform.scale;\n        parent_transform_matrix = get_transform_shape_matrix(p_anchor, p_pos, p_sca, p_rot, 0, 0);\n    }\n    if (use_bb_front) {\n        const bb_front_data = get_transforms_from_bb(bb, tr_front_mat, layer_transform_matrix, parent_transform_matrix, true, front_facing_towards_us, 3);\n        bb_front_2D = bb_front_data['boundingBoxTransformed'];\n        bb_front_transforms_te = bb_front_data['transformEffectControls'];\n        bb_front_transforms_tl = bb_front_data['transformLayerControls'];\n    }\n    if (use_bb_back) {\n        const bb_back_data = get_transforms_from_bb(bb, tr_back_mat, layer_transform_matrix, parent_transform_matrix, false, front_facing_towards_us, 3);\n        bb_back_2D = bb_back_data['boundingBoxTransformed'];\n        bb_back_transforms_te = bb_back_data['transformEffectControls'];\n        bb_back_transforms_tl = bb_back_data['transformLayerControls'];\n    }\n}\nlet grad_property = null;\ntry {\n    grad_property = shape_contents('ADBE Vector Graphic - G-Fill');\n} catch (e) {\n}\nlet grad_start_front_new = [\n    0,\n    0\n];\nlet grad_end_front_new = [\n    0,\n    0\n];\nlet grad_start_back_new = [\n    0,\n    0\n];\nlet grad_end_back_new = [\n    0,\n    0\n];\nif (grad_property != null) {\n    let grad_start = grad_property.startPoint.value;\n    let grad_end = grad_property.endPoint.value;\n    grad_start = transform2D_apply(shape_transform_matrix, grad_start);\n    grad_end = transform2D_apply(shape_transform_matrix, grad_end);\n    const grad_start_front = make_transform(tr_front_mat, grad_start);\n    const grad_end_front = make_transform(tr_front_mat, grad_end);\n    const grad_start_back = make_transform(tr_back_mat, grad_start);\n    const grad_end_back = make_transform(tr_back_mat, grad_end);\n    grad_start_front_new = grad_start_front;\n    grad_end_front_new = grad_end_front;\n    grad_start_back_new = grad_start_back;\n    grad_end_back_new = grad_end_back;\n    const grad_front_rot = $bm_div($bm_mul(extrudalizer('Front gradient direction').value, Math.PI), 180);\n    const grad_back_rot = $bm_div($bm_mul(extrudalizer('Back gradient direction').value, Math.PI), 180);\n    if (!arraysEqual([\n            grad_front_rot,\n            grad_back_rot\n        ], [\n            0,\n            0\n        ])) {\n        const grad_origin_front = div(add(grad_end_front, grad_start_front), 2);\n        const grad_origin_back = div(add(grad_end_back, grad_start_back), 2);\n        const grad_p_st_front = sub(grad_start_front, grad_origin_front);\n        const grad_p_end_front = sub(grad_end_front, grad_origin_front);\n        const grad_p_st_back = sub(grad_start_back, grad_origin_back);\n        const grad_p_end_back = sub(grad_end_back, grad_origin_back);\n        if (grad_front_rot != 0) {\n            const cos_st = Math.cos(grad_front_rot), sin_st = Math.sin(grad_front_rot);\n            grad_start_front_new[0] = $bm_sum($bm_sub($bm_mul(cos_st, grad_p_st_front[0]), $bm_mul(sin_st, grad_p_st_front[1])), grad_origin_front[0]);\n            grad_start_front_new[1] = $bm_sum($bm_sum($bm_mul(sin_st, grad_p_st_front[0]), $bm_mul(cos_st, grad_p_st_front[1])), grad_origin_front[1]);\n            grad_end_front_new[0] = $bm_sum($bm_sub($bm_mul(cos_st, grad_p_end_front[0]), $bm_mul(sin_st, grad_p_end_front[1])), grad_origin_front[0]);\n            grad_end_front_new[1] = $bm_sum($bm_sum($bm_mul(sin_st, grad_p_end_front[0]), $bm_mul(cos_st, grad_p_end_front[1])), grad_origin_front[1]);\n        }\n        if (grad_back_rot != 0) {\n            const cos_st_b = Math.cos(grad_back_rot), sin_st_b = Math.sin(grad_back_rot);\n            grad_start_back_new[0] = $bm_sum($bm_sub($bm_mul(cos_st_b, grad_p_st_back[0]), $bm_mul(sin_st_b, grad_p_st_back[1])), grad_origin_back[0]);\n            grad_start_back_new[1] = $bm_sum($bm_sum($bm_mul(sin_st_b, grad_p_st_back[0]), $bm_mul(cos_st_b, grad_p_st_back[1])), grad_origin_back[1]);\n            grad_end_back_new[0] = $bm_sum($bm_sub($bm_mul(cos_st_b, grad_p_end_back[0]), $bm_mul(sin_st_b, grad_p_end_back[1])), grad_origin_back[0]);\n            grad_end_back_new[1] = $bm_sum($bm_sum($bm_mul(sin_st_b, grad_p_end_back[0]), $bm_mul(cos_st_b, grad_p_end_back[1])), grad_origin_back[1]);\n        }\n    }\n}\nconst extr_data = [\n    tr_front_mat,\n    tr_back_mat,\n    shape_transform_matrix,\n    subdivs,\n    is_path_closed,\n    points_front_3D,\n    points_back_3D,\n    sorted_sides_indices,\n    front_facing_towards_us,\n    is_front_clockwise,\n    num_sides_towards_us,\n    sorted_side_colors,\n    pivot_position,\n    front_normal,\n    bb_front_2D,\n    bb_back_2D,\n    bb_front_transforms_te,\n    bb_back_transforms_te,\n    bb_front_transforms_tl,\n    bb_back_transforms_tl,\n    grad_start_front_new,\n    grad_end_front_new,\n    grad_start_back_new,\n    grad_end_back_new\n];\nvar txt = '';\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'] = extr_data;\n} catch (err) {\n    stringify = function (data, separator) {\n        return data.map(item => Array.isArray(item) ? item.join(',') : item.toString()).join(separator);\n    };\n    txt = stringify(extr_data, ';');\n}\n$bm_rt = txt;"},"p":{},"m":{"g":1,"a":{"a":0,"k":[0,0],"ix":2}},"a":[]},"ip":0,"op":300,"st":0,"ct":1,"bm":0}]},{"id":"comp_1","nm":"MAP || Dice || square_1 || SIDE  [3]","fr":30,"layers":[{"ddd":0,"ind":1,"ty":4,"nm":"SELFIE Outlines","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[108.359,-25.632,0],"ix":1,"l":2},"s":{"a":0,"k":[80,80,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[-3.045,-0.87],[-2.755,0],[0,11.239],[6.961,4.423],[0,0],[0,2.61],[-6.308,0],[-3.698,-2.538],[0,0],[2.538,0.798],[2.538,0],[0,-11.021],[-5.873,-3.408],[0,0],[0,-2.465],[6.743,0],[3.771,2.61]],"o":[[1.668,1.378],[2.973,0.943],[13.052,0],[0,-5.438],[0,0],[-3.771,-2.393],[0,-4.641],[4.133,0],[0,0],[-1.16,-1.088],[-2.538,-0.798],[-12.254,0],[0,5.656],[0,0],[3.771,2.248],[0,5.003],[-4.568,0],[0,0]],"v":[[-0.073,-3.771],[6.961,-0.435],[15.59,0.943],[36.907,-16.75],[27.844,-30.092],[23.566,-32.847],[18.345,-39.445],[27.409,-46.044],[39.155,-42.273],[40.605,-48.074],[35.022,-50.974],[27.336,-52.207],[7.106,-35.82],[15.88,-22.188],[20.013,-19.723],[25.668,-12.689],[15.517,-5.221],[1.305,-9.499]],"c":true},"ix":2},"nm":"S","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"S","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[75.278,-6.526],[54.323,-6.526],[58.166,-23.203],[75.785,-23.203],[77.236,-29.874],[59.688,-29.874],[63.169,-44.594],[81.731,-44.594],[83.181,-51.192],[52.437,-51.192],[40.691,0],[73.828,0]],"c":true},"ix":2},"nm":"E","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"E","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[113.786,-6.526],[94.426,-6.526],[104.795,-51.192],[92.613,-51.192],[80.867,0],[112.263,0]],"c":true},"ix":2},"nm":"L","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"L","np":3,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[135.132,-22.333],[152.317,-22.333],[153.84,-28.931],[136.655,-28.931],[140.353,-44.594],[159.06,-44.594],[160.51,-51.192],[129.621,-51.192],[117.875,0],[130.056,0]],"c":true},"ix":2},"nm":"F","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"F","np":3,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[179.459,-51.192],[167.277,-51.192],[155.531,0],[167.712,0]],"c":true},"ix":2},"nm":"I","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"I","np":3,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[212.942,-6.526],[191.987,-6.526],[195.83,-23.203],[213.449,-23.203],[214.9,-29.874],[197.352,-29.874],[200.833,-44.594],[219.395,-44.594],[220.845,-51.192],[190.101,-51.192],[178.355,0],[211.492,0]],"c":true},"ix":2},"nm":"E","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"E","np":3,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":300,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":2,"ty":5,"nm":"SELFIE","hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[108.359,-25.632,0],"ix":1,"l":2},"s":{"a":0,"k":[80,80,100],"ix":6,"l":2}},"ao":0,"t":{"d":{"k":[{"s":{"s":72,"f":"Taxon-BoldIt","t":"SELFIE","ca":0,"j":0,"tr":0,"lh":86.4000015258789,"ls":0,"fc":[0,0.325,0.451]},"t":0}]},"p":{},"m":{"g":1,"a":{"a":0,"k":[0,0],"ix":2}},"a":[]},"ip":0,"op":300,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":3,"ty":4,"nm":"MAP || Dice || square_1 || SIDE  [3]","hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nconst h = 300;\nconst w = 300;\nvar side_points = [\n    [\n        -w / 2,\n        -h / 2\n    ],\n    [\n        -w / 2,\n        h / 2\n    ],\n    [\n        w / 2,\n        h / 2\n    ],\n    [\n        w / 2,\n        -h / 2\n    ]\n];\n$bm_rt = createPath(side_points, [], [], true);"},"nm":"ORIGIN PATH","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":3,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":0,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"ORIGIN SIDE","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":300,"st":0,"ct":1,"bm":0}]},{"id":"comp_2","nm":"MAP || Dice || square_1 || SIDE  [2]","fr":30,"layers":[{"ddd":0,"ind":1,"ty":4,"nm":"HUG Outlines","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[77.329,-25.632,0],"ix":1,"l":2},"s":{"a":0,"k":[80,80,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[18.998,-23.203],[35.892,-23.203],[30.599,0],[42.926,0],[54.672,-51.192],[42.346,-51.192],[37.415,-29.874],[20.52,-29.874],[25.451,-51.192],[13.269,-51.192],[1.523,0],[13.704,0]],"c":true},"ix":2},"nm":"H","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"H","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[1.523,-1.958],[4.496,0],[0,4.133],[-0.87,3.698],[0,0],[0,0],[0,0],[0,-2.683],[-8.629,0],[-3.988,5.076],[-1.45,6.453],[0,0]],"o":[[0,0],[-1.233,5.293],[-2.248,2.973],[-5.221,0],[0,-2.248],[0,0],[0,0],[0,0],[-0.798,3.408],[0,10.151],[8.991,0],[2.32,-2.973],[0,0],[0,0]],"v":[[98.174,-51.192],[90.923,-19.795],[86.79,-8.919],[76.639,-4.496],[68.373,-11.529],[69.678,-20.448],[76.784,-51.192],[64.602,-51.192],[57.714,-21.245],[56.481,-12.109],[73.738,1.015],[93.244,-6.598],[98.899,-20.81],[105.86,-51.192]],"c":true},"ix":2},"nm":"U","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"U","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[2.248,0],[0,8.629],[-4.641,5.438],[-5.366,0],[-3.843,-2.32],[0,0],[5.873,0],[5.148,-4.931],[0,-10.369],[-12.399,0],[-6.091,2.465]],"o":[[0,0],[0,0],[0,0],[0,0],[-1.523,0.363],[-5.873,0],[0,-9.354],[2.9,-3.48],[4.278,0],[0,0],[-3.916,-2.828],[-8.266,0],[-7.178,6.743],[0,11.819],[6.671,0],[0,0]],"v":[[151.11,-26.684],[130.807,-26.684],[129.357,-20.303],[138.058,-20.303],[134.795,-6.018],[129.14,-5.438],[119.351,-18.127],[126.312,-40.243],[138.711,-45.464],[150.82,-41.983],[152.125,-47.929],[137.406,-52.207],[117.32,-44.811],[106.879,-17.837],[126.457,0.943],[145.599,-2.755]],"c":true},"ix":2},"nm":"G","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"G","np":3,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":300,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":2,"ty":5,"nm":"HUG","hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[77.329,-25.632,0],"ix":1,"l":2},"s":{"a":0,"k":[80,80,100],"ix":6,"l":2}},"ao":0,"t":{"d":{"k":[{"s":{"s":72,"f":"Taxon-BoldIt","t":"HUG","ca":0,"j":0,"tr":0,"lh":86.4000015258789,"ls":0,"fc":[0,0.325,0.451]},"t":0}]},"p":{},"m":{"g":1,"a":{"a":0,"k":[0,0],"ix":2}},"a":[]},"ip":0,"op":300,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":3,"ty":4,"nm":"MAP || Dice || square_1 || SIDE  [2]","hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nconst h = 300;\nconst w = 300;\nvar side_points = [\n    [\n        -w / 2,\n        -h / 2\n    ],\n    [\n        -w / 2,\n        h / 2\n    ],\n    [\n        w / 2,\n        h / 2\n    ],\n    [\n        w / 2,\n        -h / 2\n    ]\n];\n$bm_rt = createPath(side_points, [], [], true);"},"nm":"ORIGIN PATH","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":3,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":0,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"ORIGIN SIDE","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":300,"st":0,"ct":1,"bm":0}]},{"id":"comp_3","nm":"MAP || Dice || square_1 || SIDE  [1]","fr":30,"layers":[{"ddd":0,"ind":1,"ty":4,"nm":"NUMBER Outlines","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[152.355,-25.125,0],"ix":1,"l":2},"s":{"a":0,"k":[80,80,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[-1.668,8.266],[0,0],[0,0],[0,0],[0,0],[1.378,-6.888],[5.873,20.085],[0,0],[0,0]],"o":[[4.568,-19.505],[0,0],[0,0],[0,0],[0,0],[-4.133,18.055],[-1.233,-4.931],[0,0],[0,0],[0,0]],"v":[[9.136,0],[18.49,-41.621],[30.164,0],[42.346,0],[54.092,-51.192],[46.551,-51.192],[38.285,-13.704],[27.699,-51.192],[13.342,-51.192],[1.595,0]],"c":true},"ix":2},"nm":"N","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"N","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[1.523,-1.958],[4.496,0],[0,4.133],[-0.87,3.698],[0,0],[0,0],[0,0],[0,-2.683],[-8.629,0],[-3.988,5.076],[-1.45,6.453],[0,0]],"o":[[0,0],[-1.233,5.293],[-2.248,2.973],[-5.221,0],[0,-2.248],[0,0],[0,0],[0,0],[-0.798,3.408],[0,10.151],[8.991,0],[2.32,-2.973],[0,0],[0,0]],"v":[[97.67,-51.192],[90.419,-19.795],[86.286,-8.919],[76.135,-4.496],[67.869,-11.529],[69.174,-20.448],[76.28,-51.192],[64.098,-51.192],[57.21,-21.245],[55.977,-12.109],[73.234,1.015],[92.74,-6.598],[98.395,-20.81],[105.356,-51.192]],"c":true},"ix":2},"nm":"U","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"U","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[-0.145,-2.973],[-1.088,-16.315],[0,0],[0,0],[4.568,-19.505],[0,0],[0,0],[0,0],[1.958,-3.988],[0.508,6.888],[0,0],[0,0],[0,0]],"o":[[0.073,1.088],[0.29,5.946],[0,0],[0,0],[-2.393,9.281],[0,0],[0,0],[0,0],[-10.876,20.085],[-1.088,-17.185],[0,0],[0,0],[0,0],[0,0]],"v":[[120.804,-43.216],[121.167,-37.198],[123.342,-2.755],[132.913,-2.755],[154.594,-43.143],[144.225,0],[155.754,0],[167.5,-51.192],[152.201,-51.192],[132.986,-15.082],[130.665,-51.192],[115.366,-51.192],[103.619,0],[111.16,0]],"c":true},"ix":2},"nm":"M","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"M","np":3,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[-3.045,1.16],[0,7.614],[6.018,0.798],[0,7.541],[5.148,1.088],[4.786,0],[0,0],[0,0]],"o":[[7.106,0],[7.541,-2.755],[0,-5.221],[7.541,-1.668],[0,-4.931],[-3.263,-0.725],[0,0],[0,0],[0,0]],"v":[[182.284,0],[197.511,-1.74],[208.823,-17.257],[199.614,-26.974],[211.433,-41.041],[203.747,-50.104],[191.638,-51.192],[177.861,-51.192],[166.115,0]],"c":true},"ix":2},"nm":"B","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[-1.088,-0.798],[0,-2.248],[3.408,-1.523],[3.408,0],[0,0]],"o":[[0,0],[3.118,0],[1.378,1.088],[0,4.278],[-1.595,0.725],[0,0],[0,0]],"v":[[183.662,-23.566],[187.795,-23.566],[194.031,-22.333],[196.134,-17.257],[190.768,-7.033],[183.3,-5.946],[179.674,-5.946]],"c":true},"ix":2},"nm":"B","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[-0.943,-0.725],[0,-2.03],[2.828,-1.233],[2.538,0],[0,0]],"o":[[0,0],[2.9,0],[1.378,0.943],[0,3.771],[-1.45,0.653],[0,0],[0,0]],"v":[[188.665,-45.246],[191.131,-45.246],[196.931,-44.158],[199.034,-39.735],[194.466,-30.454],[188.52,-29.439],[185.04,-29.439]],"c":true},"ix":2},"nm":"B","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":1,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"B","np":6,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[247.79,-6.526],[226.835,-6.526],[230.678,-23.203],[248.297,-23.203],[249.748,-29.874],[232.2,-29.874],[235.681,-44.594],[254.243,-44.594],[255.693,-51.192],[224.949,-51.192],[213.203,0],[246.34,0]],"c":true},"ix":2},"nm":"E","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"E","np":3,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,7.831],[4.496,1.523],[4.931,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[7.469,-2.32],[0,-5.148],[-2.755,-0.943],[0,0],[0,0],[0,0],[0,0]],"v":[[270.346,-20.81],[277.597,-20.81],[283.398,0],[295.869,0],[288.763,-22.551],[300.365,-39.663],[293.622,-49.742],[282.093,-51.192],[265.125,-51.192],[253.379,0],[265.56,0]],"c":true},"ix":2},"nm":"R","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[-1.088,-0.87],[0,-2.248],[3.118,-2.03],[3.408,0],[0,0]],"o":[[0,0],[2.9,0],[1.305,1.015],[0,4.278],[-1.595,1.015],[0,0],[0,0]],"v":[[276.002,-45.319],[280.352,-45.319],[286.371,-44.013],[288.328,-39.155],[283.688,-27.989],[276.219,-26.466],[271.651,-26.466]],"c":true},"ix":2},"nm":"R","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":1,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"R","np":5,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":300,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":2,"ty":5,"nm":"NUMBER","hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[152.355,-25.125,0],"ix":1,"l":2},"s":{"a":0,"k":[80,80,100],"ix":6,"l":2}},"ao":0,"t":{"d":{"k":[{"s":{"s":72,"f":"Taxon-BoldIt","t":"NUMBER","ca":0,"j":0,"tr":0,"lh":86.4000015258789,"ls":0,"fc":[0,0.325,0.451]},"t":0}]},"p":{},"m":{"g":1,"a":{"a":0,"k":[0,0],"ix":2}},"a":[]},"ip":0,"op":300,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":3,"ty":4,"nm":"MAP || Dice || square_1 || SIDE  [1]","hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nconst h = 300;\nconst w = 300;\nvar side_points = [\n    [\n        -w / 2,\n        -h / 2\n    ],\n    [\n        -w / 2,\n        h / 2\n    ],\n    [\n        w / 2,\n        h / 2\n    ],\n    [\n        w / 2,\n        -h / 2\n    ]\n];\n$bm_rt = createPath(side_points, [], [], true);"},"nm":"ORIGIN PATH","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":3,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":0,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"ORIGIN SIDE","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":300,"st":0,"ct":1,"bm":0}]},{"id":"comp_4","nm":"MAP || Dice || square_1 || SIDE  [0]","fr":30,"layers":[{"ddd":0,"ind":1,"ty":4,"nm":"SLAP Outlines","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[86.059,-25.632,0],"ix":1,"l":2},"s":{"a":0,"k":[80,80,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[-3.045,-0.87],[-2.755,0],[0,11.239],[6.961,4.423],[0,0],[0,2.61],[-6.308,0],[-3.698,-2.538],[0,0],[2.538,0.798],[2.538,0],[0,-11.021],[-5.873,-3.408],[0,0],[0,-2.465],[6.743,0],[3.771,2.61]],"o":[[1.668,1.378],[2.973,0.943],[13.052,0],[0,-5.438],[0,0],[-3.771,-2.393],[0,-4.641],[4.133,0],[0,0],[-1.16,-1.088],[-2.538,-0.798],[-12.254,0],[0,5.656],[0,0],[3.771,2.248],[0,5.003],[-4.568,0],[0,0]],"v":[[-0.073,-3.771],[6.961,-0.435],[15.59,0.943],[36.907,-16.75],[27.844,-30.092],[23.566,-32.847],[18.345,-39.445],[27.409,-46.044],[39.155,-42.273],[40.605,-48.074],[35.022,-50.974],[27.336,-52.207],[7.106,-35.82],[15.88,-22.188],[20.013,-19.723],[25.668,-12.689],[15.517,-5.221],[1.305,-9.499]],"c":true},"ix":2},"nm":"S","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"S","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[73.61,-6.526],[54.25,-6.526],[64.619,-51.192],[52.437,-51.192],[40.691,0],[72.087,0]],"c":true},"ix":2},"nm":"L","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"L","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[92.115,-14.357],[108.648,-14.357],[110.025,0],[122.642,0],[117.204,-51.192],[104.877,-51.192],[75.293,0],[84.212,0]],"c":true},"ix":2},"nm":"A","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[-0.798,-10.586],[0,0]],"o":[[0.145,3.698],[0,0],[0,0]],"v":[[106.907,-42.346],[108.285,-20.955],[95.523,-20.955]],"c":true},"ix":2},"nm":"A","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":1,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"A","np":5,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[-3.625,1.233],[-1.958,3.48],[0,4.278],[4.351,1.523],[4.496,0],[0,0],[0,0],[0,0]],"o":[[0,0],[5.221,0],[3.843,-1.233],[1.885,-3.408],[0,-5.003],[-3.118,-1.088],[0,0],[0,0],[0,0],[0,0]],"v":[[144.991,-19.36],[150.792,-19.36],[164.062,-21.245],[172.69,-28.351],[175.518,-39.88],[168.992,-49.597],[157.608,-51.192],[140.133,-51.192],[128.387,0],[140.568,0]],"c":true},"ix":2},"nm":"P","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[-1.233,-0.943],[0,-2.175],[0.87,-2.465],[1.523,-0.943],[2.973,0],[0,0]],"o":[[0,0],[2.973,0],[1.378,0.943],[0,2.32],[-0.87,2.465],[-1.813,1.015],[0,0],[0,0]],"v":[[150.937,-45.101],[155.07,-45.101],[161.379,-43.723],[163.409,-39.01],[162.104,-31.832],[158.478,-26.756],[151.227,-25.233],[146.369,-25.233]],"c":true},"ix":2},"nm":"P","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":1,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"P","np":5,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":300,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":2,"ty":5,"nm":"SLAP","hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[86.059,-25.632,0],"ix":1,"l":2},"s":{"a":0,"k":[80,80,100],"ix":6,"l":2}},"ao":0,"t":{"d":{"k":[{"s":{"s":72,"f":"Taxon-BoldIt","t":"SLAP","ca":0,"j":0,"tr":0,"lh":86.4000015258789,"ls":0,"fc":[0,0.325,0.451]},"t":0}]},"p":{},"m":{"g":1,"a":{"a":0,"k":[0,0],"ix":2}},"a":[]},"ip":0,"op":300,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":3,"ty":4,"nm":"MAP || Dice || square_1 || SIDE  [0]","hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nconst h = 300;\nconst w = 300;\nvar side_points = [\n    [\n        -w / 2,\n        -h / 2\n    ],\n    [\n        -w / 2,\n        h / 2\n    ],\n    [\n        w / 2,\n        h / 2\n    ],\n    [\n        w / 2,\n        -h / 2\n    ]\n];\n$bm_rt = createPath(side_points, [], [], true);"},"nm":"ORIGIN PATH","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":3,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":0,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"ORIGIN SIDE","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":300,"st":0,"ct":1,"bm":0}]},{"id":"comp_5","nm":"MAP || Dice || square_1 || BACK","fr":30,"layers":[{"ddd":0,"ind":1,"ty":4,"nm":"DARE Outlines","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[93.895,-25.596,0],"ix":1,"l":2},"s":{"a":0,"k":[80,80,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[-3.698,1.16],[-2.828,6.163],[0,6.381],[6.671,2.103],[5.438,0],[0,0],[0,0]],"o":[[7.759,0],[6.598,-1.958],[2.828,-6.091],[0,-8.339],[-3.553,-1.088],[0,0],[0,0],[0,0]],"v":[[15.227,0],[32.484,-1.74],[46.986,-15.01],[51.119,-34.007],[41.113,-49.597],[27.626,-51.192],[13.269,-51.192],[1.523,0]],"c":true},"ix":2},"nm":"D","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[-1.668,-1.523],[0,-4.278],[1.595,-5.221],[2.973,-2.103],[4.641,0],[0,0]],"o":[[0,0],[3.843,0],[1.813,1.668],[0,4.206],[-1.668,5.221],[-2.465,1.74],[0,0],[0,0]],"v":[[24.073,-45.029],[27.916,-45.029],[36.182,-42.708],[38.865,-33.862],[36.472,-19.723],[29.511,-8.774],[18.853,-6.163],[15.155,-6.163]],"c":true},"ix":2},"nm":"D","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":1,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"D","np":5,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[65.115,-14.357],[81.648,-14.357],[83.025,0],[95.642,0],[90.204,-51.192],[77.877,-51.192],[48.293,0],[57.212,0]],"c":true},"ix":2},"nm":"A","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[-0.798,-10.586],[0,0]],"o":[[0.145,3.698],[0,0],[0,0]],"v":[[79.907,-42.346],[81.285,-20.955],[68.523,-20.955]],"c":true},"ix":2},"nm":"A","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":1,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"A","np":5,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,7.831],[4.496,1.523],[4.931,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[7.469,-2.32],[0,-5.148],[-2.755,-0.943],[0,0],[0,0],[0,0],[0,0]],"v":[[118.354,-20.81],[125.605,-20.81],[131.406,0],[143.877,0],[136.771,-22.551],[148.373,-39.663],[141.63,-49.742],[130.101,-51.192],[113.133,-51.192],[101.387,0],[113.568,0]],"c":true},"ix":2},"nm":"R","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[-1.088,-0.87],[0,-2.248],[3.118,-2.03],[3.408,0],[0,0]],"o":[[0,0],[2.9,0],[1.305,1.015],[0,4.278],[-1.595,1.015],[0,0],[0,0]],"v":[[124.01,-45.319],[128.36,-45.319],[134.379,-44.013],[136.336,-39.155],[131.696,-27.989],[124.227,-26.466],[119.659,-26.466]],"c":true},"ix":2},"nm":"R","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":1,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"R","np":5,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[184.142,-6.526],[163.187,-6.526],[167.03,-23.203],[184.649,-23.203],[186.1,-29.874],[168.552,-29.874],[172.033,-44.594],[190.595,-44.594],[192.045,-51.192],[161.301,-51.192],[149.555,0],[182.692,0]],"c":true},"ix":2},"nm":"E","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"E","np":3,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":300,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":2,"ty":5,"nm":"DARE","hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[93.895,-25.596,0],"ix":1,"l":2},"s":{"a":0,"k":[80,80,100],"ix":6,"l":2}},"ao":0,"t":{"d":{"k":[{"s":{"s":72,"f":"Taxon-BoldIt","t":"DARE","ca":0,"j":0,"tr":0,"lh":86.4000015258789,"ls":0,"fc":[0,0.325,0.451]},"t":0}]},"p":{},"m":{"g":1,"a":{"a":0,"k":[0,0],"ix":2}},"a":[]},"ip":0,"op":300,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":3,"ty":4,"nm":"MAP || Dice || square_1 || BACK","hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nvar dot_, len_vec, angle_between, isStraightLine_w_delta, getPoint, getBoundingBox, multiplyMatrixVector3x3, multiplyMatrices3x3, multiplyArrayOfMatrices3x3, reverseMatrix, transform2D_apply;\n'use native operators';\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nangle_between = function (a, b) {\n    const dot_prod = dot_(a, b);\n    const mag_a = len_vec(a);\n    const mag_b = len_vec(b);\n    const cos_ = $bm_div(dot_prod, $bm_mul(mag_a, mag_b));\n    return cos_;\n};\nisStraightLine_w_delta = function (cp1, cp2, delta) {\n    return angle_between(cp1, cp2) <= -delta;\n};\ngetPoint = function (p1, cp1, cp2, p2, t) {\n    const x = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[0]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[0])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[0])), $bm_mul(Math.pow(t, 3), p2[0]));\n    const y = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[1]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[1])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[1])), $bm_mul(Math.pow(t, 3), p2[1]));\n    return [\n        x,\n        y\n    ];\n};\ngetBoundingBox = function (points) {\n    const boundingBox = {\n        left: Number.POSITIVE_INFINITY,\n        top: Number.POSITIVE_INFINITY,\n        right: Number.NEGATIVE_INFINITY,\n        bottom: Number.NEGATIVE_INFINITY,\n        width: undefined,\n        height: undefined,\n        center: undefined\n    };\n    points.forEach(point => {\n        boundingBox.left = Math.min(boundingBox.left, point[0]);\n        boundingBox.top = Math.min(boundingBox.top, point[1]);\n        boundingBox.right = Math.max(boundingBox.right, point[0]);\n        boundingBox.bottom = Math.max(boundingBox.bottom, point[1]);\n    });\n    boundingBox.width = sub(boundingBox.right, boundingBox.left);\n    boundingBox.height = sub(boundingBox.bottom, boundingBox.top);\n    boundingBox.center = [\n        add(boundingBox.left, $bm_div(boundingBox.width, 2)),\n        add(boundingBox.top, $bm_div(boundingBox.height, 2))\n    ];\n    return boundingBox;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nreverseMatrix = function (pivot) {\n    let invertXMatrix = [\n        -1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n    ];\n    var mat_array = [\n        [\n            1,\n            0,\n            -pivot[0],\n            0,\n            1,\n            -pivot[1],\n            0,\n            0,\n            1\n        ],\n        invertXMatrix,\n        [\n            1,\n            0,\n            pivot[0],\n            0,\n            1,\n            pivot[1],\n            0,\n            0,\n            1\n        ]\n    ];\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nconst ex_layer = comp('Dice').layer('square_1');\nlet extr_data_arr;\nlet shape_transform_matrix;\nlet subdivs;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    shape_transform_matrix = extr_data_arr[2];\n    subdivs = extr_data_arr[3];\n} catch (err) {\n    const extr_data = comp('Dice').layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    shape_transform_matrix = extr_data_arr[2].split(',').map(s => parseFloat(s));\n    subdivs = parseInt(extr_data_arr[3]);\n}\nconst targetPath = ex_layer(2)(1)(2)(1)(2);\nlet pnts = targetPath.points();\nif (subdivs > 1) {\n    const inTangents = targetPath.inTangents();\n    const outTangents = targetPath.outTangents();\n    var pointsF = [];\n    var num_pnts = pnts.length;\n    for (var i = 0; i < num_pnts; i++) {\n        var p1 = pnts[i], p2 = pnts[(i + 1) % num_pnts];\n        var out1 = outTangents[i], in2 = inTangents[(i + 1) % num_pnts];\n        var cp1 = add(p1, out1), cp2 = add(p2, in2);\n        var len_out1 = len_vec(out1), len_in2 = len_vec(in2);\n        var len_p1p2 = len_vec(sub(p2, p1));\n        pointsF.push(pnts[i]);\n        if (len_out1 !== 0 || len_in2 !== 0) {\n            var a = len_out1 === 0 ? sub(p2, p1) : out1;\n            var b = len_in2 === 0 ? sub(p1, p2) : in2;\n            if (!isStraightLine_w_delta(a, b, 0.999) && (len_out1 > len_p1p2 * 0.02 || len_in2 > len_p1p2 * 0.02)) {\n                for (var j = 1; j < subdivs; j++) {\n                    var t = $bm_div(j, subdivs);\n                    pointsF.push(getPoint(p1, cp1, cp2, p2, t));\n                }\n                ;\n            }\n            ;\n        }\n        ;\n    }\n    ;\n    pnts = pointsF;\n}\n;\nlet bb = getBoundingBox(pnts);\nif (false) {\n    pnts = pnts.map(p => transform2D_apply(reverseMatrix(bb.center), p));\n}\npnts = pnts.map(p => transform2D_apply(shape_transform_matrix, p));\n$bm_rt = createPath(pnts, [], [], true);"},"nm":"ORIGIN PATH","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":3,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":0,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[-100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"ORIGIN SHAPE","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":300,"st":0,"ct":1,"bm":0}]},{"id":"comp_6","nm":"MAP || Dice || square_1 || FRONT","fr":30,"layers":[{"ddd":0,"ind":1,"ty":4,"nm":"KISS Outlines","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[74.378,-25.632,0],"ix":1,"l":2},"s":{"a":0,"k":[80,80,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[-4.278,-9.861],[0,0],[0,0],[0,0],[0,0],[3.118,-3.698],[0,0],[0,0],[0,0],[0,0]],"o":[[2.828,7.106],[0,0],[0,0],[0,0],[0,0],[-11.819,12.689],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[19.578,-25.451],[30.309,0],[43.796,0],[30.454,-28.931],[52.28,-51.192],[42.273,-51.192],[19.795,-26.611],[25.451,-51.192],[13.269,-51.192],[1.523,0],[13.704,0]],"c":true},"ix":2},"nm":"K","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"K","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[71.603,-51.192],[59.421,-51.192],[47.675,0],[59.856,0]],"c":true},"ix":2},"nm":"I","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"I","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[-3.045,-0.87],[-2.755,0],[0,11.239],[6.961,4.423],[0,0],[0,2.61],[-6.308,0],[-3.698,-2.538],[0,0],[2.538,0.798],[2.538,0],[0,-11.021],[-5.873,-3.408],[0,0],[0,-2.465],[6.743,0],[3.771,2.61]],"o":[[1.668,1.378],[2.973,0.943],[13.052,0],[0,-5.438],[0,0],[-3.771,-2.393],[0,-4.641],[4.133,0],[0,0],[-1.16,-1.088],[-2.538,-0.798],[-12.254,0],[0,5.656],[0,0],[3.771,2.248],[0,5.003],[-4.568,0],[0,0]],"v":[[69.047,-3.771],[76.081,-0.435],[84.71,0.943],[106.027,-16.75],[96.964,-30.092],[92.686,-32.847],[87.465,-39.445],[96.529,-46.044],[108.275,-42.273],[109.725,-48.074],[104.142,-50.974],[96.456,-52.207],[76.226,-35.82],[85,-22.188],[89.133,-19.723],[94.788,-12.689],[84.637,-5.221],[70.425,-9.499]],"c":true},"ix":2},"nm":"S","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"S","np":3,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[-3.045,-0.87],[-2.755,0],[0,11.239],[6.961,4.423],[0,0],[0,2.61],[-6.308,0],[-3.698,-2.538],[0,0],[2.538,0.798],[2.538,0],[0,-11.021],[-5.873,-3.408],[0,0],[0,-2.465],[6.743,0],[3.771,2.61]],"o":[[1.668,1.378],[2.973,0.943],[13.052,0],[0,-5.438],[0,0],[-3.771,-2.393],[0,-4.641],[4.133,0],[0,0],[-1.16,-1.088],[-2.538,-0.798],[-12.254,0],[0,5.656],[0,0],[3.771,2.248],[0,5.003],[-4.568,0],[0,0]],"v":[[106.703,-3.771],[113.737,-0.435],[122.366,0.943],[143.683,-16.75],[134.62,-30.092],[130.342,-32.847],[125.121,-39.445],[134.185,-46.044],[145.931,-42.273],[147.381,-48.074],[141.798,-50.974],[134.112,-52.207],[113.882,-35.82],[122.656,-22.188],[126.789,-19.723],[132.444,-12.689],[122.293,-5.221],[108.081,-9.499]],"c":true},"ix":2},"nm":"S","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0,0.325490016563,0.450980003207,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"S","np":3,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":300,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":2,"ty":5,"nm":"KISS","hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[74.378,-25.632,0],"ix":1,"l":2},"s":{"a":0,"k":[80,80,100],"ix":6,"l":2}},"ao":0,"t":{"d":{"k":[{"s":{"s":72,"f":"Taxon-BoldIt","t":"KISS","ca":0,"j":0,"tr":0,"lh":86.4000015258789,"ls":0,"fc":[0,0.325,0.451]},"t":0}]},"p":{},"m":{"g":1,"a":{"a":0,"k":[0,0],"ix":2}},"a":[]},"ip":0,"op":300,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":3,"ty":4,"nm":"MAP || Dice || square_1 || FRONT","hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nvar dot_, len_vec, angle_between, isStraightLine_w_delta, getPoint, getBoundingBox, multiplyMatrixVector3x3, multiplyMatrices3x3, multiplyArrayOfMatrices3x3, reverseMatrix, transform2D_apply;\n'use native operators';\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nangle_between = function (a, b) {\n    const dot_prod = dot_(a, b);\n    const mag_a = len_vec(a);\n    const mag_b = len_vec(b);\n    const cos_ = $bm_div(dot_prod, $bm_mul(mag_a, mag_b));\n    return cos_;\n};\nisStraightLine_w_delta = function (cp1, cp2, delta) {\n    return angle_between(cp1, cp2) <= -delta;\n};\ngetPoint = function (p1, cp1, cp2, p2, t) {\n    const x = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[0]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[0])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[0])), $bm_mul(Math.pow(t, 3), p2[0]));\n    const y = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[1]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[1])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[1])), $bm_mul(Math.pow(t, 3), p2[1]));\n    return [\n        x,\n        y\n    ];\n};\ngetBoundingBox = function (points) {\n    const boundingBox = {\n        left: Number.POSITIVE_INFINITY,\n        top: Number.POSITIVE_INFINITY,\n        right: Number.NEGATIVE_INFINITY,\n        bottom: Number.NEGATIVE_INFINITY,\n        width: undefined,\n        height: undefined,\n        center: undefined\n    };\n    points.forEach(point => {\n        boundingBox.left = Math.min(boundingBox.left, point[0]);\n        boundingBox.top = Math.min(boundingBox.top, point[1]);\n        boundingBox.right = Math.max(boundingBox.right, point[0]);\n        boundingBox.bottom = Math.max(boundingBox.bottom, point[1]);\n    });\n    boundingBox.width = sub(boundingBox.right, boundingBox.left);\n    boundingBox.height = sub(boundingBox.bottom, boundingBox.top);\n    boundingBox.center = [\n        add(boundingBox.left, $bm_div(boundingBox.width, 2)),\n        add(boundingBox.top, $bm_div(boundingBox.height, 2))\n    ];\n    return boundingBox;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nreverseMatrix = function (pivot) {\n    let invertXMatrix = [\n        -1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n    ];\n    var mat_array = [\n        [\n            1,\n            0,\n            -pivot[0],\n            0,\n            1,\n            -pivot[1],\n            0,\n            0,\n            1\n        ],\n        invertXMatrix,\n        [\n            1,\n            0,\n            pivot[0],\n            0,\n            1,\n            pivot[1],\n            0,\n            0,\n            1\n        ]\n    ];\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nconst ex_layer = comp('Dice').layer('square_1');\nlet extr_data_arr;\nlet shape_transform_matrix;\nlet subdivs;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    shape_transform_matrix = extr_data_arr[2];\n    subdivs = extr_data_arr[3];\n} catch (err) {\n    const extr_data = comp('Dice').layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    shape_transform_matrix = extr_data_arr[2].split(',').map(s => parseFloat(s));\n    subdivs = parseInt(extr_data_arr[3]);\n}\nconst targetPath = ex_layer(2)(1)(2)(1)(2);\nlet pnts = targetPath.points();\nif (subdivs > 1) {\n    const inTangents = targetPath.inTangents();\n    const outTangents = targetPath.outTangents();\n    var pointsF = [];\n    var num_pnts = pnts.length;\n    for (var i = 0; i < num_pnts; i++) {\n        var p1 = pnts[i], p2 = pnts[(i + 1) % num_pnts];\n        var out1 = outTangents[i], in2 = inTangents[(i + 1) % num_pnts];\n        var cp1 = add(p1, out1), cp2 = add(p2, in2);\n        var len_out1 = len_vec(out1), len_in2 = len_vec(in2);\n        var len_p1p2 = len_vec(sub(p2, p1));\n        pointsF.push(pnts[i]);\n        if (len_out1 !== 0 || len_in2 !== 0) {\n            var a = len_out1 === 0 ? sub(p2, p1) : out1;\n            var b = len_in2 === 0 ? sub(p1, p2) : in2;\n            if (!isStraightLine_w_delta(a, b, 0.999) && (len_out1 > len_p1p2 * 0.02 || len_in2 > len_p1p2 * 0.02)) {\n                for (var j = 1; j < subdivs; j++) {\n                    var t = $bm_div(j, subdivs);\n                    pointsF.push(getPoint(p1, cp1, cp2, p2, t));\n                }\n                ;\n            }\n            ;\n        }\n        ;\n    }\n    ;\n    pnts = pointsF;\n}\n;\nlet bb = getBoundingBox(pnts);\nif (false) {\n    pnts = pnts.map(p => transform2D_apply(reverseMatrix(bb.center), p));\n}\npnts = pnts.map(p => transform2D_apply(shape_transform_matrix, p));\n$bm_rt = createPath(pnts, [], [], true);"},"nm":"ORIGIN PATH","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":3,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":0,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"ORIGIN SHAPE","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":300,"st":0,"ct":1,"bm":0}]},{"id":"comp_7","nm":"hug_Face","fr":30,"layers":[{"ddd":0,"ind":1,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [3]","refId":"comp_1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [2]","refId":"comp_2","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":3,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [1]","refId":"comp_3","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":4,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [0]","refId":"comp_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":5,"ty":0,"nm":"MAP || Dice || square_1 || BACK","refId":"comp_5","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('square_1').effect('Extrudalizer')('Back opacity readout');"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[150,150],"ix":1,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst is_front = false;\nconst precomp_width = 300;\nlet extr_data_arr = [];\nlet is_facing_us = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    $bm_rt = is_facing_us = extr_data_arr[8];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    $bm_rt = is_facing_us = extr_data_arr[8] == 'true';\n}\nfunction logicalXOR(input1, input2) {\n    return input1 && !input2 || !input1 && input2;\n}\nif (logicalXOR(is_front, is_facing_us)) {\n    $bm_rt = value = [\n        precomp_width,\n        0\n    ];\n} else {\n    $bm_rt = value = [\n        0,\n        0\n    ];\n}"}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst POS_INDEX_LOTTIE = 0;\nconst POS_INDEX_1 = 0;\nconst POS_INDEX_2 = 1;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let pos = [\n        0,\n        0\n    ];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        $bm_rt = pos = transform_effect_controls[POS_INDEX_LOTTIE];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        $bm_rt = pos = [\n            transform_effect_controls[POS_INDEX_1],\n            transform_effect_controls[POS_INDEX_2]\n        ];\n    }\n}"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 3;\nconst control_index_ae = 4;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.height;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 4;\nconst control_index_ae = 5;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = $bm_neg(thisLayer.width);\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 2;\nconst control_index_ae = 3;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 1;\nconst control_index_ae = 2;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'Back';\nconst face_opacity = ex_layer.effect('Extrudalizer')(face + ' opacity readout').value;\n$bm_rt = face_opacity;"}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":6,"ty":0,"nm":"MAP || Dice || square_1 || FRONT","refId":"comp_6","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('square_1').effect('Extrudalizer')('Front opacity readout');"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[150,150],"ix":1,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst is_front = true;\nconst precomp_width = 300;\nlet extr_data_arr = [];\nlet is_facing_us = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    $bm_rt = is_facing_us = extr_data_arr[8];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    $bm_rt = is_facing_us = extr_data_arr[8] == 'true';\n}\nfunction logicalXOR(input1, input2) {\n    return input1 && !input2 || !input1 && input2;\n}\nif (logicalXOR(is_front, is_facing_us)) {\n    $bm_rt = value = [\n        precomp_width,\n        0\n    ];\n} else {\n    $bm_rt = value = [\n        0,\n        0\n    ];\n}"}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst POS_INDEX_LOTTIE = 0;\nconst POS_INDEX_1 = 0;\nconst POS_INDEX_2 = 1;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let pos = [\n        0,\n        0\n    ];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        $bm_rt = pos = transform_effect_controls[POS_INDEX_LOTTIE];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        $bm_rt = pos = [\n            transform_effect_controls[POS_INDEX_1],\n            transform_effect_controls[POS_INDEX_2]\n        ];\n    }\n}"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 3;\nconst control_index_ae = 4;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.height;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 4;\nconst control_index_ae = 5;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.width;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 2;\nconst control_index_ae = 3;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 1;\nconst control_index_ae = 2;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'Front';\nconst face_opacity = ex_layer.effect('Extrudalizer')(face + ' opacity readout').value;\n$bm_rt = face_opacity;"}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":7,"ty":4,"nm":"square_1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[540,540,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":1,"k":[{"i":{"x":[0.667,0.667,0.667],"y":[1,1,1]},"o":{"x":[0.333,0.333,0.333],"y":[0,0,0]},"t":60,"s":[100,100,100]},{"t":90,"s":[180,180,100]}],"ix":6,"l":2}},"ao":0,"ef":[{"ty":5,"nm":"Extrudalizer","np":70,"mn":"Pseudo/Extrudalizer","ix":1,"en":1,"ef":[{"ty":6,"nm":"3D Transform","mn":"Pseudo/Extrudalizer-0001","ix":1,"v":0},{"ty":0,"nm":"Extrusion depth","mn":"Pseudo/Extrudalizer-0002","ix":2,"v":{"a":0,"k":300,"ix":2}},{"ty":3,"nm":"Position","mn":"Pseudo/Extrudalizer-0003","ix":3,"v":{"a":0,"k":[0,0,0],"ix":3}},{"ty":6,"nm":"Scale","mn":"Pseudo/Extrudalizer-0004","ix":4,"v":0},{"ty":0,"nm":"Front scale","mn":"Pseudo/Extrudalizer-0005","ix":5,"v":{"a":0,"k":100,"ix":5}},{"ty":0,"nm":"Back scale","mn":"Pseudo/Extrudalizer-0006","ix":6,"v":{"a":0,"k":100,"ix":6}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0007","ix":7,"v":0},{"ty":6,"nm":"Pitch/Roll/Yaw","mn":"Pseudo/Extrudalizer-0008","ix":8,"v":0},{"ty":0,"nm":"Pitch (x)","mn":"Pseudo/Extrudalizer-0009","ix":9,"v":{"a":1,"k":[{"i":{"x":[0.401],"y":[1]},"o":{"x":[0.333],"y":[0]},"t":0,"s":[-30]},{"t":60,"s":[-720]}],"ix":9}},{"ty":0,"nm":"Yaw (y)","mn":"Pseudo/Extrudalizer-0010","ix":10,"v":{"a":1,"k":[{"i":{"x":[0.401],"y":[1]},"o":{"x":[0.333],"y":[0]},"t":0,"s":[30]},{"t":60,"s":[810]}],"ix":10}},{"ty":0,"nm":"Roll (z)","mn":"Pseudo/Extrudalizer-0011","ix":11,"v":{"a":1,"k":[{"i":{"x":[0.401],"y":[1]},"o":{"x":[0.333],"y":[0]},"t":0,"s":[0]},{"t":60,"s":[-360]}],"ix":11}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0012","ix":12,"v":0},{"ty":6,"nm":"Orbit control","mn":"Pseudo/Extrudalizer-0013","ix":13,"v":0},{"ty":0,"nm":"X Rotation","mn":"Pseudo/Extrudalizer-0014","ix":14,"v":{"a":0,"k":0,"ix":14}},{"ty":0,"nm":"Y Rotation","mn":"Pseudo/Extrudalizer-0015","ix":15,"v":{"a":0,"k":0,"ix":15}},{"ty":0,"nm":"Z Rotation","mn":"Pseudo/Extrudalizer-0016","ix":16,"v":{"a":0,"k":0,"ix":16}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0017","ix":17,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0018","ix":18,"v":0},{"ty":6,"nm":"Appearance","mn":"Pseudo/Extrudalizer-0019","ix":19,"v":0},{"ty":7,"nm":"Hide anchor point","mn":"Pseudo/Extrudalizer-0020","ix":20,"v":{"a":0,"k":1,"ix":20}},{"ty":7,"nm":"Wireframe mode","mn":"Pseudo/Extrudalizer-0021","ix":21,"v":{"a":0,"k":0,"ix":21}},{"ty":2,"nm":"Edge stroke color","mn":"Pseudo/Extrudalizer-0022","ix":22,"v":{"a":0,"k":[0.996078491211,0.98431378603,0.917647123337,1],"ix":22}},{"ty":0,"nm":"Edge stroke width","mn":"Pseudo/Extrudalizer-0023","ix":23,"v":{"a":0,"k":0,"ix":23}},{"ty":0,"nm":"Translucency","mn":"Pseudo/Extrudalizer-0024","ix":24,"v":{"a":0,"k":0,"ix":24}},{"ty":6,"nm":"Front & Back ","mn":"Pseudo/Extrudalizer-0025","ix":25,"v":0},{"ty":2,"nm":"Front color","mn":"Pseudo/Extrudalizer-0026","ix":26,"v":{"a":0,"k":[0.996078491211,0.98431378603,0.917647123337,1],"ix":26}},{"ty":0,"nm":"Front opacity","mn":"Pseudo/Extrudalizer-0027","ix":27,"v":{"a":0,"k":100,"ix":27}},{"ty":0,"nm":"Front gradient opacity","mn":"Pseudo/Extrudalizer-0028","ix":28,"v":{"a":0,"k":0,"ix":28}},{"ty":0,"nm":"Front gradient direction","mn":"Pseudo/Extrudalizer-0029","ix":29,"v":{"a":0,"k":0,"ix":29}},{"ty":6,"nm":"   ","mn":"Pseudo/Extrudalizer-0030","ix":30,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0031","ix":31,"v":0},{"ty":2,"nm":"Back color","mn":"Pseudo/Extrudalizer-0032","ix":32,"v":{"a":0,"k":[0.945098102093,0.917647123337,0.776470661163,1],"ix":32}},{"ty":0,"nm":"Back opacity","mn":"Pseudo/Extrudalizer-0033","ix":33,"v":{"a":0,"k":100,"ix":33}},{"ty":0,"nm":"Back gradient opacity","mn":"Pseudo/Extrudalizer-0034","ix":34,"v":{"a":0,"k":0,"ix":34}},{"ty":0,"nm":"Back gradient direction","mn":"Pseudo/Extrudalizer-0035","ix":35,"v":{"a":0,"k":0,"ix":35}},{"ty":6,"nm":"    ","mn":"Pseudo/Extrudalizer-0036","ix":36,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0037","ix":37,"v":0},{"ty":3,"nm":"Gradient start point","mn":"Pseudo/Extrudalizer-0038","ix":38,"v":{"a":0,"k":[0,0],"ix":38}},{"ty":3,"nm":"Gradient end point","mn":"Pseudo/Extrudalizer-0039","ix":39,"v":{"a":0,"k":[0,0],"ix":39}},{"ty":6,"nm":"Edit gradient start/end points o","mn":"Pseudo/Extrudalizer-0040","ix":40,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0041","ix":41,"v":0},{"ty":6,"nm":"at 3D rotation set to [0,0,0]","mn":"Pseudo/Extrudalizer-0042","ix":42,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0043","ix":43,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0044","ix":44,"v":0},{"ty":6,"nm":"Sides","mn":"Pseudo/Extrudalizer-0045","ix":45,"v":0},{"ty":2,"nm":"Sides color","mn":"Pseudo/Extrudalizer-0046","ix":46,"v":{"a":0,"k":[0,1,1,1],"ix":46}},{"ty":0,"nm":"Sides opacity","mn":"Pseudo/Extrudalizer-0047","ix":47,"v":{"a":0,"k":100,"ix":47}},{"ty":0,"nm":"Sides gradient opacity","mn":"Pseudo/Extrudalizer-0048","ix":48,"v":{"a":0,"k":25,"ix":48}},{"ty":0,"nm":"Sides gradient direction","mn":"Pseudo/Extrudalizer-0049","ix":49,"v":{"a":0,"k":0,"ix":49}},{"ty":0,"nm":"Sides gradient length","mn":"Pseudo/Extrudalizer-0050","ix":50,"v":{"a":0,"k":0,"ix":50}},{"ty":2,"nm":"Sides fill shadow color","mn":"Pseudo/Extrudalizer-0051","ix":51,"v":{"a":0,"k":[0,0,0,1],"ix":51}},{"ty":0,"nm":"Sides fill shadow opacity","mn":"Pseudo/Extrudalizer-0052","ix":52,"v":{"a":0,"k":50,"ix":52}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0053","ix":53,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0054","ix":54,"v":0},{"ty":6,"nm":"Parenting Data","mn":"Pseudo/Extrudalizer-0055","ix":55,"v":0},{"ty":0,"nm":"Front opacity readout","mn":"Pseudo/Extrudalizer-0056","ix":56,"v":{"a":0,"k":100,"ix":56,"x":"var $bm_rt;\ntry {\n    $bm_rt = content('--- EXTRUDALIZER ---').content('FRONT').transform.opacity;\n} catch (e) {\n    $bm_rt = 0;\n}"}},{"ty":0,"nm":"Back opacity readout","mn":"Pseudo/Extrudalizer-0057","ix":57,"v":{"a":0,"k":100,"ix":57,"x":"var $bm_rt;\ntry {\n    $bm_rt = content('--- EXTRUDALIZER ---').content('BACK').transform.opacity;\n} catch (e) {\n    $bm_rt = 0;\n}"}},{"ty":7,"nm":"Compute 3D front bounding box","mn":"Pseudo/Extrudalizer-0058","ix":58,"v":{"a":0,"k":1,"ix":58}},{"ty":3,"nm":"Front upper left","mn":"Pseudo/Extrudalizer-0059","ix":59,"v":{"a":0,"k":[0,0],"ix":59,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[0];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[0],\n            front_bb[1]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front upper right","mn":"Pseudo/Extrudalizer-0060","ix":60,"v":{"a":0,"k":[0,0],"ix":60,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[1];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[2],\n            front_bb[3]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front lower left","mn":"Pseudo/Extrudalizer-0061","ix":61,"v":{"a":0,"k":[0,0],"ix":61,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[2];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[4],\n            front_bb[5]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front lower right","mn":"Pseudo/Extrudalizer-0062","ix":62,"v":{"a":0,"k":[0,0],"ix":62,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[3];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[6],\n            front_bb[7]\n        ];\n    }\n}"}},{"ty":7,"nm":"Compute 3D back bounding box","mn":"Pseudo/Extrudalizer-0063","ix":63,"v":{"a":0,"k":1,"ix":63}},{"ty":3,"nm":"Back upper left","mn":"Pseudo/Extrudalizer-0064","ix":64,"v":{"a":0,"k":[0,0],"ix":64,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[0];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[0],\n            back_bb[1]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back upper right","mn":"Pseudo/Extrudalizer-0065","ix":65,"v":{"a":0,"k":[0,0],"ix":65,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[1];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[2],\n            back_bb[3]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back lower left","mn":"Pseudo/Extrudalizer-0066","ix":66,"v":{"a":0,"k":[0,0],"ix":66,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[2];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[4],\n            back_bb[5]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back lower right","mn":"Pseudo/Extrudalizer-0067","ix":67,"v":{"a":0,"k":[0,0],"ix":67,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[3];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[6],\n            back_bb[7]\n        ];\n    }\n}"}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0068","ix":68,"v":0}]},{"ty":5,"nm":"FACE 0","np":3,"mn":"ADBE Color Control","ix":2,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.945098042488,0.919524788857,0.774609744549,1],"ix":1}}]},{"ty":5,"nm":"FACE 1","np":3,"mn":"ADBE Color Control","ix":3,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.996078431606,0.984313726425,0.917647063732,1],"ix":1}}]},{"ty":5,"nm":"FACE 2","np":3,"mn":"ADBE Color Control","ix":4,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.945098042488,0.919524788857,0.774609744549,1],"ix":1}}]},{"ty":5,"nm":"FACE 3","np":3,"mn":"ADBE Color Control","ix":5,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.996078431606,0.984313726425,0.917647063732,1],"ix":1}}]}],"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[150,-150],[150,150],[-150,150],[-150,-150]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":true},{"ty":"st","c":{"a":0,"k":[0,0.925924921971,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":78,"ix":5},"lc":2,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"ORIGIN SHAPE","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nlet extr_data_arr;\nlet points_3D = [];\nlet isPathClosed;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_3D = extr_data_arr[5];\n    isPathClosed = extr_data_arr[4] === true;\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let points_arr = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    isPathClosed = extr_data_arr[4] === 'true';\n    for (var i = 0, il = points_arr.length / 3; i < il; i++) {\n        points_3D.push(points_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst points_2D = points_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst num_pts = points_2D.length;\nconst zeroArr = Array(num_pts).fill([\n    0,\n    0\n]);\n$bm_rt = createPath(points_2D, zeroArr, zeroArr, isPathClosed);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Front color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":2,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Front color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nlet extr_data_arr;\nlet is_facing_towards_us;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    is_facing_towards_us = extr_data_arr[8] === true;\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    is_facing_towards_us = extr_data_arr[8] === 'true';\n}\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = $bm_div(effect('Extrudalizer')('Translucency').value, 2);\nconst opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    if (is_facing_towards_us > 0) {\n        $bm_rt = opacity_value;\n    } else {\n        $bm_rt = transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"FRONT","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nlet extr_data_arr;\nlet points_3D = [];\nlet isPathClosed;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_3D = extr_data_arr[6];\n    isPathClosed = extr_data_arr[4] === true;\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let points_arr = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    isPathClosed = extr_data_arr[4] === 'true';\n    for (var i = 0, il = points_arr.length / 3; i < il; i++) {\n        points_3D.push(points_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst points_2D = points_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst num_pts = points_2D.length;\nconst zeroArr = Array(num_pts).fill([\n    0,\n    0\n]);\n$bm_rt = createPath(points_2D, zeroArr, zeroArr, isPathClosed);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Back color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Back color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    try {\n        const frontOpacity = content('--- EXTRUDALIZER ---').content('FRONT').transform.opacity.value;\n        $bm_rt = value = $bm_sub(100, frontOpacity);\n    } catch (e) {\n        $bm_rt = 100;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"BACK","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 0;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = true ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[0][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[0];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = false ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[0][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[0];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 0 - 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 1;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = true ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[1][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[1];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = false ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[1][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[1];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 1 - 2","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDES","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"--- EXTRUDALIZER ---","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":300,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":8,"ty":5,"nm":"EXTRUDALIZER DATA || square_1","hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[540,540,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"t":{"d":{"k":[{"s":{"s":36,"f":"TrajanPro-Bold","t":"","ca":0,"j":0,"tr":0,"lh":43.2000007629395,"ls":0,"fc":[0.267,0.722,0.765]},"t":0}],"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, arraysEqual, getNormal, get2D_projection, getBoundingBox, getPositionMatrix, getRotationMatrix, getScaleMatrix, getIdentity, translate, rotateX, rotateY, rotateZ, multiplyMatrixVector, multiplyMatrices, multiplyArrayOfMatrices, transformMatrix, make_transform, getPoint, getArea, isClockwise, getCentroid, getCentroidPro, hasNoneZeroValues, angle_between, angle_between_cw, angle_between_cw_te, isStraightLine_w_delta, isFacingTowardsUs, isVectorFacingTowardsUs, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_shape_matrix, get_transforms_from_bb, num_pts, compare_sides, sorted_sides_indices, adjustColorBrightness, lambertShader, stringify;\n'use native operators';\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\narraysEqual = function (arr1, arr2) {\n    for (var i = 0, il = arr1.length; i < il; i++) {\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n};\ngetNormal = function (pts, normalized) {\n    let dir = cross_vec(sub(pts[1], pts[0]), sub(pts[2], pts[0]));\n    let len_dir = len_vec(dir);\n    if (len_dir === 0) {\n        return [\n            0,\n            0,\n            0\n        ];\n    }\n    if (normalized) {\n        return div(dir, len_dir);\n    } else {\n        return dir;\n    }\n};\nget2D_projection = function (points) {\n    return points.map(v => [\n        v[0],\n        v[1]\n    ]);\n};\ngetBoundingBox = function (points) {\n    const boundingBox = {\n        left: Number.POSITIVE_INFINITY,\n        top: Number.POSITIVE_INFINITY,\n        right: Number.NEGATIVE_INFINITY,\n        bottom: Number.NEGATIVE_INFINITY,\n        width: undefined,\n        height: undefined,\n        center: undefined\n    };\n    points.forEach(point => {\n        boundingBox.left = Math.min(boundingBox.left, point[0]);\n        boundingBox.top = Math.min(boundingBox.top, point[1]);\n        boundingBox.right = Math.max(boundingBox.right, point[0]);\n        boundingBox.bottom = Math.max(boundingBox.bottom, point[1]);\n    });\n    boundingBox.width = sub(boundingBox.right, boundingBox.left);\n    boundingBox.height = sub(boundingBox.bottom, boundingBox.top);\n    boundingBox.center = [\n        add(boundingBox.left, $bm_div(boundingBox.width, 2)),\n        add(boundingBox.top, $bm_div(boundingBox.height, 2))\n    ];\n    boundingBox.left_top = [\n        boundingBox.left,\n        boundingBox.top\n    ];\n    boundingBox.left_bottom = [\n        boundingBox.left,\n        boundingBox.bottom\n    ];\n    boundingBox.right_top = [\n        boundingBox.right,\n        boundingBox.top\n    ];\n    boundingBox.right_bottom = [\n        boundingBox.right,\n        boundingBox.bottom\n    ];\n    return boundingBox;\n};\ngetPositionMatrix = function (value) {\n    return translate(getIdentity(), value[0], value[1], $bm_neg(value[2]));\n};\ngetRotationMatrix = function (angles) {\n    const angleX = angles[0];\n    const angleY = angles[1];\n    const angleZ = angles[2];\n    var matrix = getIdentity();\n    matrix = rotateZ(matrix, $bm_div($bm_mul(angleZ, Math.PI), 180));\n    matrix = rotateY(matrix, $bm_div($bm_mul(angleY, Math.PI), 180));\n    matrix = rotateX(matrix, $bm_div($bm_mul(angleX, Math.PI), 180));\n    return matrix;\n};\ngetScaleMatrix = function (sc) {\n    return [\n        sc,\n        0,\n        0,\n        0,\n        0,\n        sc,\n        0,\n        0,\n        0,\n        0,\n        sc,\n        0,\n        0,\n        0,\n        0,\n        1\n    ];\n};\ngetIdentity = function () {\n    return [\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n    ];\n};\ntranslate = function (matrix, x, y, z) {\n    return multiplyMatrices(matrix, [\n        1,\n        0,\n        0,\n        x,\n        0,\n        1,\n        0,\n        y,\n        0,\n        0,\n        1,\n        z,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateX = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        1,\n        0,\n        0,\n        0,\n        0,\n        cos_th,\n        $bm_neg(sin_th),\n        0,\n        0,\n        sin_th,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateY = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        cos_th,\n        0,\n        sin_th,\n        0,\n        0,\n        1,\n        0,\n        0,\n        $bm_neg(sin_th),\n        0,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateZ = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        cos_th,\n        $bm_neg(sin_th),\n        0,\n        0,\n        sin_th,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nmultiplyMatrixVector = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 4; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 4; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 4), j)], vector[j]));\n        }\n    }\n    return result;\n};\nmultiplyMatrices = function (matrixB, matrixA) {\n    let result = new Array(16).fill(0);\n    for (let i = 0; i < 4; i++) {\n        for (let j = 0; j < 4; j++) {\n            for (let k = 0; k < 4; k++) {\n                result[$bm_sum($bm_mul(i, 4), j)] = $bm_sum(result[$bm_sum($bm_mul(i, 4), j)], $bm_mul(matrixA[$bm_sum($bm_mul(i, 4), k)], matrixB[$bm_sum($bm_mul(k, 4), j)]));\n            }\n        }\n    }\n    return result;\n};\nmultiplyArrayOfMatrices = function (matrices) {\n    var result = matrices[0];\n    for (var i = 1, il = matrices.length; i < il; i++) {\n        result = multiplyMatrices(result, matrices[i]);\n    }\n    return result;\n};\ntransformMatrix = function (move, sc, pivot, pitch_angles, anch, orbit_angles) {\n    var mat_array = [];\n    if (sc !== 1) {\n        if (!arraysEqual(pivot, [\n                0,\n                0,\n                0\n            ])) {\n            mat_array = mat_array.concat([\n                getPositionMatrix(pivot.map(i => -i)),\n                getScaleMatrix(sc),\n                getPositionMatrix(pivot)\n            ]);\n        } else {\n            mat_array.push(getScaleMatrix(sc));\n        }\n    }\n    mat_array.push(getPositionMatrix(move));\n    if (!arraysEqual(pitch_angles, [\n            0,\n            0,\n            0\n        ])) {\n        if (!arraysEqual(pivot, [\n                0,\n                0,\n                0\n            ])) {\n            mat_array = mat_array.concat([\n                getPositionMatrix(pivot.map(i => -i)),\n                getRotationMatrix(pitch_angles),\n                getPositionMatrix(pivot)\n            ]);\n        } else {\n            mat_array.push(getRotationMatrix(pitch_angles));\n        }\n    }\n    if (!arraysEqual(anch, [\n            0,\n            0,\n            0\n        ])) {\n        mat_array.push(getPositionMatrix(anch.map(i => -i)));\n    }\n    if (!arraysEqual(orbit_angles, [\n            0,\n            0,\n            0\n        ])) {\n        mat_array.push(getRotationMatrix(orbit_angles));\n    }\n    return multiplyArrayOfMatrices(mat_array);\n};\nmake_transform = function (transform_matrix, vector) {\n    if (vector.length == 2) {\n        vector = [\n            ...vector,\n            0,\n            1\n        ];\n    } else if (vector.length == 3) {\n        vector = [\n            ...vector,\n            1\n        ];\n    }\n    var result_vector_4d = multiplyMatrixVector(transform_matrix, vector);\n    return result_vector_4d.slice(0, 3);\n};\ngetPoint = function (p1, cp1, cp2, p2, t) {\n    const x = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[0]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[0])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[0])), $bm_mul(Math.pow(t, 3), p2[0]));\n    const y = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[1]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[1])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[1])), $bm_mul(Math.pow(t, 3), p2[1]));\n    return [\n        x,\n        y\n    ];\n};\ngetArea = function (points) {\n    var area = 0;\n    for (var i = 0, il = points.length; i < il; i++) {\n        var p1 = points[i];\n        var p2 = points[(i + 1) % il];\n        area = $bm_sum(area, $bm_sub($bm_mul(p1[0], p2[1]), $bm_mul(p2[0], p1[1])));\n    }\n    return $bm_div(area, 2);\n};\nisClockwise = function (points) {\n    return getArea(points) > 0;\n};\ngetCentroid = function (vertices) {\n    var area = getArea(vertices);\n    if (area === 0) {\n        function findCenter(points) {\n            let sumX = 0;\n            let sumY = 0;\n            for (let i = 0, il = points.length; i < il; i++) {\n                const point = points[i];\n                sumX = $bm_sum(sumX, point[0]);\n                sumY = $bm_sum(sumY, point[1]);\n            }\n            const meanX = $bm_div(sumX, points.length);\n            const meanY = $bm_div(sumY, points.length);\n            return [\n                meanX,\n                meanY\n            ];\n        }\n        return findCenter(vertices);\n    }\n    let centroidX = 0;\n    let centroidY = 0;\n    const numVertices = vertices.length;\n    for (var i = 0; i < numVertices; i++) {\n        var currentVertex = vertices[i];\n        var nextVertex = vertices[(i + 1) % numVertices];\n        var commonFactor = $bm_sub($bm_mul(currentVertex[0], nextVertex[1]), $bm_mul(nextVertex[0], currentVertex[1]));\n        centroidX = $bm_sum(centroidX, $bm_mul($bm_sum(currentVertex[0], nextVertex[0]), commonFactor));\n        centroidY = $bm_sum(centroidY, $bm_mul($bm_sum(currentVertex[1], nextVertex[1]), commonFactor));\n    }\n    var scaleFactor = $bm_div(1, $bm_mul(6, area));\n    centroidX *= scaleFactor;\n    centroidY *= scaleFactor;\n    return [\n        centroidX,\n        centroidY\n    ];\n};\ngetCentroidPro = function (vertices) {\n    const bb = getBoundingBox(vertices);\n    return {\n        0: bb.left_top,\n        1: [\n            (bb.left_top[0] + bb.right_top[0]) / 2,\n            bb.left_top[1]\n        ],\n        2: bb.right_top,\n        3: [\n            (bb.left_top[0] + bb.left_bottom[0]) / 2,\n            (bb.left_top[1] + bb.left_bottom[1]) / 2\n        ],\n        4: getCentroid(vertices),\n        5: [\n            (bb.right_top[0] + bb.right_bottom[0]) / 2,\n            (bb.right_top[1] + bb.right_bottom[1]) / 2\n        ],\n        6: bb.left_bottom,\n        7: [\n            (bb.left_bottom[0] + bb.right_bottom[0]) / 2,\n            bb.left_bottom[1]\n        ],\n        8: bb.right_bottom\n    };\n};\nhasNoneZeroValues = function (array2D) {\n    return array2D.some(array => array.some(value => value !== 0));\n};\nangle_between = function (a, b) {\n    const dot_prod = dot_(a, b);\n    const mag_a = len_vec(a);\n    const mag_b = len_vec(b);\n    const cos_ = $bm_div(dot_prod, $bm_mul(mag_a, mag_b));\n    return cos_;\n};\nangle_between_cw = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    angle = angle >= 0 ? angle : $bm_sum($bm_mul(2, Math.PI), angle);\n    const degrees = $bm_mul(angle, $bm_div(180, Math.PI));\n    return degrees;\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nisStraightLine_w_delta = function (cp1, cp2, delta) {\n    return angle_between(cp1, cp2) <= -delta;\n};\nisFacingTowardsUs = function (p1, p2) {\n    return dot_(sub(p2, p1), [\n        0,\n        0,\n        1\n    ]) > 0;\n};\nisVectorFacingTowardsUs = function (v) {\n    return dot_(v, [\n        0,\n        0,\n        -1\n    ]) > 0;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_shape_matrix = function (anchor, pos, scale, rot, skew, skew_axis) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (skew !== 0) {\n        const sk_angle = $bm_div($bm_mul(skew, Math.PI), 180);\n        const Sk = [\n            1,\n            Math.tan(-sk_angle),\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            1\n        ];\n        if (skew_axis !== 0) {\n            const sk_axis_angle = $bm_div($bm_mul(skew_axis, Math.PI), 180);\n            const cos_sk = Math.cos(sk_axis_angle);\n            const sin_sk = Math.sin(sk_axis_angle);\n            const Rz = [\n                cos_sk,\n                -sin_sk,\n                0,\n                sin_sk,\n                cos_sk,\n                0,\n                0,\n                0,\n                1\n            ];\n            const Rz_inv = [\n                cos_sk,\n                sin_sk,\n                0,\n                -sin_sk,\n                cos_sk,\n                0,\n                0,\n                0,\n                1\n            ];\n            const SkM = multiplyArrayOfMatrices3x3([\n                Rz_inv,\n                Sk,\n                Rz\n            ]);\n            mat_array.push(SkM);\n        } else {\n            mat_array.push(Sk);\n        }\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nget_transforms_from_bb = function (bb, extr_transform_matrix, layer_transform_matrix, parent_transform_matrix, is_front, front_facing_towards_us, mode) {\n    let bb_transformed_3D = [];\n    if (front_facing_towards_us) {\n        bb_transformed_3D = [\n            bb.left_top,\n            bb.right_top,\n            bb.left_bottom,\n            bb.right_bottom\n        ];\n    } else {\n        bb_transformed_3D = [\n            bb.right_top,\n            bb.left_top,\n            bb.right_bottom,\n            bb.left_bottom\n        ];\n    }\n    bb_transformed_3D = bb_transformed_3D.map(pnt => make_transform(extr_transform_matrix, pnt));\n    let bb_transformed_2D = get2D_projection(bb_transformed_3D);\n    bb_transformed_2D = bb_transformed_2D.map(p => transform2D_apply(layer_transform_matrix, p));\n    if (parent_transform_matrix) {\n        bb_transformed_2D = bb_transformed_2D.map(p => transform2D_apply(parent_transform_matrix, p));\n    }\n    const ex_left_top = bb_transformed_2D[0], ex_right_top = bb_transformed_2D[1], ex_left_bottom = bb_transformed_2D[2], ex_right_bottom = bb_transformed_2D[3];\n    let transform_effect_controls = [];\n    if (mode & 1) {\n        const bb_pos = ex_left_top;\n        const ex_AD = sub(ex_left_bottom, ex_left_top);\n        const rot = angle_between_cw_te(ex_AD, [\n            0,\n            1\n        ]);\n        const ex_AB = sub(ex_right_top, ex_left_top);\n        const rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\n        const x_rot = [\n            Math.cos(rot_rad),\n            Math.sin(rot_rad)\n        ];\n        let skw = angle_between_cw_te(ex_AB, x_rot);\n        if (!front_facing_towards_us) {\n            skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n            skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n        }\n        ;\n        let extra_skew_arr = [];\n        if (Math.abs(skw) > 70) {\n            const max_count = 7;\n            let count = 1;\n            let skew_ = Math.abs(skw);\n            const tan_70 = Math.tan(degreesToRadians(70));\n            while (skew_ > 70 && count < max_count) {\n                skew_ = radiansToDegrees(Math.atan($bm_sub(Math.tan(degreesToRadians(skew_)), tan_70)));\n                extra_skew_arr.push(skw > 0 ? skew_ : -skew_);\n                count++;\n            }\n        }\n        const scaleY = $bm_mul(100, len_vec(ex_AD));\n        const angle_AB_AD = angle_between_cw_te(ex_AD, ex_AB);\n        const beta = $bm_sub($bm_sub(180, angle_AB_AD), skw);\n        const scaleX_coeff = $bm_div(Math.sin($bm_div($bm_mul(beta, Math.PI), 180)), Math.sin($bm_div($bm_mul(angle_AB_AD, Math.PI), 180)));\n        let scaleX = $bm_div($bm_mul(100, len_vec(ex_AB)), scaleX_coeff);\n        if (!front_facing_towards_us) {\n            scaleX = $bm_neg(scaleX);\n        }\n        transform_effect_controls = [\n            bb_pos,\n            rot,\n            skw,\n            scaleY,\n            scaleX,\n            extra_skew_arr\n        ];\n    }\n    let transform_layer_controls = [];\n    if (mode & 2) {\n        const tl_AB = sub(bb.right_top, bb.left_top);\n        const tl_AD = sub(bb.left_bottom, bb.left_top);\n        const tl_scaleX_coeff = 100;\n        const tl_scaleY_coeff = 100;\n        const tl_bb_anchor = bb.left_top;\n        let tl_bb_pos = ex_left_top;\n        const tl_ex_AB = sub(ex_right_top, ex_left_top);\n        let tl_bb_theta = angle_between_cw(tl_AB, tl_ex_AB);\n        let tl_bb_scx = $bm_div($bm_mul(tl_scaleX_coeff, len_vec(tl_ex_AB)), len_vec(tl_AB));\n        const tl_ex_AD = sub(ex_left_bottom, ex_left_top);\n        const tl_bb_th_rad = $bm_mul(tl_bb_theta, $bm_div(Math.PI, 180));\n        const tl_cos_th = Math.cos(tl_bb_th_rad);\n        const tl_sin_th = Math.sin(tl_bb_th_rad);\n        const tl_AD_rot = [\n            tl_AD[0] * tl_cos_th - tl_AD[1] * tl_sin_th,\n            tl_AD[0] * tl_sin_th + tl_AD[1] * tl_cos_th\n        ];\n        let tl_skew = angle_between_cw(tl_AD_rot, tl_ex_AD);\n        tl_skew = tl_skew < 90 ? tl_skew : $bm_sub(tl_skew, 360);\n        const tl_sk_rad = $bm_div($bm_mul(tl_skew, Math.PI), 180);\n        const tl_AD_skew = [\n            tl_AD[0] + Math.tan(-tl_sk_rad) * tl_AD[1],\n            tl_AD[1]\n        ];\n        const tl_bb_scy = $bm_div($bm_mul(tl_scaleY_coeff, len_vec(tl_ex_AD)), len_vec(tl_AD_skew));\n        if (front_facing_towards_us && !is_front || !front_facing_towards_us && is_front) {\n            tl_bb_scx = $bm_neg(tl_bb_scx);\n            tl_bb_pos = $bm_sum(tl_bb_pos, tl_ex_AB);\n        }\n        transform_layer_controls = [\n            tl_bb_anchor[0],\n            tl_bb_anchor[1],\n            tl_bb_pos[0],\n            tl_bb_pos[1],\n            tl_bb_theta,\n            tl_bb_scx,\n            tl_bb_scy,\n            tl_skew\n        ];\n    }\n    return {\n        'boundingBoxTransformed': bb_transformed_2D,\n        'transformEffectControls': transform_effect_controls,\n        'transformLayerControls': transform_layer_controls\n    };\n};\nconst shape_layer = thisComp.layer('square_1');\nconst shape = shape_layer(2)(1);\nconst shape_contents = shape(2);\nconst targetPath = shape_contents(1)(2);\nconst is_path_closed = targetPath.isClosed();\nconst extrudalizer = shape_layer('ADBE Effect Parade')('Pseudo/Extrudalizer');\nconst depth = extrudalizer('Extrusion depth').value;\nlet anchor = extrudalizer('Position').value;\nanchor = [\n    $bm_neg(anchor[0]),\n    anchor[1],\n    anchor[2]\n];\nconst angleX = extrudalizer('X Rotation').value;\nconst angleY = extrudalizer('Y Rotation').value;\nconst angleZ = extrudalizer('Z Rotation').value;\nconst pivot_angleX = extrudalizer('Pitch (x)').value;\nconst pivot_angleY = extrudalizer('Yaw (y)').value;\nconst pivot_angleZ = extrudalizer('Roll (z)').value;\nconst scale_front = $bm_div(extrudalizer('Front scale').value, 100);\nconst scale_back = $bm_div(extrudalizer('Back scale').value, 100);\nconst use_bb_front = extrudalizer('Compute 3D front bounding box').value;\nconst use_bb_back = extrudalizer('Compute 3D back bounding box').value;\nlet pnts = targetPath.points();\nlet inTangents = targetPath.inTangents();\nlet outTangents = targetPath.outTangents();\nconst is_front_clockwise = isClockwise(pnts);\nconst shape_transform = shape.transform;\nconst s_anchor = shape_transform.anchorPoint;\nconst s_pos = shape_transform.position;\nconst s_scale = shape_transform.scale;\nconst s_rot = shape_transform.rotation;\nconst s_skew = shape_transform.skew;\nconst s_skew_axis = shape_transform.skewAxis;\nconst shape_transform_matrix = get_transform_shape_matrix(s_anchor, s_pos, s_scale, s_rot, s_skew, s_skew_axis);\nconst layer_transform = shape_layer.transform;\nconst l_anchor = layer_transform.anchorPoint;\nconst l_pos = layer_transform.position;\nconst l_scale = layer_transform.scale;\nconst l_rot = layer_transform.rotation;\nconst layer_transform_matrix = get_transform_shape_matrix(l_anchor, l_pos, l_scale, l_rot, 0, 0);\nlet subdivs = 1;\nlet num_pnts = pnts.length;\nif (hasNoneZeroValues(inTangents) || hasNoneZeroValues(outTangents)) {\n    subdivs = 5;\n    let pointsF = [];\n    for (var i = 0; i < num_pnts; i++) {\n        pointsF.push(pnts[i]);\n        if (!is_path_closed && i == num_pnts - 1) {\n            break;\n        }\n        var p1 = pnts[i], p2 = pnts[(i + 1) % num_pnts];\n        var out1 = outTangents[i], in2 = inTangents[(i + 1) % num_pnts];\n        var cp1 = add(p1, out1), cp2 = add(p2, in2);\n        var len_out1 = len_vec(out1), len_in2 = len_vec(in2);\n        var len_p1p2 = len_vec(sub(p2, p1));\n        if (len_out1 !== 0 || len_in2 !== 0) {\n            var a = len_out1 === 0 ? sub(p2, p1) : out1;\n            var b = len_in2 === 0 ? sub(p1, p2) : in2;\n            if (!isStraightLine_w_delta(a, b, 0.999) && (len_out1 > len_p1p2 * 0.02 || len_in2 > len_p1p2 * 0.02)) {\n                for (var j = 1; j < subdivs; j++) {\n                    var t = $bm_div(j, subdivs);\n                    pointsF.push(getPoint(p1, cp1, cp2, p2, t));\n                }\n            }\n        }\n    }\n    pnts = pointsF;\n}\npnts = pnts.map(p => transform2D_apply(shape_transform_matrix, p));\nnum_pts = pnts.length;\nconst zero_center_point = getCentroidPro(pnts)[4];\nlet z_coord = 0;\nswitch (1) {\ncase 0:\n    z_coord = $bm_div($bm_neg(depth), 2);\n    break;\ncase 1:\n    z_coord = 0;\n    break;\ncase 2:\n    z_coord = $bm_div(depth, 2);\n    break;\n}\n;\nconst zero_center_point_3D = [\n    ...zero_center_point,\n    z_coord\n];\nconst pivot_matrix = transformMatrix([\n    0,\n    0,\n    z_coord\n], 1, [\n    0,\n    0,\n    0\n], [\n    0,\n    0,\n    0\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst pivot_position = make_transform(pivot_matrix, zero_center_point);\nconst tr_front_mat = transformMatrix([\n    0,\n    0,\n    $bm_div($bm_neg(depth), 2)\n], scale_front, zero_center_point_3D, [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst tr_back_mat = transformMatrix([\n    0,\n    0,\n    $bm_div(depth, 2)\n], scale_back, zero_center_point_3D, [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst rot_matrix = transformMatrix([\n    0,\n    0,\n    0\n], 1, [\n    0,\n    0,\n    0\n], [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], [\n    0,\n    0,\n    0\n], [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst z1_transformed = make_transform(rot_matrix, [\n    0,\n    0,\n    -1\n]);\nconst front_facing_towards_us = isVectorFacingTowardsUs(z1_transformed);\nlet points_front_3D = pnts.map(pnt => make_transform(tr_front_mat, pnt));\nlet points_back_3D = pnts.map(pnt => make_transform(tr_back_mat, pnt));\nlet winding_sides = [];\nlet sorted_sides = [];\nlet sorted_side_colors = [];\nlet num_sides_towards_us = 0;\nfor (var i = 0; i < num_pts; i++) {\n    if (!is_path_closed && i == num_pts - 1) {\n        break;\n    }\n    var F1 = points_front_3D[i], F2 = points_front_3D[(i + 1) % num_pts];\n    var B1 = points_back_3D[i], B2 = points_back_3D[(i + 1) % num_pts];\n    let abs_side_normal = getNormal([\n        F2,\n        F1,\n        B1\n    ], true);\n    let real_side_normal = !is_front_clockwise ? mul(abs_side_normal, -1) : abs_side_normal;\n    const sideIsFacingUs = isFacingTowardsUs([\n        0,\n        0,\n        0\n    ], real_side_normal);\n    if (sideIsFacingUs) {\n        num_sides_towards_us++;\n    }\n    winding_sides.push(sideIsFacingUs);\n    let side_sorted = [\n        F2,\n        F1,\n        B1,\n        B2\n    ];\n    side_sorted.sort((a, b) => b[2] - a[2]);\n    sorted_sides.push([\n        side_sorted,\n        i,\n        $bm_mod($bm_sum(i, 1), num_pts),\n        abs_side_normal\n    ]);\n}\ncompare_sides = function (side1, side2) {\n    const s1_vertices_z = side1[0].map(v => v[2]), s2_vertices_z = side2[0].map(v => v[2]);\n    for (var i = 0, il = side1[0].length; i < il; i++) {\n        if (s1_vertices_z[i] != s2_vertices_z[i]) {\n            return $bm_sub(s2_vertices_z[i], s1_vertices_z[i]);\n        }\n    }\n};\nsorted_sides.sort((a, b) => compare_sides(a, b));\nsorted_sides.sort(function (a, b) {\n    const fa = winding_sides[a[1]], fb = winding_sides[b[1]];\n    if (fa && !fb) {\n        return -1;\n    } else if (!fa && fb) {\n        return 1;\n    } else {\n        return 0;\n    }\n});\nsorted_sides_indices = sorted_sides.map(p => [\n    p[1],\n    p[2]\n]);\nif (true) {\n    const lambert_max = extrudalizer('Sides fill shadow opacity').value;\n    const rgba = extrudalizer('Sides color').value;\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    lambertShader = function (normal, max_value, multiplier) {\n        return $bm_div($bm_mul($bm_mul(multiplier, $bm_sub(100, max_value)), Math.abs(dot_(normal, [\n            0,\n            0,\n            1\n        ]))), 100);\n    };\n    sorted_side_colors = sorted_sides.map(p => adjustColorBrightness(rgba, lambertShader(p[3], lambert_max, 2)));\n}\nconst front_normal = div(z1_transformed, len_vec(z1_transformed));\nlet bb_front_2D = [], bb_back_2D = [], bb_front_transforms_te = [], bb_back_transforms_te = [], bb_front_transforms_tl = [], bb_back_transforms_tl = [];\nif (use_bb_back || use_bb_front) {\n    const bb = getBoundingBox(pnts);\n    let hasParent = shape_layer.hasParent;\n    let parent_transform_matrix = null;\n    if (hasParent) {\n        let p_pos = shape_layer.parent.transform.position;\n        let p_anchor = shape_layer.parent.transform.anchorPoint;\n        let p_rot = shape_layer.parent.transform.rotation;\n        let p_sca = shape_layer.parent.transform.scale;\n        parent_transform_matrix = get_transform_shape_matrix(p_anchor, p_pos, p_sca, p_rot, 0, 0);\n    }\n    if (use_bb_front) {\n        const bb_front_data = get_transforms_from_bb(bb, tr_front_mat, layer_transform_matrix, parent_transform_matrix, true, front_facing_towards_us, 3);\n        bb_front_2D = bb_front_data['boundingBoxTransformed'];\n        bb_front_transforms_te = bb_front_data['transformEffectControls'];\n        bb_front_transforms_tl = bb_front_data['transformLayerControls'];\n    }\n    if (use_bb_back) {\n        const bb_back_data = get_transforms_from_bb(bb, tr_back_mat, layer_transform_matrix, parent_transform_matrix, false, front_facing_towards_us, 3);\n        bb_back_2D = bb_back_data['boundingBoxTransformed'];\n        bb_back_transforms_te = bb_back_data['transformEffectControls'];\n        bb_back_transforms_tl = bb_back_data['transformLayerControls'];\n    }\n}\nlet grad_property = null;\ntry {\n    grad_property = shape_contents('ADBE Vector Graphic - G-Fill');\n} catch (e) {\n}\nlet grad_start_front_new = [\n    0,\n    0\n];\nlet grad_end_front_new = [\n    0,\n    0\n];\nlet grad_start_back_new = [\n    0,\n    0\n];\nlet grad_end_back_new = [\n    0,\n    0\n];\nif (grad_property != null) {\n    let grad_start = grad_property.startPoint.value;\n    let grad_end = grad_property.endPoint.value;\n    grad_start = transform2D_apply(shape_transform_matrix, grad_start);\n    grad_end = transform2D_apply(shape_transform_matrix, grad_end);\n    const grad_start_front = make_transform(tr_front_mat, grad_start);\n    const grad_end_front = make_transform(tr_front_mat, grad_end);\n    const grad_start_back = make_transform(tr_back_mat, grad_start);\n    const grad_end_back = make_transform(tr_back_mat, grad_end);\n    grad_start_front_new = grad_start_front;\n    grad_end_front_new = grad_end_front;\n    grad_start_back_new = grad_start_back;\n    grad_end_back_new = grad_end_back;\n    const grad_front_rot = $bm_div($bm_mul(extrudalizer('Front gradient direction').value, Math.PI), 180);\n    const grad_back_rot = $bm_div($bm_mul(extrudalizer('Back gradient direction').value, Math.PI), 180);\n    if (!arraysEqual([\n            grad_front_rot,\n            grad_back_rot\n        ], [\n            0,\n            0\n        ])) {\n        const grad_origin_front = div(add(grad_end_front, grad_start_front), 2);\n        const grad_origin_back = div(add(grad_end_back, grad_start_back), 2);\n        const grad_p_st_front = sub(grad_start_front, grad_origin_front);\n        const grad_p_end_front = sub(grad_end_front, grad_origin_front);\n        const grad_p_st_back = sub(grad_start_back, grad_origin_back);\n        const grad_p_end_back = sub(grad_end_back, grad_origin_back);\n        if (grad_front_rot != 0) {\n            const cos_st = Math.cos(grad_front_rot), sin_st = Math.sin(grad_front_rot);\n            grad_start_front_new[0] = $bm_sum($bm_sub($bm_mul(cos_st, grad_p_st_front[0]), $bm_mul(sin_st, grad_p_st_front[1])), grad_origin_front[0]);\n            grad_start_front_new[1] = $bm_sum($bm_sum($bm_mul(sin_st, grad_p_st_front[0]), $bm_mul(cos_st, grad_p_st_front[1])), grad_origin_front[1]);\n            grad_end_front_new[0] = $bm_sum($bm_sub($bm_mul(cos_st, grad_p_end_front[0]), $bm_mul(sin_st, grad_p_end_front[1])), grad_origin_front[0]);\n            grad_end_front_new[1] = $bm_sum($bm_sum($bm_mul(sin_st, grad_p_end_front[0]), $bm_mul(cos_st, grad_p_end_front[1])), grad_origin_front[1]);\n        }\n        if (grad_back_rot != 0) {\n            const cos_st_b = Math.cos(grad_back_rot), sin_st_b = Math.sin(grad_back_rot);\n            grad_start_back_new[0] = $bm_sum($bm_sub($bm_mul(cos_st_b, grad_p_st_back[0]), $bm_mul(sin_st_b, grad_p_st_back[1])), grad_origin_back[0]);\n            grad_start_back_new[1] = $bm_sum($bm_sum($bm_mul(sin_st_b, grad_p_st_back[0]), $bm_mul(cos_st_b, grad_p_st_back[1])), grad_origin_back[1]);\n            grad_end_back_new[0] = $bm_sum($bm_sub($bm_mul(cos_st_b, grad_p_end_back[0]), $bm_mul(sin_st_b, grad_p_end_back[1])), grad_origin_back[0]);\n            grad_end_back_new[1] = $bm_sum($bm_sum($bm_mul(sin_st_b, grad_p_end_back[0]), $bm_mul(cos_st_b, grad_p_end_back[1])), grad_origin_back[1]);\n        }\n    }\n}\nconst extr_data = [\n    tr_front_mat,\n    tr_back_mat,\n    shape_transform_matrix,\n    subdivs,\n    is_path_closed,\n    points_front_3D,\n    points_back_3D,\n    sorted_sides_indices,\n    front_facing_towards_us,\n    is_front_clockwise,\n    num_sides_towards_us,\n    sorted_side_colors,\n    pivot_position,\n    front_normal,\n    bb_front_2D,\n    bb_back_2D,\n    bb_front_transforms_te,\n    bb_back_transforms_te,\n    bb_front_transforms_tl,\n    bb_back_transforms_tl,\n    grad_start_front_new,\n    grad_end_front_new,\n    grad_start_back_new,\n    grad_end_back_new\n];\nvar txt = '';\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'] = extr_data;\n} catch (err) {\n    stringify = function (data, separator) {\n        return data.map(item => Array.isArray(item) ? item.join(',') : item.toString()).join(separator);\n    };\n    txt = stringify(extr_data, ';');\n}\n$bm_rt = txt;"},"p":{},"m":{"g":1,"a":{"a":0,"k":[0,0],"ix":2}},"a":[]},"ip":0,"op":300,"st":0,"ct":1,"bm":0}]},{"id":"comp_8","nm":"Dare_Face","fr":30,"layers":[{"ddd":0,"ind":1,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [3]","refId":"comp_1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [2]","refId":"comp_2","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":3,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [1]","refId":"comp_3","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":4,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [0]","refId":"comp_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":5,"ty":0,"nm":"MAP || Dice || square_1 || BACK","refId":"comp_5","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('square_1').effect('Extrudalizer')('Back opacity readout');"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[150,150],"ix":1,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst is_front = false;\nconst precomp_width = 300;\nlet extr_data_arr = [];\nlet is_facing_us = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    $bm_rt = is_facing_us = extr_data_arr[8];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    $bm_rt = is_facing_us = extr_data_arr[8] == 'true';\n}\nfunction logicalXOR(input1, input2) {\n    return input1 && !input2 || !input1 && input2;\n}\nif (logicalXOR(is_front, is_facing_us)) {\n    $bm_rt = value = [\n        precomp_width,\n        0\n    ];\n} else {\n    $bm_rt = value = [\n        0,\n        0\n    ];\n}"}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst POS_INDEX_LOTTIE = 0;\nconst POS_INDEX_1 = 0;\nconst POS_INDEX_2 = 1;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let pos = [\n        0,\n        0\n    ];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        $bm_rt = pos = transform_effect_controls[POS_INDEX_LOTTIE];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        $bm_rt = pos = [\n            transform_effect_controls[POS_INDEX_1],\n            transform_effect_controls[POS_INDEX_2]\n        ];\n    }\n}"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 3;\nconst control_index_ae = 4;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.height;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 4;\nconst control_index_ae = 5;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = $bm_neg(thisLayer.width);\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 2;\nconst control_index_ae = 3;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 1;\nconst control_index_ae = 2;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'Back';\nconst face_opacity = ex_layer.effect('Extrudalizer')(face + ' opacity readout').value;\n$bm_rt = face_opacity;"}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":6,"ty":0,"nm":"MAP || Dice || square_1 || FRONT","refId":"comp_6","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('square_1').effect('Extrudalizer')('Front opacity readout');"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[150,150],"ix":1,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst is_front = true;\nconst precomp_width = 300;\nlet extr_data_arr = [];\nlet is_facing_us = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    $bm_rt = is_facing_us = extr_data_arr[8];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    $bm_rt = is_facing_us = extr_data_arr[8] == 'true';\n}\nfunction logicalXOR(input1, input2) {\n    return input1 && !input2 || !input1 && input2;\n}\nif (logicalXOR(is_front, is_facing_us)) {\n    $bm_rt = value = [\n        precomp_width,\n        0\n    ];\n} else {\n    $bm_rt = value = [\n        0,\n        0\n    ];\n}"}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst POS_INDEX_LOTTIE = 0;\nconst POS_INDEX_1 = 0;\nconst POS_INDEX_2 = 1;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let pos = [\n        0,\n        0\n    ];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        $bm_rt = pos = transform_effect_controls[POS_INDEX_LOTTIE];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        $bm_rt = pos = [\n            transform_effect_controls[POS_INDEX_1],\n            transform_effect_controls[POS_INDEX_2]\n        ];\n    }\n}"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 3;\nconst control_index_ae = 4;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.height;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 4;\nconst control_index_ae = 5;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.width;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 2;\nconst control_index_ae = 3;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 1;\nconst control_index_ae = 2;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'Front';\nconst face_opacity = ex_layer.effect('Extrudalizer')(face + ' opacity readout').value;\n$bm_rt = face_opacity;"}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":7,"ty":4,"nm":"square_1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[540,540,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":1,"k":[{"i":{"x":[0.667,0.667,0.667],"y":[1,1,1]},"o":{"x":[0.333,0.333,0.333],"y":[0,0,0]},"t":60,"s":[100,100,100]},{"t":90,"s":[180,180,100]}],"ix":6,"l":2}},"ao":0,"ef":[{"ty":5,"nm":"Extrudalizer","np":70,"mn":"Pseudo/Extrudalizer","ix":1,"en":1,"ef":[{"ty":6,"nm":"3D Transform","mn":"Pseudo/Extrudalizer-0001","ix":1,"v":0},{"ty":0,"nm":"Extrusion depth","mn":"Pseudo/Extrudalizer-0002","ix":2,"v":{"a":0,"k":300,"ix":2}},{"ty":3,"nm":"Position","mn":"Pseudo/Extrudalizer-0003","ix":3,"v":{"a":0,"k":[0,0,0],"ix":3}},{"ty":6,"nm":"Scale","mn":"Pseudo/Extrudalizer-0004","ix":4,"v":0},{"ty":0,"nm":"Front scale","mn":"Pseudo/Extrudalizer-0005","ix":5,"v":{"a":0,"k":100,"ix":5}},{"ty":0,"nm":"Back scale","mn":"Pseudo/Extrudalizer-0006","ix":6,"v":{"a":0,"k":100,"ix":6}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0007","ix":7,"v":0},{"ty":6,"nm":"Pitch/Roll/Yaw","mn":"Pseudo/Extrudalizer-0008","ix":8,"v":0},{"ty":0,"nm":"Pitch (x)","mn":"Pseudo/Extrudalizer-0009","ix":9,"v":{"a":1,"k":[{"i":{"x":[0.401],"y":[1]},"o":{"x":[0.333],"y":[0]},"t":0,"s":[-30]},{"t":60,"s":[720]}],"ix":9}},{"ty":0,"nm":"Yaw (y)","mn":"Pseudo/Extrudalizer-0010","ix":10,"v":{"a":1,"k":[{"i":{"x":[0.401],"y":[1]},"o":{"x":[0.333],"y":[0]},"t":0,"s":[30]},{"t":60,"s":[900]}],"ix":10}},{"ty":0,"nm":"Roll (z)","mn":"Pseudo/Extrudalizer-0011","ix":11,"v":{"a":1,"k":[{"i":{"x":[0.401],"y":[1]},"o":{"x":[0.333],"y":[0]},"t":0,"s":[0]},{"t":60,"s":[-720]}],"ix":11}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0012","ix":12,"v":0},{"ty":6,"nm":"Orbit control","mn":"Pseudo/Extrudalizer-0013","ix":13,"v":0},{"ty":0,"nm":"X Rotation","mn":"Pseudo/Extrudalizer-0014","ix":14,"v":{"a":0,"k":0,"ix":14}},{"ty":0,"nm":"Y Rotation","mn":"Pseudo/Extrudalizer-0015","ix":15,"v":{"a":0,"k":0,"ix":15}},{"ty":0,"nm":"Z Rotation","mn":"Pseudo/Extrudalizer-0016","ix":16,"v":{"a":0,"k":0,"ix":16}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0017","ix":17,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0018","ix":18,"v":0},{"ty":6,"nm":"Appearance","mn":"Pseudo/Extrudalizer-0019","ix":19,"v":0},{"ty":7,"nm":"Hide anchor point","mn":"Pseudo/Extrudalizer-0020","ix":20,"v":{"a":0,"k":1,"ix":20}},{"ty":7,"nm":"Wireframe mode","mn":"Pseudo/Extrudalizer-0021","ix":21,"v":{"a":0,"k":0,"ix":21}},{"ty":2,"nm":"Edge stroke color","mn":"Pseudo/Extrudalizer-0022","ix":22,"v":{"a":0,"k":[0.996078491211,0.98431378603,0.917647123337,1],"ix":22}},{"ty":0,"nm":"Edge stroke width","mn":"Pseudo/Extrudalizer-0023","ix":23,"v":{"a":0,"k":0,"ix":23}},{"ty":0,"nm":"Translucency","mn":"Pseudo/Extrudalizer-0024","ix":24,"v":{"a":0,"k":0,"ix":24}},{"ty":6,"nm":"Front & Back ","mn":"Pseudo/Extrudalizer-0025","ix":25,"v":0},{"ty":2,"nm":"Front color","mn":"Pseudo/Extrudalizer-0026","ix":26,"v":{"a":0,"k":[0.996078491211,0.98431378603,0.917647123337,1],"ix":26}},{"ty":0,"nm":"Front opacity","mn":"Pseudo/Extrudalizer-0027","ix":27,"v":{"a":0,"k":100,"ix":27}},{"ty":0,"nm":"Front gradient opacity","mn":"Pseudo/Extrudalizer-0028","ix":28,"v":{"a":0,"k":0,"ix":28}},{"ty":0,"nm":"Front gradient direction","mn":"Pseudo/Extrudalizer-0029","ix":29,"v":{"a":0,"k":0,"ix":29}},{"ty":6,"nm":"   ","mn":"Pseudo/Extrudalizer-0030","ix":30,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0031","ix":31,"v":0},{"ty":2,"nm":"Back color","mn":"Pseudo/Extrudalizer-0032","ix":32,"v":{"a":0,"k":[0.945098102093,0.917647123337,0.776470661163,1],"ix":32}},{"ty":0,"nm":"Back opacity","mn":"Pseudo/Extrudalizer-0033","ix":33,"v":{"a":0,"k":100,"ix":33}},{"ty":0,"nm":"Back gradient opacity","mn":"Pseudo/Extrudalizer-0034","ix":34,"v":{"a":0,"k":0,"ix":34}},{"ty":0,"nm":"Back gradient direction","mn":"Pseudo/Extrudalizer-0035","ix":35,"v":{"a":0,"k":0,"ix":35}},{"ty":6,"nm":"    ","mn":"Pseudo/Extrudalizer-0036","ix":36,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0037","ix":37,"v":0},{"ty":3,"nm":"Gradient start point","mn":"Pseudo/Extrudalizer-0038","ix":38,"v":{"a":0,"k":[0,0],"ix":38}},{"ty":3,"nm":"Gradient end point","mn":"Pseudo/Extrudalizer-0039","ix":39,"v":{"a":0,"k":[0,0],"ix":39}},{"ty":6,"nm":"Edit gradient start/end points o","mn":"Pseudo/Extrudalizer-0040","ix":40,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0041","ix":41,"v":0},{"ty":6,"nm":"at 3D rotation set to [0,0,0]","mn":"Pseudo/Extrudalizer-0042","ix":42,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0043","ix":43,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0044","ix":44,"v":0},{"ty":6,"nm":"Sides","mn":"Pseudo/Extrudalizer-0045","ix":45,"v":0},{"ty":2,"nm":"Sides color","mn":"Pseudo/Extrudalizer-0046","ix":46,"v":{"a":0,"k":[0,1,1,1],"ix":46}},{"ty":0,"nm":"Sides opacity","mn":"Pseudo/Extrudalizer-0047","ix":47,"v":{"a":0,"k":100,"ix":47}},{"ty":0,"nm":"Sides gradient opacity","mn":"Pseudo/Extrudalizer-0048","ix":48,"v":{"a":0,"k":25,"ix":48}},{"ty":0,"nm":"Sides gradient direction","mn":"Pseudo/Extrudalizer-0049","ix":49,"v":{"a":0,"k":0,"ix":49}},{"ty":0,"nm":"Sides gradient length","mn":"Pseudo/Extrudalizer-0050","ix":50,"v":{"a":0,"k":0,"ix":50}},{"ty":2,"nm":"Sides fill shadow color","mn":"Pseudo/Extrudalizer-0051","ix":51,"v":{"a":0,"k":[0,0,0,1],"ix":51}},{"ty":0,"nm":"Sides fill shadow opacity","mn":"Pseudo/Extrudalizer-0052","ix":52,"v":{"a":0,"k":50,"ix":52}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0053","ix":53,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0054","ix":54,"v":0},{"ty":6,"nm":"Parenting Data","mn":"Pseudo/Extrudalizer-0055","ix":55,"v":0},{"ty":0,"nm":"Front opacity readout","mn":"Pseudo/Extrudalizer-0056","ix":56,"v":{"a":0,"k":100,"ix":56,"x":"var $bm_rt;\ntry {\n    $bm_rt = content('--- EXTRUDALIZER ---').content('FRONT').transform.opacity;\n} catch (e) {\n    $bm_rt = 0;\n}"}},{"ty":0,"nm":"Back opacity readout","mn":"Pseudo/Extrudalizer-0057","ix":57,"v":{"a":0,"k":100,"ix":57,"x":"var $bm_rt;\ntry {\n    $bm_rt = content('--- EXTRUDALIZER ---').content('BACK').transform.opacity;\n} catch (e) {\n    $bm_rt = 0;\n}"}},{"ty":7,"nm":"Compute 3D front bounding box","mn":"Pseudo/Extrudalizer-0058","ix":58,"v":{"a":0,"k":1,"ix":58}},{"ty":3,"nm":"Front upper left","mn":"Pseudo/Extrudalizer-0059","ix":59,"v":{"a":0,"k":[0,0],"ix":59,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[0];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[0],\n            front_bb[1]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front upper right","mn":"Pseudo/Extrudalizer-0060","ix":60,"v":{"a":0,"k":[0,0],"ix":60,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[1];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[2],\n            front_bb[3]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front lower left","mn":"Pseudo/Extrudalizer-0061","ix":61,"v":{"a":0,"k":[0,0],"ix":61,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[2];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[4],\n            front_bb[5]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front lower right","mn":"Pseudo/Extrudalizer-0062","ix":62,"v":{"a":0,"k":[0,0],"ix":62,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[3];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[6],\n            front_bb[7]\n        ];\n    }\n}"}},{"ty":7,"nm":"Compute 3D back bounding box","mn":"Pseudo/Extrudalizer-0063","ix":63,"v":{"a":0,"k":1,"ix":63}},{"ty":3,"nm":"Back upper left","mn":"Pseudo/Extrudalizer-0064","ix":64,"v":{"a":0,"k":[0,0],"ix":64,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[0];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[0],\n            back_bb[1]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back upper right","mn":"Pseudo/Extrudalizer-0065","ix":65,"v":{"a":0,"k":[0,0],"ix":65,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[1];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[2],\n            back_bb[3]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back lower left","mn":"Pseudo/Extrudalizer-0066","ix":66,"v":{"a":0,"k":[0,0],"ix":66,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[2];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[4],\n            back_bb[5]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back lower right","mn":"Pseudo/Extrudalizer-0067","ix":67,"v":{"a":0,"k":[0,0],"ix":67,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[3];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[6],\n            back_bb[7]\n        ];\n    }\n}"}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0068","ix":68,"v":0}]},{"ty":5,"nm":"FACE 0","np":3,"mn":"ADBE Color Control","ix":2,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.945098042488,0.919524788857,0.774609744549,1],"ix":1}}]},{"ty":5,"nm":"FACE 1","np":3,"mn":"ADBE Color Control","ix":3,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.996078431606,0.984313726425,0.917647063732,1],"ix":1}}]},{"ty":5,"nm":"FACE 2","np":3,"mn":"ADBE Color Control","ix":4,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.945098042488,0.919524788857,0.774609744549,1],"ix":1}}]},{"ty":5,"nm":"FACE 3","np":3,"mn":"ADBE Color Control","ix":5,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.996078431606,0.984313726425,0.917647063732,1],"ix":1}}]}],"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[150,-150],[150,150],[-150,150],[-150,-150]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":true},{"ty":"st","c":{"a":0,"k":[0,0.925924921971,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":78,"ix":5},"lc":2,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"ORIGIN SHAPE","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nlet extr_data_arr;\nlet points_3D = [];\nlet isPathClosed;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_3D = extr_data_arr[5];\n    isPathClosed = extr_data_arr[4] === true;\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let points_arr = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    isPathClosed = extr_data_arr[4] === 'true';\n    for (var i = 0, il = points_arr.length / 3; i < il; i++) {\n        points_3D.push(points_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst points_2D = points_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst num_pts = points_2D.length;\nconst zeroArr = Array(num_pts).fill([\n    0,\n    0\n]);\n$bm_rt = createPath(points_2D, zeroArr, zeroArr, isPathClosed);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Front color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":2,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Front color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nlet extr_data_arr;\nlet is_facing_towards_us;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    is_facing_towards_us = extr_data_arr[8] === true;\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    is_facing_towards_us = extr_data_arr[8] === 'true';\n}\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = $bm_div(effect('Extrudalizer')('Translucency').value, 2);\nconst opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    if (is_facing_towards_us > 0) {\n        $bm_rt = opacity_value;\n    } else {\n        $bm_rt = transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"FRONT","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nlet extr_data_arr;\nlet points_3D = [];\nlet isPathClosed;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_3D = extr_data_arr[6];\n    isPathClosed = extr_data_arr[4] === true;\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let points_arr = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    isPathClosed = extr_data_arr[4] === 'true';\n    for (var i = 0, il = points_arr.length / 3; i < il; i++) {\n        points_3D.push(points_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst points_2D = points_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst num_pts = points_2D.length;\nconst zeroArr = Array(num_pts).fill([\n    0,\n    0\n]);\n$bm_rt = createPath(points_2D, zeroArr, zeroArr, isPathClosed);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Back color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Back color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    try {\n        const frontOpacity = content('--- EXTRUDALIZER ---').content('FRONT').transform.opacity.value;\n        $bm_rt = value = $bm_sub(100, frontOpacity);\n    } catch (e) {\n        $bm_rt = 100;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"BACK","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 0;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = true ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[0][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[0];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = false ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[0][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[0];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 0 - 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 1;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = true ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[1][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[1];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = false ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[1][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[1];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 1 - 2","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDES","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"--- EXTRUDALIZER ---","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":300,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":8,"ty":5,"nm":"EXTRUDALIZER DATA || square_1","hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[540,540,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"t":{"d":{"k":[{"s":{"s":36,"f":"TrajanPro-Bold","t":"","ca":0,"j":0,"tr":0,"lh":43.2000007629395,"ls":0,"fc":[0.267,0.722,0.765]},"t":0}],"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, arraysEqual, getNormal, get2D_projection, getBoundingBox, getPositionMatrix, getRotationMatrix, getScaleMatrix, getIdentity, translate, rotateX, rotateY, rotateZ, multiplyMatrixVector, multiplyMatrices, multiplyArrayOfMatrices, transformMatrix, make_transform, getPoint, getArea, isClockwise, getCentroid, getCentroidPro, hasNoneZeroValues, angle_between, angle_between_cw, angle_between_cw_te, isStraightLine_w_delta, isFacingTowardsUs, isVectorFacingTowardsUs, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_shape_matrix, get_transforms_from_bb, num_pts, compare_sides, sorted_sides_indices, adjustColorBrightness, lambertShader, stringify;\n'use native operators';\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\narraysEqual = function (arr1, arr2) {\n    for (var i = 0, il = arr1.length; i < il; i++) {\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n};\ngetNormal = function (pts, normalized) {\n    let dir = cross_vec(sub(pts[1], pts[0]), sub(pts[2], pts[0]));\n    let len_dir = len_vec(dir);\n    if (len_dir === 0) {\n        return [\n            0,\n            0,\n            0\n        ];\n    }\n    if (normalized) {\n        return div(dir, len_dir);\n    } else {\n        return dir;\n    }\n};\nget2D_projection = function (points) {\n    return points.map(v => [\n        v[0],\n        v[1]\n    ]);\n};\ngetBoundingBox = function (points) {\n    const boundingBox = {\n        left: Number.POSITIVE_INFINITY,\n        top: Number.POSITIVE_INFINITY,\n        right: Number.NEGATIVE_INFINITY,\n        bottom: Number.NEGATIVE_INFINITY,\n        width: undefined,\n        height: undefined,\n        center: undefined\n    };\n    points.forEach(point => {\n        boundingBox.left = Math.min(boundingBox.left, point[0]);\n        boundingBox.top = Math.min(boundingBox.top, point[1]);\n        boundingBox.right = Math.max(boundingBox.right, point[0]);\n        boundingBox.bottom = Math.max(boundingBox.bottom, point[1]);\n    });\n    boundingBox.width = sub(boundingBox.right, boundingBox.left);\n    boundingBox.height = sub(boundingBox.bottom, boundingBox.top);\n    boundingBox.center = [\n        add(boundingBox.left, $bm_div(boundingBox.width, 2)),\n        add(boundingBox.top, $bm_div(boundingBox.height, 2))\n    ];\n    boundingBox.left_top = [\n        boundingBox.left,\n        boundingBox.top\n    ];\n    boundingBox.left_bottom = [\n        boundingBox.left,\n        boundingBox.bottom\n    ];\n    boundingBox.right_top = [\n        boundingBox.right,\n        boundingBox.top\n    ];\n    boundingBox.right_bottom = [\n        boundingBox.right,\n        boundingBox.bottom\n    ];\n    return boundingBox;\n};\ngetPositionMatrix = function (value) {\n    return translate(getIdentity(), value[0], value[1], $bm_neg(value[2]));\n};\ngetRotationMatrix = function (angles) {\n    const angleX = angles[0];\n    const angleY = angles[1];\n    const angleZ = angles[2];\n    var matrix = getIdentity();\n    matrix = rotateZ(matrix, $bm_div($bm_mul(angleZ, Math.PI), 180));\n    matrix = rotateY(matrix, $bm_div($bm_mul(angleY, Math.PI), 180));\n    matrix = rotateX(matrix, $bm_div($bm_mul(angleX, Math.PI), 180));\n    return matrix;\n};\ngetScaleMatrix = function (sc) {\n    return [\n        sc,\n        0,\n        0,\n        0,\n        0,\n        sc,\n        0,\n        0,\n        0,\n        0,\n        sc,\n        0,\n        0,\n        0,\n        0,\n        1\n    ];\n};\ngetIdentity = function () {\n    return [\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n    ];\n};\ntranslate = function (matrix, x, y, z) {\n    return multiplyMatrices(matrix, [\n        1,\n        0,\n        0,\n        x,\n        0,\n        1,\n        0,\n        y,\n        0,\n        0,\n        1,\n        z,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateX = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        1,\n        0,\n        0,\n        0,\n        0,\n        cos_th,\n        $bm_neg(sin_th),\n        0,\n        0,\n        sin_th,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateY = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        cos_th,\n        0,\n        sin_th,\n        0,\n        0,\n        1,\n        0,\n        0,\n        $bm_neg(sin_th),\n        0,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateZ = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        cos_th,\n        $bm_neg(sin_th),\n        0,\n        0,\n        sin_th,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nmultiplyMatrixVector = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 4; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 4; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 4), j)], vector[j]));\n        }\n    }\n    return result;\n};\nmultiplyMatrices = function (matrixB, matrixA) {\n    let result = new Array(16).fill(0);\n    for (let i = 0; i < 4; i++) {\n        for (let j = 0; j < 4; j++) {\n            for (let k = 0; k < 4; k++) {\n                result[$bm_sum($bm_mul(i, 4), j)] = $bm_sum(result[$bm_sum($bm_mul(i, 4), j)], $bm_mul(matrixA[$bm_sum($bm_mul(i, 4), k)], matrixB[$bm_sum($bm_mul(k, 4), j)]));\n            }\n        }\n    }\n    return result;\n};\nmultiplyArrayOfMatrices = function (matrices) {\n    var result = matrices[0];\n    for (var i = 1, il = matrices.length; i < il; i++) {\n        result = multiplyMatrices(result, matrices[i]);\n    }\n    return result;\n};\ntransformMatrix = function (move, sc, pivot, pitch_angles, anch, orbit_angles) {\n    var mat_array = [];\n    if (sc !== 1) {\n        if (!arraysEqual(pivot, [\n                0,\n                0,\n                0\n            ])) {\n            mat_array = mat_array.concat([\n                getPositionMatrix(pivot.map(i => -i)),\n                getScaleMatrix(sc),\n                getPositionMatrix(pivot)\n            ]);\n        } else {\n            mat_array.push(getScaleMatrix(sc));\n        }\n    }\n    mat_array.push(getPositionMatrix(move));\n    if (!arraysEqual(pitch_angles, [\n            0,\n            0,\n            0\n        ])) {\n        if (!arraysEqual(pivot, [\n                0,\n                0,\n                0\n            ])) {\n            mat_array = mat_array.concat([\n                getPositionMatrix(pivot.map(i => -i)),\n                getRotationMatrix(pitch_angles),\n                getPositionMatrix(pivot)\n            ]);\n        } else {\n            mat_array.push(getRotationMatrix(pitch_angles));\n        }\n    }\n    if (!arraysEqual(anch, [\n            0,\n            0,\n            0\n        ])) {\n        mat_array.push(getPositionMatrix(anch.map(i => -i)));\n    }\n    if (!arraysEqual(orbit_angles, [\n            0,\n            0,\n            0\n        ])) {\n        mat_array.push(getRotationMatrix(orbit_angles));\n    }\n    return multiplyArrayOfMatrices(mat_array);\n};\nmake_transform = function (transform_matrix, vector) {\n    if (vector.length == 2) {\n        vector = [\n            ...vector,\n            0,\n            1\n        ];\n    } else if (vector.length == 3) {\n        vector = [\n            ...vector,\n            1\n        ];\n    }\n    var result_vector_4d = multiplyMatrixVector(transform_matrix, vector);\n    return result_vector_4d.slice(0, 3);\n};\ngetPoint = function (p1, cp1, cp2, p2, t) {\n    const x = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[0]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[0])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[0])), $bm_mul(Math.pow(t, 3), p2[0]));\n    const y = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[1]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[1])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[1])), $bm_mul(Math.pow(t, 3), p2[1]));\n    return [\n        x,\n        y\n    ];\n};\ngetArea = function (points) {\n    var area = 0;\n    for (var i = 0, il = points.length; i < il; i++) {\n        var p1 = points[i];\n        var p2 = points[(i + 1) % il];\n        area = $bm_sum(area, $bm_sub($bm_mul(p1[0], p2[1]), $bm_mul(p2[0], p1[1])));\n    }\n    return $bm_div(area, 2);\n};\nisClockwise = function (points) {\n    return getArea(points) > 0;\n};\ngetCentroid = function (vertices) {\n    var area = getArea(vertices);\n    if (area === 0) {\n        function findCenter(points) {\n            let sumX = 0;\n            let sumY = 0;\n            for (let i = 0, il = points.length; i < il; i++) {\n                const point = points[i];\n                sumX = $bm_sum(sumX, point[0]);\n                sumY = $bm_sum(sumY, point[1]);\n            }\n            const meanX = $bm_div(sumX, points.length);\n            const meanY = $bm_div(sumY, points.length);\n            return [\n                meanX,\n                meanY\n            ];\n        }\n        return findCenter(vertices);\n    }\n    let centroidX = 0;\n    let centroidY = 0;\n    const numVertices = vertices.length;\n    for (var i = 0; i < numVertices; i++) {\n        var currentVertex = vertices[i];\n        var nextVertex = vertices[(i + 1) % numVertices];\n        var commonFactor = $bm_sub($bm_mul(currentVertex[0], nextVertex[1]), $bm_mul(nextVertex[0], currentVertex[1]));\n        centroidX = $bm_sum(centroidX, $bm_mul($bm_sum(currentVertex[0], nextVertex[0]), commonFactor));\n        centroidY = $bm_sum(centroidY, $bm_mul($bm_sum(currentVertex[1], nextVertex[1]), commonFactor));\n    }\n    var scaleFactor = $bm_div(1, $bm_mul(6, area));\n    centroidX *= scaleFactor;\n    centroidY *= scaleFactor;\n    return [\n        centroidX,\n        centroidY\n    ];\n};\ngetCentroidPro = function (vertices) {\n    const bb = getBoundingBox(vertices);\n    return {\n        0: bb.left_top,\n        1: [\n            (bb.left_top[0] + bb.right_top[0]) / 2,\n            bb.left_top[1]\n        ],\n        2: bb.right_top,\n        3: [\n            (bb.left_top[0] + bb.left_bottom[0]) / 2,\n            (bb.left_top[1] + bb.left_bottom[1]) / 2\n        ],\n        4: getCentroid(vertices),\n        5: [\n            (bb.right_top[0] + bb.right_bottom[0]) / 2,\n            (bb.right_top[1] + bb.right_bottom[1]) / 2\n        ],\n        6: bb.left_bottom,\n        7: [\n            (bb.left_bottom[0] + bb.right_bottom[0]) / 2,\n            bb.left_bottom[1]\n        ],\n        8: bb.right_bottom\n    };\n};\nhasNoneZeroValues = function (array2D) {\n    return array2D.some(array => array.some(value => value !== 0));\n};\nangle_between = function (a, b) {\n    const dot_prod = dot_(a, b);\n    const mag_a = len_vec(a);\n    const mag_b = len_vec(b);\n    const cos_ = $bm_div(dot_prod, $bm_mul(mag_a, mag_b));\n    return cos_;\n};\nangle_between_cw = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    angle = angle >= 0 ? angle : $bm_sum($bm_mul(2, Math.PI), angle);\n    const degrees = $bm_mul(angle, $bm_div(180, Math.PI));\n    return degrees;\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nisStraightLine_w_delta = function (cp1, cp2, delta) {\n    return angle_between(cp1, cp2) <= -delta;\n};\nisFacingTowardsUs = function (p1, p2) {\n    return dot_(sub(p2, p1), [\n        0,\n        0,\n        1\n    ]) > 0;\n};\nisVectorFacingTowardsUs = function (v) {\n    return dot_(v, [\n        0,\n        0,\n        -1\n    ]) > 0;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_shape_matrix = function (anchor, pos, scale, rot, skew, skew_axis) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (skew !== 0) {\n        const sk_angle = $bm_div($bm_mul(skew, Math.PI), 180);\n        const Sk = [\n            1,\n            Math.tan(-sk_angle),\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            1\n        ];\n        if (skew_axis !== 0) {\n            const sk_axis_angle = $bm_div($bm_mul(skew_axis, Math.PI), 180);\n            const cos_sk = Math.cos(sk_axis_angle);\n            const sin_sk = Math.sin(sk_axis_angle);\n            const Rz = [\n                cos_sk,\n                -sin_sk,\n                0,\n                sin_sk,\n                cos_sk,\n                0,\n                0,\n                0,\n                1\n            ];\n            const Rz_inv = [\n                cos_sk,\n                sin_sk,\n                0,\n                -sin_sk,\n                cos_sk,\n                0,\n                0,\n                0,\n                1\n            ];\n            const SkM = multiplyArrayOfMatrices3x3([\n                Rz_inv,\n                Sk,\n                Rz\n            ]);\n            mat_array.push(SkM);\n        } else {\n            mat_array.push(Sk);\n        }\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nget_transforms_from_bb = function (bb, extr_transform_matrix, layer_transform_matrix, parent_transform_matrix, is_front, front_facing_towards_us, mode) {\n    let bb_transformed_3D = [];\n    if (front_facing_towards_us) {\n        bb_transformed_3D = [\n            bb.left_top,\n            bb.right_top,\n            bb.left_bottom,\n            bb.right_bottom\n        ];\n    } else {\n        bb_transformed_3D = [\n            bb.right_top,\n            bb.left_top,\n            bb.right_bottom,\n            bb.left_bottom\n        ];\n    }\n    bb_transformed_3D = bb_transformed_3D.map(pnt => make_transform(extr_transform_matrix, pnt));\n    let bb_transformed_2D = get2D_projection(bb_transformed_3D);\n    bb_transformed_2D = bb_transformed_2D.map(p => transform2D_apply(layer_transform_matrix, p));\n    if (parent_transform_matrix) {\n        bb_transformed_2D = bb_transformed_2D.map(p => transform2D_apply(parent_transform_matrix, p));\n    }\n    const ex_left_top = bb_transformed_2D[0], ex_right_top = bb_transformed_2D[1], ex_left_bottom = bb_transformed_2D[2], ex_right_bottom = bb_transformed_2D[3];\n    let transform_effect_controls = [];\n    if (mode & 1) {\n        const bb_pos = ex_left_top;\n        const ex_AD = sub(ex_left_bottom, ex_left_top);\n        const rot = angle_between_cw_te(ex_AD, [\n            0,\n            1\n        ]);\n        const ex_AB = sub(ex_right_top, ex_left_top);\n        const rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\n        const x_rot = [\n            Math.cos(rot_rad),\n            Math.sin(rot_rad)\n        ];\n        let skw = angle_between_cw_te(ex_AB, x_rot);\n        if (!front_facing_towards_us) {\n            skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n            skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n        }\n        ;\n        let extra_skew_arr = [];\n        if (Math.abs(skw) > 70) {\n            const max_count = 7;\n            let count = 1;\n            let skew_ = Math.abs(skw);\n            const tan_70 = Math.tan(degreesToRadians(70));\n            while (skew_ > 70 && count < max_count) {\n                skew_ = radiansToDegrees(Math.atan($bm_sub(Math.tan(degreesToRadians(skew_)), tan_70)));\n                extra_skew_arr.push(skw > 0 ? skew_ : -skew_);\n                count++;\n            }\n        }\n        const scaleY = $bm_mul(100, len_vec(ex_AD));\n        const angle_AB_AD = angle_between_cw_te(ex_AD, ex_AB);\n        const beta = $bm_sub($bm_sub(180, angle_AB_AD), skw);\n        const scaleX_coeff = $bm_div(Math.sin($bm_div($bm_mul(beta, Math.PI), 180)), Math.sin($bm_div($bm_mul(angle_AB_AD, Math.PI), 180)));\n        let scaleX = $bm_div($bm_mul(100, len_vec(ex_AB)), scaleX_coeff);\n        if (!front_facing_towards_us) {\n            scaleX = $bm_neg(scaleX);\n        }\n        transform_effect_controls = [\n            bb_pos,\n            rot,\n            skw,\n            scaleY,\n            scaleX,\n            extra_skew_arr\n        ];\n    }\n    let transform_layer_controls = [];\n    if (mode & 2) {\n        const tl_AB = sub(bb.right_top, bb.left_top);\n        const tl_AD = sub(bb.left_bottom, bb.left_top);\n        const tl_scaleX_coeff = 100;\n        const tl_scaleY_coeff = 100;\n        const tl_bb_anchor = bb.left_top;\n        let tl_bb_pos = ex_left_top;\n        const tl_ex_AB = sub(ex_right_top, ex_left_top);\n        let tl_bb_theta = angle_between_cw(tl_AB, tl_ex_AB);\n        let tl_bb_scx = $bm_div($bm_mul(tl_scaleX_coeff, len_vec(tl_ex_AB)), len_vec(tl_AB));\n        const tl_ex_AD = sub(ex_left_bottom, ex_left_top);\n        const tl_bb_th_rad = $bm_mul(tl_bb_theta, $bm_div(Math.PI, 180));\n        const tl_cos_th = Math.cos(tl_bb_th_rad);\n        const tl_sin_th = Math.sin(tl_bb_th_rad);\n        const tl_AD_rot = [\n            tl_AD[0] * tl_cos_th - tl_AD[1] * tl_sin_th,\n            tl_AD[0] * tl_sin_th + tl_AD[1] * tl_cos_th\n        ];\n        let tl_skew = angle_between_cw(tl_AD_rot, tl_ex_AD);\n        tl_skew = tl_skew < 90 ? tl_skew : $bm_sub(tl_skew, 360);\n        const tl_sk_rad = $bm_div($bm_mul(tl_skew, Math.PI), 180);\n        const tl_AD_skew = [\n            tl_AD[0] + Math.tan(-tl_sk_rad) * tl_AD[1],\n            tl_AD[1]\n        ];\n        const tl_bb_scy = $bm_div($bm_mul(tl_scaleY_coeff, len_vec(tl_ex_AD)), len_vec(tl_AD_skew));\n        if (front_facing_towards_us && !is_front || !front_facing_towards_us && is_front) {\n            tl_bb_scx = $bm_neg(tl_bb_scx);\n            tl_bb_pos = $bm_sum(tl_bb_pos, tl_ex_AB);\n        }\n        transform_layer_controls = [\n            tl_bb_anchor[0],\n            tl_bb_anchor[1],\n            tl_bb_pos[0],\n            tl_bb_pos[1],\n            tl_bb_theta,\n            tl_bb_scx,\n            tl_bb_scy,\n            tl_skew\n        ];\n    }\n    return {\n        'boundingBoxTransformed': bb_transformed_2D,\n        'transformEffectControls': transform_effect_controls,\n        'transformLayerControls': transform_layer_controls\n    };\n};\nconst shape_layer = thisComp.layer('square_1');\nconst shape = shape_layer(2)(1);\nconst shape_contents = shape(2);\nconst targetPath = shape_contents(1)(2);\nconst is_path_closed = targetPath.isClosed();\nconst extrudalizer = shape_layer('ADBE Effect Parade')('Pseudo/Extrudalizer');\nconst depth = extrudalizer('Extrusion depth').value;\nlet anchor = extrudalizer('Position').value;\nanchor = [\n    $bm_neg(anchor[0]),\n    anchor[1],\n    anchor[2]\n];\nconst angleX = extrudalizer('X Rotation').value;\nconst angleY = extrudalizer('Y Rotation').value;\nconst angleZ = extrudalizer('Z Rotation').value;\nconst pivot_angleX = extrudalizer('Pitch (x)').value;\nconst pivot_angleY = extrudalizer('Yaw (y)').value;\nconst pivot_angleZ = extrudalizer('Roll (z)').value;\nconst scale_front = $bm_div(extrudalizer('Front scale').value, 100);\nconst scale_back = $bm_div(extrudalizer('Back scale').value, 100);\nconst use_bb_front = extrudalizer('Compute 3D front bounding box').value;\nconst use_bb_back = extrudalizer('Compute 3D back bounding box').value;\nlet pnts = targetPath.points();\nlet inTangents = targetPath.inTangents();\nlet outTangents = targetPath.outTangents();\nconst is_front_clockwise = isClockwise(pnts);\nconst shape_transform = shape.transform;\nconst s_anchor = shape_transform.anchorPoint;\nconst s_pos = shape_transform.position;\nconst s_scale = shape_transform.scale;\nconst s_rot = shape_transform.rotation;\nconst s_skew = shape_transform.skew;\nconst s_skew_axis = shape_transform.skewAxis;\nconst shape_transform_matrix = get_transform_shape_matrix(s_anchor, s_pos, s_scale, s_rot, s_skew, s_skew_axis);\nconst layer_transform = shape_layer.transform;\nconst l_anchor = layer_transform.anchorPoint;\nconst l_pos = layer_transform.position;\nconst l_scale = layer_transform.scale;\nconst l_rot = layer_transform.rotation;\nconst layer_transform_matrix = get_transform_shape_matrix(l_anchor, l_pos, l_scale, l_rot, 0, 0);\nlet subdivs = 1;\nlet num_pnts = pnts.length;\nif (hasNoneZeroValues(inTangents) || hasNoneZeroValues(outTangents)) {\n    subdivs = 5;\n    let pointsF = [];\n    for (var i = 0; i < num_pnts; i++) {\n        pointsF.push(pnts[i]);\n        if (!is_path_closed && i == num_pnts - 1) {\n            break;\n        }\n        var p1 = pnts[i], p2 = pnts[(i + 1) % num_pnts];\n        var out1 = outTangents[i], in2 = inTangents[(i + 1) % num_pnts];\n        var cp1 = add(p1, out1), cp2 = add(p2, in2);\n        var len_out1 = len_vec(out1), len_in2 = len_vec(in2);\n        var len_p1p2 = len_vec(sub(p2, p1));\n        if (len_out1 !== 0 || len_in2 !== 0) {\n            var a = len_out1 === 0 ? sub(p2, p1) : out1;\n            var b = len_in2 === 0 ? sub(p1, p2) : in2;\n            if (!isStraightLine_w_delta(a, b, 0.999) && (len_out1 > len_p1p2 * 0.02 || len_in2 > len_p1p2 * 0.02)) {\n                for (var j = 1; j < subdivs; j++) {\n                    var t = $bm_div(j, subdivs);\n                    pointsF.push(getPoint(p1, cp1, cp2, p2, t));\n                }\n            }\n        }\n    }\n    pnts = pointsF;\n}\npnts = pnts.map(p => transform2D_apply(shape_transform_matrix, p));\nnum_pts = pnts.length;\nconst zero_center_point = getCentroidPro(pnts)[4];\nlet z_coord = 0;\nswitch (1) {\ncase 0:\n    z_coord = $bm_div($bm_neg(depth), 2);\n    break;\ncase 1:\n    z_coord = 0;\n    break;\ncase 2:\n    z_coord = $bm_div(depth, 2);\n    break;\n}\n;\nconst zero_center_point_3D = [\n    ...zero_center_point,\n    z_coord\n];\nconst pivot_matrix = transformMatrix([\n    0,\n    0,\n    z_coord\n], 1, [\n    0,\n    0,\n    0\n], [\n    0,\n    0,\n    0\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst pivot_position = make_transform(pivot_matrix, zero_center_point);\nconst tr_front_mat = transformMatrix([\n    0,\n    0,\n    $bm_div($bm_neg(depth), 2)\n], scale_front, zero_center_point_3D, [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst tr_back_mat = transformMatrix([\n    0,\n    0,\n    $bm_div(depth, 2)\n], scale_back, zero_center_point_3D, [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst rot_matrix = transformMatrix([\n    0,\n    0,\n    0\n], 1, [\n    0,\n    0,\n    0\n], [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], [\n    0,\n    0,\n    0\n], [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst z1_transformed = make_transform(rot_matrix, [\n    0,\n    0,\n    -1\n]);\nconst front_facing_towards_us = isVectorFacingTowardsUs(z1_transformed);\nlet points_front_3D = pnts.map(pnt => make_transform(tr_front_mat, pnt));\nlet points_back_3D = pnts.map(pnt => make_transform(tr_back_mat, pnt));\nlet winding_sides = [];\nlet sorted_sides = [];\nlet sorted_side_colors = [];\nlet num_sides_towards_us = 0;\nfor (var i = 0; i < num_pts; i++) {\n    if (!is_path_closed && i == num_pts - 1) {\n        break;\n    }\n    var F1 = points_front_3D[i], F2 = points_front_3D[(i + 1) % num_pts];\n    var B1 = points_back_3D[i], B2 = points_back_3D[(i + 1) % num_pts];\n    let abs_side_normal = getNormal([\n        F2,\n        F1,\n        B1\n    ], true);\n    let real_side_normal = !is_front_clockwise ? mul(abs_side_normal, -1) : abs_side_normal;\n    const sideIsFacingUs = isFacingTowardsUs([\n        0,\n        0,\n        0\n    ], real_side_normal);\n    if (sideIsFacingUs) {\n        num_sides_towards_us++;\n    }\n    winding_sides.push(sideIsFacingUs);\n    let side_sorted = [\n        F2,\n        F1,\n        B1,\n        B2\n    ];\n    side_sorted.sort((a, b) => b[2] - a[2]);\n    sorted_sides.push([\n        side_sorted,\n        i,\n        $bm_mod($bm_sum(i, 1), num_pts),\n        abs_side_normal\n    ]);\n}\ncompare_sides = function (side1, side2) {\n    const s1_vertices_z = side1[0].map(v => v[2]), s2_vertices_z = side2[0].map(v => v[2]);\n    for (var i = 0, il = side1[0].length; i < il; i++) {\n        if (s1_vertices_z[i] != s2_vertices_z[i]) {\n            return $bm_sub(s2_vertices_z[i], s1_vertices_z[i]);\n        }\n    }\n};\nsorted_sides.sort((a, b) => compare_sides(a, b));\nsorted_sides.sort(function (a, b) {\n    const fa = winding_sides[a[1]], fb = winding_sides[b[1]];\n    if (fa && !fb) {\n        return -1;\n    } else if (!fa && fb) {\n        return 1;\n    } else {\n        return 0;\n    }\n});\nsorted_sides_indices = sorted_sides.map(p => [\n    p[1],\n    p[2]\n]);\nif (true) {\n    const lambert_max = extrudalizer('Sides fill shadow opacity').value;\n    const rgba = extrudalizer('Sides color').value;\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    lambertShader = function (normal, max_value, multiplier) {\n        return $bm_div($bm_mul($bm_mul(multiplier, $bm_sub(100, max_value)), Math.abs(dot_(normal, [\n            0,\n            0,\n            1\n        ]))), 100);\n    };\n    sorted_side_colors = sorted_sides.map(p => adjustColorBrightness(rgba, lambertShader(p[3], lambert_max, 2)));\n}\nconst front_normal = div(z1_transformed, len_vec(z1_transformed));\nlet bb_front_2D = [], bb_back_2D = [], bb_front_transforms_te = [], bb_back_transforms_te = [], bb_front_transforms_tl = [], bb_back_transforms_tl = [];\nif (use_bb_back || use_bb_front) {\n    const bb = getBoundingBox(pnts);\n    let hasParent = shape_layer.hasParent;\n    let parent_transform_matrix = null;\n    if (hasParent) {\n        let p_pos = shape_layer.parent.transform.position;\n        let p_anchor = shape_layer.parent.transform.anchorPoint;\n        let p_rot = shape_layer.parent.transform.rotation;\n        let p_sca = shape_layer.parent.transform.scale;\n        parent_transform_matrix = get_transform_shape_matrix(p_anchor, p_pos, p_sca, p_rot, 0, 0);\n    }\n    if (use_bb_front) {\n        const bb_front_data = get_transforms_from_bb(bb, tr_front_mat, layer_transform_matrix, parent_transform_matrix, true, front_facing_towards_us, 3);\n        bb_front_2D = bb_front_data['boundingBoxTransformed'];\n        bb_front_transforms_te = bb_front_data['transformEffectControls'];\n        bb_front_transforms_tl = bb_front_data['transformLayerControls'];\n    }\n    if (use_bb_back) {\n        const bb_back_data = get_transforms_from_bb(bb, tr_back_mat, layer_transform_matrix, parent_transform_matrix, false, front_facing_towards_us, 3);\n        bb_back_2D = bb_back_data['boundingBoxTransformed'];\n        bb_back_transforms_te = bb_back_data['transformEffectControls'];\n        bb_back_transforms_tl = bb_back_data['transformLayerControls'];\n    }\n}\nlet grad_property = null;\ntry {\n    grad_property = shape_contents('ADBE Vector Graphic - G-Fill');\n} catch (e) {\n}\nlet grad_start_front_new = [\n    0,\n    0\n];\nlet grad_end_front_new = [\n    0,\n    0\n];\nlet grad_start_back_new = [\n    0,\n    0\n];\nlet grad_end_back_new = [\n    0,\n    0\n];\nif (grad_property != null) {\n    let grad_start = grad_property.startPoint.value;\n    let grad_end = grad_property.endPoint.value;\n    grad_start = transform2D_apply(shape_transform_matrix, grad_start);\n    grad_end = transform2D_apply(shape_transform_matrix, grad_end);\n    const grad_start_front = make_transform(tr_front_mat, grad_start);\n    const grad_end_front = make_transform(tr_front_mat, grad_end);\n    const grad_start_back = make_transform(tr_back_mat, grad_start);\n    const grad_end_back = make_transform(tr_back_mat, grad_end);\n    grad_start_front_new = grad_start_front;\n    grad_end_front_new = grad_end_front;\n    grad_start_back_new = grad_start_back;\n    grad_end_back_new = grad_end_back;\n    const grad_front_rot = $bm_div($bm_mul(extrudalizer('Front gradient direction').value, Math.PI), 180);\n    const grad_back_rot = $bm_div($bm_mul(extrudalizer('Back gradient direction').value, Math.PI), 180);\n    if (!arraysEqual([\n            grad_front_rot,\n            grad_back_rot\n        ], [\n            0,\n            0\n        ])) {\n        const grad_origin_front = div(add(grad_end_front, grad_start_front), 2);\n        const grad_origin_back = div(add(grad_end_back, grad_start_back), 2);\n        const grad_p_st_front = sub(grad_start_front, grad_origin_front);\n        const grad_p_end_front = sub(grad_end_front, grad_origin_front);\n        const grad_p_st_back = sub(grad_start_back, grad_origin_back);\n        const grad_p_end_back = sub(grad_end_back, grad_origin_back);\n        if (grad_front_rot != 0) {\n            const cos_st = Math.cos(grad_front_rot), sin_st = Math.sin(grad_front_rot);\n            grad_start_front_new[0] = $bm_sum($bm_sub($bm_mul(cos_st, grad_p_st_front[0]), $bm_mul(sin_st, grad_p_st_front[1])), grad_origin_front[0]);\n            grad_start_front_new[1] = $bm_sum($bm_sum($bm_mul(sin_st, grad_p_st_front[0]), $bm_mul(cos_st, grad_p_st_front[1])), grad_origin_front[1]);\n            grad_end_front_new[0] = $bm_sum($bm_sub($bm_mul(cos_st, grad_p_end_front[0]), $bm_mul(sin_st, grad_p_end_front[1])), grad_origin_front[0]);\n            grad_end_front_new[1] = $bm_sum($bm_sum($bm_mul(sin_st, grad_p_end_front[0]), $bm_mul(cos_st, grad_p_end_front[1])), grad_origin_front[1]);\n        }\n        if (grad_back_rot != 0) {\n            const cos_st_b = Math.cos(grad_back_rot), sin_st_b = Math.sin(grad_back_rot);\n            grad_start_back_new[0] = $bm_sum($bm_sub($bm_mul(cos_st_b, grad_p_st_back[0]), $bm_mul(sin_st_b, grad_p_st_back[1])), grad_origin_back[0]);\n            grad_start_back_new[1] = $bm_sum($bm_sum($bm_mul(sin_st_b, grad_p_st_back[0]), $bm_mul(cos_st_b, grad_p_st_back[1])), grad_origin_back[1]);\n            grad_end_back_new[0] = $bm_sum($bm_sub($bm_mul(cos_st_b, grad_p_end_back[0]), $bm_mul(sin_st_b, grad_p_end_back[1])), grad_origin_back[0]);\n            grad_end_back_new[1] = $bm_sum($bm_sum($bm_mul(sin_st_b, grad_p_end_back[0]), $bm_mul(cos_st_b, grad_p_end_back[1])), grad_origin_back[1]);\n        }\n    }\n}\nconst extr_data = [\n    tr_front_mat,\n    tr_back_mat,\n    shape_transform_matrix,\n    subdivs,\n    is_path_closed,\n    points_front_3D,\n    points_back_3D,\n    sorted_sides_indices,\n    front_facing_towards_us,\n    is_front_clockwise,\n    num_sides_towards_us,\n    sorted_side_colors,\n    pivot_position,\n    front_normal,\n    bb_front_2D,\n    bb_back_2D,\n    bb_front_transforms_te,\n    bb_back_transforms_te,\n    bb_front_transforms_tl,\n    bb_back_transforms_tl,\n    grad_start_front_new,\n    grad_end_front_new,\n    grad_start_back_new,\n    grad_end_back_new\n];\nvar txt = '';\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'] = extr_data;\n} catch (err) {\n    stringify = function (data, separator) {\n        return data.map(item => Array.isArray(item) ? item.join(',') : item.toString()).join(separator);\n    };\n    txt = stringify(extr_data, ';');\n}\n$bm_rt = txt;"},"p":{},"m":{"g":1,"a":{"a":0,"k":[0,0],"ix":2}},"a":[]},"ip":0,"op":300,"st":0,"ct":1,"bm":0}]},{"id":"comp_9","nm":"Number_Face","fr":30,"layers":[{"ddd":0,"ind":1,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [3]","refId":"comp_1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [2]","refId":"comp_2","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":3,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [1]","refId":"comp_3","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":4,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [0]","refId":"comp_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":5,"ty":0,"nm":"MAP || Dice || square_1 || BACK","refId":"comp_5","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('square_1').effect('Extrudalizer')('Back opacity readout');"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[150,150],"ix":1,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst is_front = false;\nconst precomp_width = 300;\nlet extr_data_arr = [];\nlet is_facing_us = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    $bm_rt = is_facing_us = extr_data_arr[8];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    $bm_rt = is_facing_us = extr_data_arr[8] == 'true';\n}\nfunction logicalXOR(input1, input2) {\n    return input1 && !input2 || !input1 && input2;\n}\nif (logicalXOR(is_front, is_facing_us)) {\n    $bm_rt = value = [\n        precomp_width,\n        0\n    ];\n} else {\n    $bm_rt = value = [\n        0,\n        0\n    ];\n}"}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst POS_INDEX_LOTTIE = 0;\nconst POS_INDEX_1 = 0;\nconst POS_INDEX_2 = 1;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let pos = [\n        0,\n        0\n    ];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        $bm_rt = pos = transform_effect_controls[POS_INDEX_LOTTIE];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        $bm_rt = pos = [\n            transform_effect_controls[POS_INDEX_1],\n            transform_effect_controls[POS_INDEX_2]\n        ];\n    }\n}"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 3;\nconst control_index_ae = 4;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.height;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 4;\nconst control_index_ae = 5;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = $bm_neg(thisLayer.width);\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 2;\nconst control_index_ae = 3;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 1;\nconst control_index_ae = 2;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'Back';\nconst face_opacity = ex_layer.effect('Extrudalizer')(face + ' opacity readout').value;\n$bm_rt = face_opacity;"}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":6,"ty":0,"nm":"MAP || Dice || square_1 || FRONT","refId":"comp_6","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('square_1').effect('Extrudalizer')('Front opacity readout');"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[150,150],"ix":1,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst is_front = true;\nconst precomp_width = 300;\nlet extr_data_arr = [];\nlet is_facing_us = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    $bm_rt = is_facing_us = extr_data_arr[8];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    $bm_rt = is_facing_us = extr_data_arr[8] == 'true';\n}\nfunction logicalXOR(input1, input2) {\n    return input1 && !input2 || !input1 && input2;\n}\nif (logicalXOR(is_front, is_facing_us)) {\n    $bm_rt = value = [\n        precomp_width,\n        0\n    ];\n} else {\n    $bm_rt = value = [\n        0,\n        0\n    ];\n}"}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst POS_INDEX_LOTTIE = 0;\nconst POS_INDEX_1 = 0;\nconst POS_INDEX_2 = 1;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let pos = [\n        0,\n        0\n    ];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        $bm_rt = pos = transform_effect_controls[POS_INDEX_LOTTIE];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        $bm_rt = pos = [\n            transform_effect_controls[POS_INDEX_1],\n            transform_effect_controls[POS_INDEX_2]\n        ];\n    }\n}"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 3;\nconst control_index_ae = 4;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.height;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 4;\nconst control_index_ae = 5;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.width;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 2;\nconst control_index_ae = 3;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 1;\nconst control_index_ae = 2;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'Front';\nconst face_opacity = ex_layer.effect('Extrudalizer')(face + ' opacity readout').value;\n$bm_rt = face_opacity;"}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":7,"ty":4,"nm":"square_1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[540,540,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":1,"k":[{"i":{"x":[0.667,0.667,0.667],"y":[1,1,1]},"o":{"x":[0.333,0.333,0.333],"y":[0,0,0]},"t":60,"s":[100,100,100]},{"t":90,"s":[180,180,100]}],"ix":6,"l":2}},"ao":0,"ef":[{"ty":5,"nm":"Extrudalizer","np":70,"mn":"Pseudo/Extrudalizer","ix":1,"en":1,"ef":[{"ty":6,"nm":"3D Transform","mn":"Pseudo/Extrudalizer-0001","ix":1,"v":0},{"ty":0,"nm":"Extrusion depth","mn":"Pseudo/Extrudalizer-0002","ix":2,"v":{"a":0,"k":300,"ix":2}},{"ty":3,"nm":"Position","mn":"Pseudo/Extrudalizer-0003","ix":3,"v":{"a":0,"k":[0,0,0],"ix":3}},{"ty":6,"nm":"Scale","mn":"Pseudo/Extrudalizer-0004","ix":4,"v":0},{"ty":0,"nm":"Front scale","mn":"Pseudo/Extrudalizer-0005","ix":5,"v":{"a":0,"k":100,"ix":5}},{"ty":0,"nm":"Back scale","mn":"Pseudo/Extrudalizer-0006","ix":6,"v":{"a":0,"k":100,"ix":6}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0007","ix":7,"v":0},{"ty":6,"nm":"Pitch/Roll/Yaw","mn":"Pseudo/Extrudalizer-0008","ix":8,"v":0},{"ty":0,"nm":"Pitch (x)","mn":"Pseudo/Extrudalizer-0009","ix":9,"v":{"a":1,"k":[{"i":{"x":[0.401],"y":[1]},"o":{"x":[0.333],"y":[0]},"t":0,"s":[-30]},{"t":60,"s":[810]}],"ix":9}},{"ty":0,"nm":"Yaw (y)","mn":"Pseudo/Extrudalizer-0010","ix":10,"v":{"a":1,"k":[{"i":{"x":[0.401],"y":[1]},"o":{"x":[0.333],"y":[0]},"t":0,"s":[30]},{"t":60,"s":[810]}],"ix":10}},{"ty":0,"nm":"Roll (z)","mn":"Pseudo/Extrudalizer-0011","ix":11,"v":{"a":1,"k":[{"i":{"x":[0.401],"y":[1]},"o":{"x":[0.333],"y":[0]},"t":0,"s":[0]},{"t":60,"s":[-720]}],"ix":11}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0012","ix":12,"v":0},{"ty":6,"nm":"Orbit control","mn":"Pseudo/Extrudalizer-0013","ix":13,"v":0},{"ty":0,"nm":"X Rotation","mn":"Pseudo/Extrudalizer-0014","ix":14,"v":{"a":0,"k":0,"ix":14}},{"ty":0,"nm":"Y Rotation","mn":"Pseudo/Extrudalizer-0015","ix":15,"v":{"a":0,"k":0,"ix":15}},{"ty":0,"nm":"Z Rotation","mn":"Pseudo/Extrudalizer-0016","ix":16,"v":{"a":0,"k":0,"ix":16}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0017","ix":17,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0018","ix":18,"v":0},{"ty":6,"nm":"Appearance","mn":"Pseudo/Extrudalizer-0019","ix":19,"v":0},{"ty":7,"nm":"Hide anchor point","mn":"Pseudo/Extrudalizer-0020","ix":20,"v":{"a":0,"k":1,"ix":20}},{"ty":7,"nm":"Wireframe mode","mn":"Pseudo/Extrudalizer-0021","ix":21,"v":{"a":0,"k":0,"ix":21}},{"ty":2,"nm":"Edge stroke color","mn":"Pseudo/Extrudalizer-0022","ix":22,"v":{"a":0,"k":[0.996078491211,0.98431378603,0.917647123337,1],"ix":22}},{"ty":0,"nm":"Edge stroke width","mn":"Pseudo/Extrudalizer-0023","ix":23,"v":{"a":0,"k":0,"ix":23}},{"ty":0,"nm":"Translucency","mn":"Pseudo/Extrudalizer-0024","ix":24,"v":{"a":0,"k":0,"ix":24}},{"ty":6,"nm":"Front & Back ","mn":"Pseudo/Extrudalizer-0025","ix":25,"v":0},{"ty":2,"nm":"Front color","mn":"Pseudo/Extrudalizer-0026","ix":26,"v":{"a":0,"k":[0.996078491211,0.98431378603,0.917647123337,1],"ix":26}},{"ty":0,"nm":"Front opacity","mn":"Pseudo/Extrudalizer-0027","ix":27,"v":{"a":0,"k":100,"ix":27}},{"ty":0,"nm":"Front gradient opacity","mn":"Pseudo/Extrudalizer-0028","ix":28,"v":{"a":0,"k":0,"ix":28}},{"ty":0,"nm":"Front gradient direction","mn":"Pseudo/Extrudalizer-0029","ix":29,"v":{"a":0,"k":0,"ix":29}},{"ty":6,"nm":"   ","mn":"Pseudo/Extrudalizer-0030","ix":30,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0031","ix":31,"v":0},{"ty":2,"nm":"Back color","mn":"Pseudo/Extrudalizer-0032","ix":32,"v":{"a":0,"k":[0.945098102093,0.917647123337,0.776470661163,1],"ix":32}},{"ty":0,"nm":"Back opacity","mn":"Pseudo/Extrudalizer-0033","ix":33,"v":{"a":0,"k":100,"ix":33}},{"ty":0,"nm":"Back gradient opacity","mn":"Pseudo/Extrudalizer-0034","ix":34,"v":{"a":0,"k":0,"ix":34}},{"ty":0,"nm":"Back gradient direction","mn":"Pseudo/Extrudalizer-0035","ix":35,"v":{"a":0,"k":0,"ix":35}},{"ty":6,"nm":"    ","mn":"Pseudo/Extrudalizer-0036","ix":36,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0037","ix":37,"v":0},{"ty":3,"nm":"Gradient start point","mn":"Pseudo/Extrudalizer-0038","ix":38,"v":{"a":0,"k":[0,0],"ix":38}},{"ty":3,"nm":"Gradient end point","mn":"Pseudo/Extrudalizer-0039","ix":39,"v":{"a":0,"k":[0,0],"ix":39}},{"ty":6,"nm":"Edit gradient start/end points o","mn":"Pseudo/Extrudalizer-0040","ix":40,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0041","ix":41,"v":0},{"ty":6,"nm":"at 3D rotation set to [0,0,0]","mn":"Pseudo/Extrudalizer-0042","ix":42,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0043","ix":43,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0044","ix":44,"v":0},{"ty":6,"nm":"Sides","mn":"Pseudo/Extrudalizer-0045","ix":45,"v":0},{"ty":2,"nm":"Sides color","mn":"Pseudo/Extrudalizer-0046","ix":46,"v":{"a":0,"k":[0,1,1,1],"ix":46}},{"ty":0,"nm":"Sides opacity","mn":"Pseudo/Extrudalizer-0047","ix":47,"v":{"a":0,"k":100,"ix":47}},{"ty":0,"nm":"Sides gradient opacity","mn":"Pseudo/Extrudalizer-0048","ix":48,"v":{"a":0,"k":25,"ix":48}},{"ty":0,"nm":"Sides gradient direction","mn":"Pseudo/Extrudalizer-0049","ix":49,"v":{"a":0,"k":0,"ix":49}},{"ty":0,"nm":"Sides gradient length","mn":"Pseudo/Extrudalizer-0050","ix":50,"v":{"a":0,"k":0,"ix":50}},{"ty":2,"nm":"Sides fill shadow color","mn":"Pseudo/Extrudalizer-0051","ix":51,"v":{"a":0,"k":[0,0,0,1],"ix":51}},{"ty":0,"nm":"Sides fill shadow opacity","mn":"Pseudo/Extrudalizer-0052","ix":52,"v":{"a":0,"k":50,"ix":52}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0053","ix":53,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0054","ix":54,"v":0},{"ty":6,"nm":"Parenting Data","mn":"Pseudo/Extrudalizer-0055","ix":55,"v":0},{"ty":0,"nm":"Front opacity readout","mn":"Pseudo/Extrudalizer-0056","ix":56,"v":{"a":0,"k":100,"ix":56,"x":"var $bm_rt;\ntry {\n    $bm_rt = content('--- EXTRUDALIZER ---').content('FRONT').transform.opacity;\n} catch (e) {\n    $bm_rt = 0;\n}"}},{"ty":0,"nm":"Back opacity readout","mn":"Pseudo/Extrudalizer-0057","ix":57,"v":{"a":0,"k":100,"ix":57,"x":"var $bm_rt;\ntry {\n    $bm_rt = content('--- EXTRUDALIZER ---').content('BACK').transform.opacity;\n} catch (e) {\n    $bm_rt = 0;\n}"}},{"ty":7,"nm":"Compute 3D front bounding box","mn":"Pseudo/Extrudalizer-0058","ix":58,"v":{"a":0,"k":1,"ix":58}},{"ty":3,"nm":"Front upper left","mn":"Pseudo/Extrudalizer-0059","ix":59,"v":{"a":0,"k":[0,0],"ix":59,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[0];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[0],\n            front_bb[1]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front upper right","mn":"Pseudo/Extrudalizer-0060","ix":60,"v":{"a":0,"k":[0,0],"ix":60,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[1];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[2],\n            front_bb[3]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front lower left","mn":"Pseudo/Extrudalizer-0061","ix":61,"v":{"a":0,"k":[0,0],"ix":61,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[2];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[4],\n            front_bb[5]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front lower right","mn":"Pseudo/Extrudalizer-0062","ix":62,"v":{"a":0,"k":[0,0],"ix":62,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[3];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[6],\n            front_bb[7]\n        ];\n    }\n}"}},{"ty":7,"nm":"Compute 3D back bounding box","mn":"Pseudo/Extrudalizer-0063","ix":63,"v":{"a":0,"k":1,"ix":63}},{"ty":3,"nm":"Back upper left","mn":"Pseudo/Extrudalizer-0064","ix":64,"v":{"a":0,"k":[0,0],"ix":64,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[0];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[0],\n            back_bb[1]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back upper right","mn":"Pseudo/Extrudalizer-0065","ix":65,"v":{"a":0,"k":[0,0],"ix":65,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[1];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[2],\n            back_bb[3]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back lower left","mn":"Pseudo/Extrudalizer-0066","ix":66,"v":{"a":0,"k":[0,0],"ix":66,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[2];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[4],\n            back_bb[5]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back lower right","mn":"Pseudo/Extrudalizer-0067","ix":67,"v":{"a":0,"k":[0,0],"ix":67,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[3];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[6],\n            back_bb[7]\n        ];\n    }\n}"}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0068","ix":68,"v":0}]},{"ty":5,"nm":"FACE 0","np":3,"mn":"ADBE Color Control","ix":2,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.945098042488,0.919524788857,0.774609744549,1],"ix":1}}]},{"ty":5,"nm":"FACE 1","np":3,"mn":"ADBE Color Control","ix":3,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.996078431606,0.984313726425,0.917647063732,1],"ix":1}}]},{"ty":5,"nm":"FACE 2","np":3,"mn":"ADBE Color Control","ix":4,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.945098042488,0.919524788857,0.774609744549,1],"ix":1}}]},{"ty":5,"nm":"FACE 3","np":3,"mn":"ADBE Color Control","ix":5,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.996078431606,0.984313726425,0.917647063732,1],"ix":1}}]}],"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[150,-150],[150,150],[-150,150],[-150,-150]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":true},{"ty":"st","c":{"a":0,"k":[0,0.925924921971,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":78,"ix":5},"lc":2,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"ORIGIN SHAPE","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nlet extr_data_arr;\nlet points_3D = [];\nlet isPathClosed;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_3D = extr_data_arr[5];\n    isPathClosed = extr_data_arr[4] === true;\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let points_arr = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    isPathClosed = extr_data_arr[4] === 'true';\n    for (var i = 0, il = points_arr.length / 3; i < il; i++) {\n        points_3D.push(points_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst points_2D = points_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst num_pts = points_2D.length;\nconst zeroArr = Array(num_pts).fill([\n    0,\n    0\n]);\n$bm_rt = createPath(points_2D, zeroArr, zeroArr, isPathClosed);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Front color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":2,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Front color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nlet extr_data_arr;\nlet is_facing_towards_us;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    is_facing_towards_us = extr_data_arr[8] === true;\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    is_facing_towards_us = extr_data_arr[8] === 'true';\n}\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = $bm_div(effect('Extrudalizer')('Translucency').value, 2);\nconst opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    if (is_facing_towards_us > 0) {\n        $bm_rt = opacity_value;\n    } else {\n        $bm_rt = transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"FRONT","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nlet extr_data_arr;\nlet points_3D = [];\nlet isPathClosed;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_3D = extr_data_arr[6];\n    isPathClosed = extr_data_arr[4] === true;\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let points_arr = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    isPathClosed = extr_data_arr[4] === 'true';\n    for (var i = 0, il = points_arr.length / 3; i < il; i++) {\n        points_3D.push(points_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst points_2D = points_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst num_pts = points_2D.length;\nconst zeroArr = Array(num_pts).fill([\n    0,\n    0\n]);\n$bm_rt = createPath(points_2D, zeroArr, zeroArr, isPathClosed);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Back color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Back color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    try {\n        const frontOpacity = content('--- EXTRUDALIZER ---').content('FRONT').transform.opacity.value;\n        $bm_rt = value = $bm_sub(100, frontOpacity);\n    } catch (e) {\n        $bm_rt = 100;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"BACK","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 0;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = true ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[0][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[0];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = false ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[0][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[0];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 0 - 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 1;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = true ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[1][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[1];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = false ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[1][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[1];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 1 - 2","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDES","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"--- EXTRUDALIZER ---","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":300,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":8,"ty":5,"nm":"EXTRUDALIZER DATA || square_1","hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[540,540,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"t":{"d":{"k":[{"s":{"s":36,"f":"TrajanPro-Bold","t":"","ca":0,"j":0,"tr":0,"lh":43.2000007629395,"ls":0,"fc":[0.267,0.722,0.765]},"t":0}],"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, arraysEqual, getNormal, get2D_projection, getBoundingBox, getPositionMatrix, getRotationMatrix, getScaleMatrix, getIdentity, translate, rotateX, rotateY, rotateZ, multiplyMatrixVector, multiplyMatrices, multiplyArrayOfMatrices, transformMatrix, make_transform, getPoint, getArea, isClockwise, getCentroid, getCentroidPro, hasNoneZeroValues, angle_between, angle_between_cw, angle_between_cw_te, isStraightLine_w_delta, isFacingTowardsUs, isVectorFacingTowardsUs, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_shape_matrix, get_transforms_from_bb, num_pts, compare_sides, sorted_sides_indices, adjustColorBrightness, lambertShader, stringify;\n'use native operators';\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\narraysEqual = function (arr1, arr2) {\n    for (var i = 0, il = arr1.length; i < il; i++) {\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n};\ngetNormal = function (pts, normalized) {\n    let dir = cross_vec(sub(pts[1], pts[0]), sub(pts[2], pts[0]));\n    let len_dir = len_vec(dir);\n    if (len_dir === 0) {\n        return [\n            0,\n            0,\n            0\n        ];\n    }\n    if (normalized) {\n        return div(dir, len_dir);\n    } else {\n        return dir;\n    }\n};\nget2D_projection = function (points) {\n    return points.map(v => [\n        v[0],\n        v[1]\n    ]);\n};\ngetBoundingBox = function (points) {\n    const boundingBox = {\n        left: Number.POSITIVE_INFINITY,\n        top: Number.POSITIVE_INFINITY,\n        right: Number.NEGATIVE_INFINITY,\n        bottom: Number.NEGATIVE_INFINITY,\n        width: undefined,\n        height: undefined,\n        center: undefined\n    };\n    points.forEach(point => {\n        boundingBox.left = Math.min(boundingBox.left, point[0]);\n        boundingBox.top = Math.min(boundingBox.top, point[1]);\n        boundingBox.right = Math.max(boundingBox.right, point[0]);\n        boundingBox.bottom = Math.max(boundingBox.bottom, point[1]);\n    });\n    boundingBox.width = sub(boundingBox.right, boundingBox.left);\n    boundingBox.height = sub(boundingBox.bottom, boundingBox.top);\n    boundingBox.center = [\n        add(boundingBox.left, $bm_div(boundingBox.width, 2)),\n        add(boundingBox.top, $bm_div(boundingBox.height, 2))\n    ];\n    boundingBox.left_top = [\n        boundingBox.left,\n        boundingBox.top\n    ];\n    boundingBox.left_bottom = [\n        boundingBox.left,\n        boundingBox.bottom\n    ];\n    boundingBox.right_top = [\n        boundingBox.right,\n        boundingBox.top\n    ];\n    boundingBox.right_bottom = [\n        boundingBox.right,\n        boundingBox.bottom\n    ];\n    return boundingBox;\n};\ngetPositionMatrix = function (value) {\n    return translate(getIdentity(), value[0], value[1], $bm_neg(value[2]));\n};\ngetRotationMatrix = function (angles) {\n    const angleX = angles[0];\n    const angleY = angles[1];\n    const angleZ = angles[2];\n    var matrix = getIdentity();\n    matrix = rotateZ(matrix, $bm_div($bm_mul(angleZ, Math.PI), 180));\n    matrix = rotateY(matrix, $bm_div($bm_mul(angleY, Math.PI), 180));\n    matrix = rotateX(matrix, $bm_div($bm_mul(angleX, Math.PI), 180));\n    return matrix;\n};\ngetScaleMatrix = function (sc) {\n    return [\n        sc,\n        0,\n        0,\n        0,\n        0,\n        sc,\n        0,\n        0,\n        0,\n        0,\n        sc,\n        0,\n        0,\n        0,\n        0,\n        1\n    ];\n};\ngetIdentity = function () {\n    return [\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n    ];\n};\ntranslate = function (matrix, x, y, z) {\n    return multiplyMatrices(matrix, [\n        1,\n        0,\n        0,\n        x,\n        0,\n        1,\n        0,\n        y,\n        0,\n        0,\n        1,\n        z,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateX = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        1,\n        0,\n        0,\n        0,\n        0,\n        cos_th,\n        $bm_neg(sin_th),\n        0,\n        0,\n        sin_th,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateY = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        cos_th,\n        0,\n        sin_th,\n        0,\n        0,\n        1,\n        0,\n        0,\n        $bm_neg(sin_th),\n        0,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateZ = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        cos_th,\n        $bm_neg(sin_th),\n        0,\n        0,\n        sin_th,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nmultiplyMatrixVector = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 4; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 4; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 4), j)], vector[j]));\n        }\n    }\n    return result;\n};\nmultiplyMatrices = function (matrixB, matrixA) {\n    let result = new Array(16).fill(0);\n    for (let i = 0; i < 4; i++) {\n        for (let j = 0; j < 4; j++) {\n            for (let k = 0; k < 4; k++) {\n                result[$bm_sum($bm_mul(i, 4), j)] = $bm_sum(result[$bm_sum($bm_mul(i, 4), j)], $bm_mul(matrixA[$bm_sum($bm_mul(i, 4), k)], matrixB[$bm_sum($bm_mul(k, 4), j)]));\n            }\n        }\n    }\n    return result;\n};\nmultiplyArrayOfMatrices = function (matrices) {\n    var result = matrices[0];\n    for (var i = 1, il = matrices.length; i < il; i++) {\n        result = multiplyMatrices(result, matrices[i]);\n    }\n    return result;\n};\ntransformMatrix = function (move, sc, pivot, pitch_angles, anch, orbit_angles) {\n    var mat_array = [];\n    if (sc !== 1) {\n        if (!arraysEqual(pivot, [\n                0,\n                0,\n                0\n            ])) {\n            mat_array = mat_array.concat([\n                getPositionMatrix(pivot.map(i => -i)),\n                getScaleMatrix(sc),\n                getPositionMatrix(pivot)\n            ]);\n        } else {\n            mat_array.push(getScaleMatrix(sc));\n        }\n    }\n    mat_array.push(getPositionMatrix(move));\n    if (!arraysEqual(pitch_angles, [\n            0,\n            0,\n            0\n        ])) {\n        if (!arraysEqual(pivot, [\n                0,\n                0,\n                0\n            ])) {\n            mat_array = mat_array.concat([\n                getPositionMatrix(pivot.map(i => -i)),\n                getRotationMatrix(pitch_angles),\n                getPositionMatrix(pivot)\n            ]);\n        } else {\n            mat_array.push(getRotationMatrix(pitch_angles));\n        }\n    }\n    if (!arraysEqual(anch, [\n            0,\n            0,\n            0\n        ])) {\n        mat_array.push(getPositionMatrix(anch.map(i => -i)));\n    }\n    if (!arraysEqual(orbit_angles, [\n            0,\n            0,\n            0\n        ])) {\n        mat_array.push(getRotationMatrix(orbit_angles));\n    }\n    return multiplyArrayOfMatrices(mat_array);\n};\nmake_transform = function (transform_matrix, vector) {\n    if (vector.length == 2) {\n        vector = [\n            ...vector,\n            0,\n            1\n        ];\n    } else if (vector.length == 3) {\n        vector = [\n            ...vector,\n            1\n        ];\n    }\n    var result_vector_4d = multiplyMatrixVector(transform_matrix, vector);\n    return result_vector_4d.slice(0, 3);\n};\ngetPoint = function (p1, cp1, cp2, p2, t) {\n    const x = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[0]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[0])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[0])), $bm_mul(Math.pow(t, 3), p2[0]));\n    const y = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[1]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[1])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[1])), $bm_mul(Math.pow(t, 3), p2[1]));\n    return [\n        x,\n        y\n    ];\n};\ngetArea = function (points) {\n    var area = 0;\n    for (var i = 0, il = points.length; i < il; i++) {\n        var p1 = points[i];\n        var p2 = points[(i + 1) % il];\n        area = $bm_sum(area, $bm_sub($bm_mul(p1[0], p2[1]), $bm_mul(p2[0], p1[1])));\n    }\n    return $bm_div(area, 2);\n};\nisClockwise = function (points) {\n    return getArea(points) > 0;\n};\ngetCentroid = function (vertices) {\n    var area = getArea(vertices);\n    if (area === 0) {\n        function findCenter(points) {\n            let sumX = 0;\n            let sumY = 0;\n            for (let i = 0, il = points.length; i < il; i++) {\n                const point = points[i];\n                sumX = $bm_sum(sumX, point[0]);\n                sumY = $bm_sum(sumY, point[1]);\n            }\n            const meanX = $bm_div(sumX, points.length);\n            const meanY = $bm_div(sumY, points.length);\n            return [\n                meanX,\n                meanY\n            ];\n        }\n        return findCenter(vertices);\n    }\n    let centroidX = 0;\n    let centroidY = 0;\n    const numVertices = vertices.length;\n    for (var i = 0; i < numVertices; i++) {\n        var currentVertex = vertices[i];\n        var nextVertex = vertices[(i + 1) % numVertices];\n        var commonFactor = $bm_sub($bm_mul(currentVertex[0], nextVertex[1]), $bm_mul(nextVertex[0], currentVertex[1]));\n        centroidX = $bm_sum(centroidX, $bm_mul($bm_sum(currentVertex[0], nextVertex[0]), commonFactor));\n        centroidY = $bm_sum(centroidY, $bm_mul($bm_sum(currentVertex[1], nextVertex[1]), commonFactor));\n    }\n    var scaleFactor = $bm_div(1, $bm_mul(6, area));\n    centroidX *= scaleFactor;\n    centroidY *= scaleFactor;\n    return [\n        centroidX,\n        centroidY\n    ];\n};\ngetCentroidPro = function (vertices) {\n    const bb = getBoundingBox(vertices);\n    return {\n        0: bb.left_top,\n        1: [\n            (bb.left_top[0] + bb.right_top[0]) / 2,\n            bb.left_top[1]\n        ],\n        2: bb.right_top,\n        3: [\n            (bb.left_top[0] + bb.left_bottom[0]) / 2,\n            (bb.left_top[1] + bb.left_bottom[1]) / 2\n        ],\n        4: getCentroid(vertices),\n        5: [\n            (bb.right_top[0] + bb.right_bottom[0]) / 2,\n            (bb.right_top[1] + bb.right_bottom[1]) / 2\n        ],\n        6: bb.left_bottom,\n        7: [\n            (bb.left_bottom[0] + bb.right_bottom[0]) / 2,\n            bb.left_bottom[1]\n        ],\n        8: bb.right_bottom\n    };\n};\nhasNoneZeroValues = function (array2D) {\n    return array2D.some(array => array.some(value => value !== 0));\n};\nangle_between = function (a, b) {\n    const dot_prod = dot_(a, b);\n    const mag_a = len_vec(a);\n    const mag_b = len_vec(b);\n    const cos_ = $bm_div(dot_prod, $bm_mul(mag_a, mag_b));\n    return cos_;\n};\nangle_between_cw = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    angle = angle >= 0 ? angle : $bm_sum($bm_mul(2, Math.PI), angle);\n    const degrees = $bm_mul(angle, $bm_div(180, Math.PI));\n    return degrees;\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nisStraightLine_w_delta = function (cp1, cp2, delta) {\n    return angle_between(cp1, cp2) <= -delta;\n};\nisFacingTowardsUs = function (p1, p2) {\n    return dot_(sub(p2, p1), [\n        0,\n        0,\n        1\n    ]) > 0;\n};\nisVectorFacingTowardsUs = function (v) {\n    return dot_(v, [\n        0,\n        0,\n        -1\n    ]) > 0;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_shape_matrix = function (anchor, pos, scale, rot, skew, skew_axis) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (skew !== 0) {\n        const sk_angle = $bm_div($bm_mul(skew, Math.PI), 180);\n        const Sk = [\n            1,\n            Math.tan(-sk_angle),\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            1\n        ];\n        if (skew_axis !== 0) {\n            const sk_axis_angle = $bm_div($bm_mul(skew_axis, Math.PI), 180);\n            const cos_sk = Math.cos(sk_axis_angle);\n            const sin_sk = Math.sin(sk_axis_angle);\n            const Rz = [\n                cos_sk,\n                -sin_sk,\n                0,\n                sin_sk,\n                cos_sk,\n                0,\n                0,\n                0,\n                1\n            ];\n            const Rz_inv = [\n                cos_sk,\n                sin_sk,\n                0,\n                -sin_sk,\n                cos_sk,\n                0,\n                0,\n                0,\n                1\n            ];\n            const SkM = multiplyArrayOfMatrices3x3([\n                Rz_inv,\n                Sk,\n                Rz\n            ]);\n            mat_array.push(SkM);\n        } else {\n            mat_array.push(Sk);\n        }\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nget_transforms_from_bb = function (bb, extr_transform_matrix, layer_transform_matrix, parent_transform_matrix, is_front, front_facing_towards_us, mode) {\n    let bb_transformed_3D = [];\n    if (front_facing_towards_us) {\n        bb_transformed_3D = [\n            bb.left_top,\n            bb.right_top,\n            bb.left_bottom,\n            bb.right_bottom\n        ];\n    } else {\n        bb_transformed_3D = [\n            bb.right_top,\n            bb.left_top,\n            bb.right_bottom,\n            bb.left_bottom\n        ];\n    }\n    bb_transformed_3D = bb_transformed_3D.map(pnt => make_transform(extr_transform_matrix, pnt));\n    let bb_transformed_2D = get2D_projection(bb_transformed_3D);\n    bb_transformed_2D = bb_transformed_2D.map(p => transform2D_apply(layer_transform_matrix, p));\n    if (parent_transform_matrix) {\n        bb_transformed_2D = bb_transformed_2D.map(p => transform2D_apply(parent_transform_matrix, p));\n    }\n    const ex_left_top = bb_transformed_2D[0], ex_right_top = bb_transformed_2D[1], ex_left_bottom = bb_transformed_2D[2], ex_right_bottom = bb_transformed_2D[3];\n    let transform_effect_controls = [];\n    if (mode & 1) {\n        const bb_pos = ex_left_top;\n        const ex_AD = sub(ex_left_bottom, ex_left_top);\n        const rot = angle_between_cw_te(ex_AD, [\n            0,\n            1\n        ]);\n        const ex_AB = sub(ex_right_top, ex_left_top);\n        const rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\n        const x_rot = [\n            Math.cos(rot_rad),\n            Math.sin(rot_rad)\n        ];\n        let skw = angle_between_cw_te(ex_AB, x_rot);\n        if (!front_facing_towards_us) {\n            skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n            skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n        }\n        ;\n        let extra_skew_arr = [];\n        if (Math.abs(skw) > 70) {\n            const max_count = 7;\n            let count = 1;\n            let skew_ = Math.abs(skw);\n            const tan_70 = Math.tan(degreesToRadians(70));\n            while (skew_ > 70 && count < max_count) {\n                skew_ = radiansToDegrees(Math.atan($bm_sub(Math.tan(degreesToRadians(skew_)), tan_70)));\n                extra_skew_arr.push(skw > 0 ? skew_ : -skew_);\n                count++;\n            }\n        }\n        const scaleY = $bm_mul(100, len_vec(ex_AD));\n        const angle_AB_AD = angle_between_cw_te(ex_AD, ex_AB);\n        const beta = $bm_sub($bm_sub(180, angle_AB_AD), skw);\n        const scaleX_coeff = $bm_div(Math.sin($bm_div($bm_mul(beta, Math.PI), 180)), Math.sin($bm_div($bm_mul(angle_AB_AD, Math.PI), 180)));\n        let scaleX = $bm_div($bm_mul(100, len_vec(ex_AB)), scaleX_coeff);\n        if (!front_facing_towards_us) {\n            scaleX = $bm_neg(scaleX);\n        }\n        transform_effect_controls = [\n            bb_pos,\n            rot,\n            skw,\n            scaleY,\n            scaleX,\n            extra_skew_arr\n        ];\n    }\n    let transform_layer_controls = [];\n    if (mode & 2) {\n        const tl_AB = sub(bb.right_top, bb.left_top);\n        const tl_AD = sub(bb.left_bottom, bb.left_top);\n        const tl_scaleX_coeff = 100;\n        const tl_scaleY_coeff = 100;\n        const tl_bb_anchor = bb.left_top;\n        let tl_bb_pos = ex_left_top;\n        const tl_ex_AB = sub(ex_right_top, ex_left_top);\n        let tl_bb_theta = angle_between_cw(tl_AB, tl_ex_AB);\n        let tl_bb_scx = $bm_div($bm_mul(tl_scaleX_coeff, len_vec(tl_ex_AB)), len_vec(tl_AB));\n        const tl_ex_AD = sub(ex_left_bottom, ex_left_top);\n        const tl_bb_th_rad = $bm_mul(tl_bb_theta, $bm_div(Math.PI, 180));\n        const tl_cos_th = Math.cos(tl_bb_th_rad);\n        const tl_sin_th = Math.sin(tl_bb_th_rad);\n        const tl_AD_rot = [\n            tl_AD[0] * tl_cos_th - tl_AD[1] * tl_sin_th,\n            tl_AD[0] * tl_sin_th + tl_AD[1] * tl_cos_th\n        ];\n        let tl_skew = angle_between_cw(tl_AD_rot, tl_ex_AD);\n        tl_skew = tl_skew < 90 ? tl_skew : $bm_sub(tl_skew, 360);\n        const tl_sk_rad = $bm_div($bm_mul(tl_skew, Math.PI), 180);\n        const tl_AD_skew = [\n            tl_AD[0] + Math.tan(-tl_sk_rad) * tl_AD[1],\n            tl_AD[1]\n        ];\n        const tl_bb_scy = $bm_div($bm_mul(tl_scaleY_coeff, len_vec(tl_ex_AD)), len_vec(tl_AD_skew));\n        if (front_facing_towards_us && !is_front || !front_facing_towards_us && is_front) {\n            tl_bb_scx = $bm_neg(tl_bb_scx);\n            tl_bb_pos = $bm_sum(tl_bb_pos, tl_ex_AB);\n        }\n        transform_layer_controls = [\n            tl_bb_anchor[0],\n            tl_bb_anchor[1],\n            tl_bb_pos[0],\n            tl_bb_pos[1],\n            tl_bb_theta,\n            tl_bb_scx,\n            tl_bb_scy,\n            tl_skew\n        ];\n    }\n    return {\n        'boundingBoxTransformed': bb_transformed_2D,\n        'transformEffectControls': transform_effect_controls,\n        'transformLayerControls': transform_layer_controls\n    };\n};\nconst shape_layer = thisComp.layer('square_1');\nconst shape = shape_layer(2)(1);\nconst shape_contents = shape(2);\nconst targetPath = shape_contents(1)(2);\nconst is_path_closed = targetPath.isClosed();\nconst extrudalizer = shape_layer('ADBE Effect Parade')('Pseudo/Extrudalizer');\nconst depth = extrudalizer('Extrusion depth').value;\nlet anchor = extrudalizer('Position').value;\nanchor = [\n    $bm_neg(anchor[0]),\n    anchor[1],\n    anchor[2]\n];\nconst angleX = extrudalizer('X Rotation').value;\nconst angleY = extrudalizer('Y Rotation').value;\nconst angleZ = extrudalizer('Z Rotation').value;\nconst pivot_angleX = extrudalizer('Pitch (x)').value;\nconst pivot_angleY = extrudalizer('Yaw (y)').value;\nconst pivot_angleZ = extrudalizer('Roll (z)').value;\nconst scale_front = $bm_div(extrudalizer('Front scale').value, 100);\nconst scale_back = $bm_div(extrudalizer('Back scale').value, 100);\nconst use_bb_front = extrudalizer('Compute 3D front bounding box').value;\nconst use_bb_back = extrudalizer('Compute 3D back bounding box').value;\nlet pnts = targetPath.points();\nlet inTangents = targetPath.inTangents();\nlet outTangents = targetPath.outTangents();\nconst is_front_clockwise = isClockwise(pnts);\nconst shape_transform = shape.transform;\nconst s_anchor = shape_transform.anchorPoint;\nconst s_pos = shape_transform.position;\nconst s_scale = shape_transform.scale;\nconst s_rot = shape_transform.rotation;\nconst s_skew = shape_transform.skew;\nconst s_skew_axis = shape_transform.skewAxis;\nconst shape_transform_matrix = get_transform_shape_matrix(s_anchor, s_pos, s_scale, s_rot, s_skew, s_skew_axis);\nconst layer_transform = shape_layer.transform;\nconst l_anchor = layer_transform.anchorPoint;\nconst l_pos = layer_transform.position;\nconst l_scale = layer_transform.scale;\nconst l_rot = layer_transform.rotation;\nconst layer_transform_matrix = get_transform_shape_matrix(l_anchor, l_pos, l_scale, l_rot, 0, 0);\nlet subdivs = 1;\nlet num_pnts = pnts.length;\nif (hasNoneZeroValues(inTangents) || hasNoneZeroValues(outTangents)) {\n    subdivs = 5;\n    let pointsF = [];\n    for (var i = 0; i < num_pnts; i++) {\n        pointsF.push(pnts[i]);\n        if (!is_path_closed && i == num_pnts - 1) {\n            break;\n        }\n        var p1 = pnts[i], p2 = pnts[(i + 1) % num_pnts];\n        var out1 = outTangents[i], in2 = inTangents[(i + 1) % num_pnts];\n        var cp1 = add(p1, out1), cp2 = add(p2, in2);\n        var len_out1 = len_vec(out1), len_in2 = len_vec(in2);\n        var len_p1p2 = len_vec(sub(p2, p1));\n        if (len_out1 !== 0 || len_in2 !== 0) {\n            var a = len_out1 === 0 ? sub(p2, p1) : out1;\n            var b = len_in2 === 0 ? sub(p1, p2) : in2;\n            if (!isStraightLine_w_delta(a, b, 0.999) && (len_out1 > len_p1p2 * 0.02 || len_in2 > len_p1p2 * 0.02)) {\n                for (var j = 1; j < subdivs; j++) {\n                    var t = $bm_div(j, subdivs);\n                    pointsF.push(getPoint(p1, cp1, cp2, p2, t));\n                }\n            }\n        }\n    }\n    pnts = pointsF;\n}\npnts = pnts.map(p => transform2D_apply(shape_transform_matrix, p));\nnum_pts = pnts.length;\nconst zero_center_point = getCentroidPro(pnts)[4];\nlet z_coord = 0;\nswitch (1) {\ncase 0:\n    z_coord = $bm_div($bm_neg(depth), 2);\n    break;\ncase 1:\n    z_coord = 0;\n    break;\ncase 2:\n    z_coord = $bm_div(depth, 2);\n    break;\n}\n;\nconst zero_center_point_3D = [\n    ...zero_center_point,\n    z_coord\n];\nconst pivot_matrix = transformMatrix([\n    0,\n    0,\n    z_coord\n], 1, [\n    0,\n    0,\n    0\n], [\n    0,\n    0,\n    0\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst pivot_position = make_transform(pivot_matrix, zero_center_point);\nconst tr_front_mat = transformMatrix([\n    0,\n    0,\n    $bm_div($bm_neg(depth), 2)\n], scale_front, zero_center_point_3D, [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst tr_back_mat = transformMatrix([\n    0,\n    0,\n    $bm_div(depth, 2)\n], scale_back, zero_center_point_3D, [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst rot_matrix = transformMatrix([\n    0,\n    0,\n    0\n], 1, [\n    0,\n    0,\n    0\n], [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], [\n    0,\n    0,\n    0\n], [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst z1_transformed = make_transform(rot_matrix, [\n    0,\n    0,\n    -1\n]);\nconst front_facing_towards_us = isVectorFacingTowardsUs(z1_transformed);\nlet points_front_3D = pnts.map(pnt => make_transform(tr_front_mat, pnt));\nlet points_back_3D = pnts.map(pnt => make_transform(tr_back_mat, pnt));\nlet winding_sides = [];\nlet sorted_sides = [];\nlet sorted_side_colors = [];\nlet num_sides_towards_us = 0;\nfor (var i = 0; i < num_pts; i++) {\n    if (!is_path_closed && i == num_pts - 1) {\n        break;\n    }\n    var F1 = points_front_3D[i], F2 = points_front_3D[(i + 1) % num_pts];\n    var B1 = points_back_3D[i], B2 = points_back_3D[(i + 1) % num_pts];\n    let abs_side_normal = getNormal([\n        F2,\n        F1,\n        B1\n    ], true);\n    let real_side_normal = !is_front_clockwise ? mul(abs_side_normal, -1) : abs_side_normal;\n    const sideIsFacingUs = isFacingTowardsUs([\n        0,\n        0,\n        0\n    ], real_side_normal);\n    if (sideIsFacingUs) {\n        num_sides_towards_us++;\n    }\n    winding_sides.push(sideIsFacingUs);\n    let side_sorted = [\n        F2,\n        F1,\n        B1,\n        B2\n    ];\n    side_sorted.sort((a, b) => b[2] - a[2]);\n    sorted_sides.push([\n        side_sorted,\n        i,\n        $bm_mod($bm_sum(i, 1), num_pts),\n        abs_side_normal\n    ]);\n}\ncompare_sides = function (side1, side2) {\n    const s1_vertices_z = side1[0].map(v => v[2]), s2_vertices_z = side2[0].map(v => v[2]);\n    for (var i = 0, il = side1[0].length; i < il; i++) {\n        if (s1_vertices_z[i] != s2_vertices_z[i]) {\n            return $bm_sub(s2_vertices_z[i], s1_vertices_z[i]);\n        }\n    }\n};\nsorted_sides.sort((a, b) => compare_sides(a, b));\nsorted_sides.sort(function (a, b) {\n    const fa = winding_sides[a[1]], fb = winding_sides[b[1]];\n    if (fa && !fb) {\n        return -1;\n    } else if (!fa && fb) {\n        return 1;\n    } else {\n        return 0;\n    }\n});\nsorted_sides_indices = sorted_sides.map(p => [\n    p[1],\n    p[2]\n]);\nif (true) {\n    const lambert_max = extrudalizer('Sides fill shadow opacity').value;\n    const rgba = extrudalizer('Sides color').value;\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    lambertShader = function (normal, max_value, multiplier) {\n        return $bm_div($bm_mul($bm_mul(multiplier, $bm_sub(100, max_value)), Math.abs(dot_(normal, [\n            0,\n            0,\n            1\n        ]))), 100);\n    };\n    sorted_side_colors = sorted_sides.map(p => adjustColorBrightness(rgba, lambertShader(p[3], lambert_max, 2)));\n}\nconst front_normal = div(z1_transformed, len_vec(z1_transformed));\nlet bb_front_2D = [], bb_back_2D = [], bb_front_transforms_te = [], bb_back_transforms_te = [], bb_front_transforms_tl = [], bb_back_transforms_tl = [];\nif (use_bb_back || use_bb_front) {\n    const bb = getBoundingBox(pnts);\n    let hasParent = shape_layer.hasParent;\n    let parent_transform_matrix = null;\n    if (hasParent) {\n        let p_pos = shape_layer.parent.transform.position;\n        let p_anchor = shape_layer.parent.transform.anchorPoint;\n        let p_rot = shape_layer.parent.transform.rotation;\n        let p_sca = shape_layer.parent.transform.scale;\n        parent_transform_matrix = get_transform_shape_matrix(p_anchor, p_pos, p_sca, p_rot, 0, 0);\n    }\n    if (use_bb_front) {\n        const bb_front_data = get_transforms_from_bb(bb, tr_front_mat, layer_transform_matrix, parent_transform_matrix, true, front_facing_towards_us, 3);\n        bb_front_2D = bb_front_data['boundingBoxTransformed'];\n        bb_front_transforms_te = bb_front_data['transformEffectControls'];\n        bb_front_transforms_tl = bb_front_data['transformLayerControls'];\n    }\n    if (use_bb_back) {\n        const bb_back_data = get_transforms_from_bb(bb, tr_back_mat, layer_transform_matrix, parent_transform_matrix, false, front_facing_towards_us, 3);\n        bb_back_2D = bb_back_data['boundingBoxTransformed'];\n        bb_back_transforms_te = bb_back_data['transformEffectControls'];\n        bb_back_transforms_tl = bb_back_data['transformLayerControls'];\n    }\n}\nlet grad_property = null;\ntry {\n    grad_property = shape_contents('ADBE Vector Graphic - G-Fill');\n} catch (e) {\n}\nlet grad_start_front_new = [\n    0,\n    0\n];\nlet grad_end_front_new = [\n    0,\n    0\n];\nlet grad_start_back_new = [\n    0,\n    0\n];\nlet grad_end_back_new = [\n    0,\n    0\n];\nif (grad_property != null) {\n    let grad_start = grad_property.startPoint.value;\n    let grad_end = grad_property.endPoint.value;\n    grad_start = transform2D_apply(shape_transform_matrix, grad_start);\n    grad_end = transform2D_apply(shape_transform_matrix, grad_end);\n    const grad_start_front = make_transform(tr_front_mat, grad_start);\n    const grad_end_front = make_transform(tr_front_mat, grad_end);\n    const grad_start_back = make_transform(tr_back_mat, grad_start);\n    const grad_end_back = make_transform(tr_back_mat, grad_end);\n    grad_start_front_new = grad_start_front;\n    grad_end_front_new = grad_end_front;\n    grad_start_back_new = grad_start_back;\n    grad_end_back_new = grad_end_back;\n    const grad_front_rot = $bm_div($bm_mul(extrudalizer('Front gradient direction').value, Math.PI), 180);\n    const grad_back_rot = $bm_div($bm_mul(extrudalizer('Back gradient direction').value, Math.PI), 180);\n    if (!arraysEqual([\n            grad_front_rot,\n            grad_back_rot\n        ], [\n            0,\n            0\n        ])) {\n        const grad_origin_front = div(add(grad_end_front, grad_start_front), 2);\n        const grad_origin_back = div(add(grad_end_back, grad_start_back), 2);\n        const grad_p_st_front = sub(grad_start_front, grad_origin_front);\n        const grad_p_end_front = sub(grad_end_front, grad_origin_front);\n        const grad_p_st_back = sub(grad_start_back, grad_origin_back);\n        const grad_p_end_back = sub(grad_end_back, grad_origin_back);\n        if (grad_front_rot != 0) {\n            const cos_st = Math.cos(grad_front_rot), sin_st = Math.sin(grad_front_rot);\n            grad_start_front_new[0] = $bm_sum($bm_sub($bm_mul(cos_st, grad_p_st_front[0]), $bm_mul(sin_st, grad_p_st_front[1])), grad_origin_front[0]);\n            grad_start_front_new[1] = $bm_sum($bm_sum($bm_mul(sin_st, grad_p_st_front[0]), $bm_mul(cos_st, grad_p_st_front[1])), grad_origin_front[1]);\n            grad_end_front_new[0] = $bm_sum($bm_sub($bm_mul(cos_st, grad_p_end_front[0]), $bm_mul(sin_st, grad_p_end_front[1])), grad_origin_front[0]);\n            grad_end_front_new[1] = $bm_sum($bm_sum($bm_mul(sin_st, grad_p_end_front[0]), $bm_mul(cos_st, grad_p_end_front[1])), grad_origin_front[1]);\n        }\n        if (grad_back_rot != 0) {\n            const cos_st_b = Math.cos(grad_back_rot), sin_st_b = Math.sin(grad_back_rot);\n            grad_start_back_new[0] = $bm_sum($bm_sub($bm_mul(cos_st_b, grad_p_st_back[0]), $bm_mul(sin_st_b, grad_p_st_back[1])), grad_origin_back[0]);\n            grad_start_back_new[1] = $bm_sum($bm_sum($bm_mul(sin_st_b, grad_p_st_back[0]), $bm_mul(cos_st_b, grad_p_st_back[1])), grad_origin_back[1]);\n            grad_end_back_new[0] = $bm_sum($bm_sub($bm_mul(cos_st_b, grad_p_end_back[0]), $bm_mul(sin_st_b, grad_p_end_back[1])), grad_origin_back[0]);\n            grad_end_back_new[1] = $bm_sum($bm_sum($bm_mul(sin_st_b, grad_p_end_back[0]), $bm_mul(cos_st_b, grad_p_end_back[1])), grad_origin_back[1]);\n        }\n    }\n}\nconst extr_data = [\n    tr_front_mat,\n    tr_back_mat,\n    shape_transform_matrix,\n    subdivs,\n    is_path_closed,\n    points_front_3D,\n    points_back_3D,\n    sorted_sides_indices,\n    front_facing_towards_us,\n    is_front_clockwise,\n    num_sides_towards_us,\n    sorted_side_colors,\n    pivot_position,\n    front_normal,\n    bb_front_2D,\n    bb_back_2D,\n    bb_front_transforms_te,\n    bb_back_transforms_te,\n    bb_front_transforms_tl,\n    bb_back_transforms_tl,\n    grad_start_front_new,\n    grad_end_front_new,\n    grad_start_back_new,\n    grad_end_back_new\n];\nvar txt = '';\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'] = extr_data;\n} catch (err) {\n    stringify = function (data, separator) {\n        return data.map(item => Array.isArray(item) ? item.join(',') : item.toString()).join(separator);\n    };\n    txt = stringify(extr_data, ';');\n}\n$bm_rt = txt;"},"p":{},"m":{"g":1,"a":{"a":0,"k":[0,0],"ix":2}},"a":[]},"ip":0,"op":300,"st":0,"ct":1,"bm":0}]},{"id":"comp_10","nm":"Selfie_Face","fr":30,"layers":[{"ddd":0,"ind":1,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [3]","refId":"comp_1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [2]","refId":"comp_2","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":3,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [1]","refId":"comp_3","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":4,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [0]","refId":"comp_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":5,"ty":0,"nm":"MAP || Dice || square_1 || BACK","refId":"comp_5","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('square_1').effect('Extrudalizer')('Back opacity readout');"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[150,150],"ix":1,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst is_front = false;\nconst precomp_width = 300;\nlet extr_data_arr = [];\nlet is_facing_us = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    $bm_rt = is_facing_us = extr_data_arr[8];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    $bm_rt = is_facing_us = extr_data_arr[8] == 'true';\n}\nfunction logicalXOR(input1, input2) {\n    return input1 && !input2 || !input1 && input2;\n}\nif (logicalXOR(is_front, is_facing_us)) {\n    $bm_rt = value = [\n        precomp_width,\n        0\n    ];\n} else {\n    $bm_rt = value = [\n        0,\n        0\n    ];\n}"}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst POS_INDEX_LOTTIE = 0;\nconst POS_INDEX_1 = 0;\nconst POS_INDEX_2 = 1;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let pos = [\n        0,\n        0\n    ];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        $bm_rt = pos = transform_effect_controls[POS_INDEX_LOTTIE];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        $bm_rt = pos = [\n            transform_effect_controls[POS_INDEX_1],\n            transform_effect_controls[POS_INDEX_2]\n        ];\n    }\n}"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 3;\nconst control_index_ae = 4;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.height;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 4;\nconst control_index_ae = 5;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = $bm_neg(thisLayer.width);\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 2;\nconst control_index_ae = 3;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 1;\nconst control_index_ae = 2;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'Back';\nconst face_opacity = ex_layer.effect('Extrudalizer')(face + ' opacity readout').value;\n$bm_rt = face_opacity;"}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":6,"ty":0,"nm":"MAP || Dice || square_1 || FRONT","refId":"comp_6","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('square_1').effect('Extrudalizer')('Front opacity readout');"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[150,150],"ix":1,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst is_front = true;\nconst precomp_width = 300;\nlet extr_data_arr = [];\nlet is_facing_us = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    $bm_rt = is_facing_us = extr_data_arr[8];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    $bm_rt = is_facing_us = extr_data_arr[8] == 'true';\n}\nfunction logicalXOR(input1, input2) {\n    return input1 && !input2 || !input1 && input2;\n}\nif (logicalXOR(is_front, is_facing_us)) {\n    $bm_rt = value = [\n        precomp_width,\n        0\n    ];\n} else {\n    $bm_rt = value = [\n        0,\n        0\n    ];\n}"}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst POS_INDEX_LOTTIE = 0;\nconst POS_INDEX_1 = 0;\nconst POS_INDEX_2 = 1;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let pos = [\n        0,\n        0\n    ];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        $bm_rt = pos = transform_effect_controls[POS_INDEX_LOTTIE];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        $bm_rt = pos = [\n            transform_effect_controls[POS_INDEX_1],\n            transform_effect_controls[POS_INDEX_2]\n        ];\n    }\n}"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 3;\nconst control_index_ae = 4;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.height;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 4;\nconst control_index_ae = 5;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.width;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 2;\nconst control_index_ae = 3;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 1;\nconst control_index_ae = 2;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'Front';\nconst face_opacity = ex_layer.effect('Extrudalizer')(face + ' opacity readout').value;\n$bm_rt = face_opacity;"}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":7,"ty":4,"nm":"square_1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[540,540,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":1,"k":[{"i":{"x":[0.667,0.667,0.667],"y":[1,1,1]},"o":{"x":[0.333,0.333,0.333],"y":[0,0,0]},"t":60,"s":[100,100,100]},{"t":90,"s":[180,180,100]}],"ix":6,"l":2}},"ao":0,"ef":[{"ty":5,"nm":"Extrudalizer","np":70,"mn":"Pseudo/Extrudalizer","ix":1,"en":1,"ef":[{"ty":6,"nm":"3D Transform","mn":"Pseudo/Extrudalizer-0001","ix":1,"v":0},{"ty":0,"nm":"Extrusion depth","mn":"Pseudo/Extrudalizer-0002","ix":2,"v":{"a":0,"k":300,"ix":2}},{"ty":3,"nm":"Position","mn":"Pseudo/Extrudalizer-0003","ix":3,"v":{"a":0,"k":[0,0,0],"ix":3}},{"ty":6,"nm":"Scale","mn":"Pseudo/Extrudalizer-0004","ix":4,"v":0},{"ty":0,"nm":"Front scale","mn":"Pseudo/Extrudalizer-0005","ix":5,"v":{"a":0,"k":100,"ix":5}},{"ty":0,"nm":"Back scale","mn":"Pseudo/Extrudalizer-0006","ix":6,"v":{"a":0,"k":100,"ix":6}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0007","ix":7,"v":0},{"ty":6,"nm":"Pitch/Roll/Yaw","mn":"Pseudo/Extrudalizer-0008","ix":8,"v":0},{"ty":0,"nm":"Pitch (x)","mn":"Pseudo/Extrudalizer-0009","ix":9,"v":{"a":1,"k":[{"i":{"x":[0.401],"y":[1]},"o":{"x":[0.333],"y":[0]},"t":0,"s":[-30]},{"t":60,"s":[-450]}],"ix":9}},{"ty":0,"nm":"Yaw (y)","mn":"Pseudo/Extrudalizer-0010","ix":10,"v":{"a":1,"k":[{"i":{"x":[0.401],"y":[1]},"o":{"x":[0.333],"y":[0]},"t":0,"s":[30]},{"t":60,"s":[810]}],"ix":10}},{"ty":0,"nm":"Roll (z)","mn":"Pseudo/Extrudalizer-0011","ix":11,"v":{"a":1,"k":[{"i":{"x":[0.401],"y":[1]},"o":{"x":[0.333],"y":[0]},"t":0,"s":[0]},{"t":60,"s":[-720]}],"ix":11}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0012","ix":12,"v":0},{"ty":6,"nm":"Orbit control","mn":"Pseudo/Extrudalizer-0013","ix":13,"v":0},{"ty":0,"nm":"X Rotation","mn":"Pseudo/Extrudalizer-0014","ix":14,"v":{"a":0,"k":0,"ix":14}},{"ty":0,"nm":"Y Rotation","mn":"Pseudo/Extrudalizer-0015","ix":15,"v":{"a":0,"k":0,"ix":15}},{"ty":0,"nm":"Z Rotation","mn":"Pseudo/Extrudalizer-0016","ix":16,"v":{"a":0,"k":0,"ix":16}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0017","ix":17,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0018","ix":18,"v":0},{"ty":6,"nm":"Appearance","mn":"Pseudo/Extrudalizer-0019","ix":19,"v":0},{"ty":7,"nm":"Hide anchor point","mn":"Pseudo/Extrudalizer-0020","ix":20,"v":{"a":0,"k":1,"ix":20}},{"ty":7,"nm":"Wireframe mode","mn":"Pseudo/Extrudalizer-0021","ix":21,"v":{"a":0,"k":0,"ix":21}},{"ty":2,"nm":"Edge stroke color","mn":"Pseudo/Extrudalizer-0022","ix":22,"v":{"a":0,"k":[0.996078491211,0.98431378603,0.917647123337,1],"ix":22}},{"ty":0,"nm":"Edge stroke width","mn":"Pseudo/Extrudalizer-0023","ix":23,"v":{"a":0,"k":0,"ix":23}},{"ty":0,"nm":"Translucency","mn":"Pseudo/Extrudalizer-0024","ix":24,"v":{"a":0,"k":0,"ix":24}},{"ty":6,"nm":"Front & Back ","mn":"Pseudo/Extrudalizer-0025","ix":25,"v":0},{"ty":2,"nm":"Front color","mn":"Pseudo/Extrudalizer-0026","ix":26,"v":{"a":0,"k":[0.996078491211,0.98431378603,0.917647123337,1],"ix":26}},{"ty":0,"nm":"Front opacity","mn":"Pseudo/Extrudalizer-0027","ix":27,"v":{"a":0,"k":100,"ix":27}},{"ty":0,"nm":"Front gradient opacity","mn":"Pseudo/Extrudalizer-0028","ix":28,"v":{"a":0,"k":0,"ix":28}},{"ty":0,"nm":"Front gradient direction","mn":"Pseudo/Extrudalizer-0029","ix":29,"v":{"a":0,"k":0,"ix":29}},{"ty":6,"nm":"   ","mn":"Pseudo/Extrudalizer-0030","ix":30,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0031","ix":31,"v":0},{"ty":2,"nm":"Back color","mn":"Pseudo/Extrudalizer-0032","ix":32,"v":{"a":0,"k":[0.945098102093,0.917647123337,0.776470661163,1],"ix":32}},{"ty":0,"nm":"Back opacity","mn":"Pseudo/Extrudalizer-0033","ix":33,"v":{"a":0,"k":100,"ix":33}},{"ty":0,"nm":"Back gradient opacity","mn":"Pseudo/Extrudalizer-0034","ix":34,"v":{"a":0,"k":0,"ix":34}},{"ty":0,"nm":"Back gradient direction","mn":"Pseudo/Extrudalizer-0035","ix":35,"v":{"a":0,"k":0,"ix":35}},{"ty":6,"nm":"    ","mn":"Pseudo/Extrudalizer-0036","ix":36,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0037","ix":37,"v":0},{"ty":3,"nm":"Gradient start point","mn":"Pseudo/Extrudalizer-0038","ix":38,"v":{"a":0,"k":[0,0],"ix":38}},{"ty":3,"nm":"Gradient end point","mn":"Pseudo/Extrudalizer-0039","ix":39,"v":{"a":0,"k":[0,0],"ix":39}},{"ty":6,"nm":"Edit gradient start/end points o","mn":"Pseudo/Extrudalizer-0040","ix":40,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0041","ix":41,"v":0},{"ty":6,"nm":"at 3D rotation set to [0,0,0]","mn":"Pseudo/Extrudalizer-0042","ix":42,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0043","ix":43,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0044","ix":44,"v":0},{"ty":6,"nm":"Sides","mn":"Pseudo/Extrudalizer-0045","ix":45,"v":0},{"ty":2,"nm":"Sides color","mn":"Pseudo/Extrudalizer-0046","ix":46,"v":{"a":0,"k":[0,1,1,1],"ix":46}},{"ty":0,"nm":"Sides opacity","mn":"Pseudo/Extrudalizer-0047","ix":47,"v":{"a":0,"k":100,"ix":47}},{"ty":0,"nm":"Sides gradient opacity","mn":"Pseudo/Extrudalizer-0048","ix":48,"v":{"a":0,"k":25,"ix":48}},{"ty":0,"nm":"Sides gradient direction","mn":"Pseudo/Extrudalizer-0049","ix":49,"v":{"a":0,"k":0,"ix":49}},{"ty":0,"nm":"Sides gradient length","mn":"Pseudo/Extrudalizer-0050","ix":50,"v":{"a":0,"k":0,"ix":50}},{"ty":2,"nm":"Sides fill shadow color","mn":"Pseudo/Extrudalizer-0051","ix":51,"v":{"a":0,"k":[0,0,0,1],"ix":51}},{"ty":0,"nm":"Sides fill shadow opacity","mn":"Pseudo/Extrudalizer-0052","ix":52,"v":{"a":0,"k":50,"ix":52}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0053","ix":53,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0054","ix":54,"v":0},{"ty":6,"nm":"Parenting Data","mn":"Pseudo/Extrudalizer-0055","ix":55,"v":0},{"ty":0,"nm":"Front opacity readout","mn":"Pseudo/Extrudalizer-0056","ix":56,"v":{"a":0,"k":100,"ix":56,"x":"var $bm_rt;\ntry {\n    $bm_rt = content('--- EXTRUDALIZER ---').content('FRONT').transform.opacity;\n} catch (e) {\n    $bm_rt = 0;\n}"}},{"ty":0,"nm":"Back opacity readout","mn":"Pseudo/Extrudalizer-0057","ix":57,"v":{"a":0,"k":100,"ix":57,"x":"var $bm_rt;\ntry {\n    $bm_rt = content('--- EXTRUDALIZER ---').content('BACK').transform.opacity;\n} catch (e) {\n    $bm_rt = 0;\n}"}},{"ty":7,"nm":"Compute 3D front bounding box","mn":"Pseudo/Extrudalizer-0058","ix":58,"v":{"a":0,"k":1,"ix":58}},{"ty":3,"nm":"Front upper left","mn":"Pseudo/Extrudalizer-0059","ix":59,"v":{"a":0,"k":[0,0],"ix":59,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[0];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[0],\n            front_bb[1]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front upper right","mn":"Pseudo/Extrudalizer-0060","ix":60,"v":{"a":0,"k":[0,0],"ix":60,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[1];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[2],\n            front_bb[3]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front lower left","mn":"Pseudo/Extrudalizer-0061","ix":61,"v":{"a":0,"k":[0,0],"ix":61,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[2];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[4],\n            front_bb[5]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front lower right","mn":"Pseudo/Extrudalizer-0062","ix":62,"v":{"a":0,"k":[0,0],"ix":62,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[3];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[6],\n            front_bb[7]\n        ];\n    }\n}"}},{"ty":7,"nm":"Compute 3D back bounding box","mn":"Pseudo/Extrudalizer-0063","ix":63,"v":{"a":0,"k":1,"ix":63}},{"ty":3,"nm":"Back upper left","mn":"Pseudo/Extrudalizer-0064","ix":64,"v":{"a":0,"k":[0,0],"ix":64,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[0];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[0],\n            back_bb[1]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back upper right","mn":"Pseudo/Extrudalizer-0065","ix":65,"v":{"a":0,"k":[0,0],"ix":65,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[1];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[2],\n            back_bb[3]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back lower left","mn":"Pseudo/Extrudalizer-0066","ix":66,"v":{"a":0,"k":[0,0],"ix":66,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[2];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[4],\n            back_bb[5]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back lower right","mn":"Pseudo/Extrudalizer-0067","ix":67,"v":{"a":0,"k":[0,0],"ix":67,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[3];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[6],\n            back_bb[7]\n        ];\n    }\n}"}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0068","ix":68,"v":0}]},{"ty":5,"nm":"FACE 0","np":3,"mn":"ADBE Color Control","ix":2,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.945098042488,0.919524788857,0.774609744549,1],"ix":1}}]},{"ty":5,"nm":"FACE 1","np":3,"mn":"ADBE Color Control","ix":3,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.996078431606,0.984313726425,0.917647063732,1],"ix":1}}]},{"ty":5,"nm":"FACE 2","np":3,"mn":"ADBE Color Control","ix":4,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.945098042488,0.919524788857,0.774609744549,1],"ix":1}}]},{"ty":5,"nm":"FACE 3","np":3,"mn":"ADBE Color Control","ix":5,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.996078431606,0.984313726425,0.917647063732,1],"ix":1}}]}],"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[150,-150],[150,150],[-150,150],[-150,-150]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":true},{"ty":"st","c":{"a":0,"k":[0,0.925924921971,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":78,"ix":5},"lc":2,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"ORIGIN SHAPE","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nlet extr_data_arr;\nlet points_3D = [];\nlet isPathClosed;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_3D = extr_data_arr[5];\n    isPathClosed = extr_data_arr[4] === true;\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let points_arr = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    isPathClosed = extr_data_arr[4] === 'true';\n    for (var i = 0, il = points_arr.length / 3; i < il; i++) {\n        points_3D.push(points_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst points_2D = points_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst num_pts = points_2D.length;\nconst zeroArr = Array(num_pts).fill([\n    0,\n    0\n]);\n$bm_rt = createPath(points_2D, zeroArr, zeroArr, isPathClosed);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Front color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":2,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Front color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nlet extr_data_arr;\nlet is_facing_towards_us;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    is_facing_towards_us = extr_data_arr[8] === true;\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    is_facing_towards_us = extr_data_arr[8] === 'true';\n}\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = $bm_div(effect('Extrudalizer')('Translucency').value, 2);\nconst opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    if (is_facing_towards_us > 0) {\n        $bm_rt = opacity_value;\n    } else {\n        $bm_rt = transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"FRONT","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nlet extr_data_arr;\nlet points_3D = [];\nlet isPathClosed;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_3D = extr_data_arr[6];\n    isPathClosed = extr_data_arr[4] === true;\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let points_arr = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    isPathClosed = extr_data_arr[4] === 'true';\n    for (var i = 0, il = points_arr.length / 3; i < il; i++) {\n        points_3D.push(points_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst points_2D = points_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst num_pts = points_2D.length;\nconst zeroArr = Array(num_pts).fill([\n    0,\n    0\n]);\n$bm_rt = createPath(points_2D, zeroArr, zeroArr, isPathClosed);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Back color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Back color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    try {\n        const frontOpacity = content('--- EXTRUDALIZER ---').content('FRONT').transform.opacity.value;\n        $bm_rt = value = $bm_sub(100, frontOpacity);\n    } catch (e) {\n        $bm_rt = 100;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"BACK","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 0;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = true ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[0][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[0];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = false ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[0][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[0];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 0 - 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 1;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = true ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[1][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[1];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = false ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[1][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[1];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 1 - 2","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDES","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"--- EXTRUDALIZER ---","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":300,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":8,"ty":5,"nm":"EXTRUDALIZER DATA || square_1","hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[540,540,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"t":{"d":{"k":[{"s":{"s":36,"f":"TrajanPro-Bold","t":"","ca":0,"j":0,"tr":0,"lh":43.2000007629395,"ls":0,"fc":[0.267,0.722,0.765]},"t":0}],"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, arraysEqual, getNormal, get2D_projection, getBoundingBox, getPositionMatrix, getRotationMatrix, getScaleMatrix, getIdentity, translate, rotateX, rotateY, rotateZ, multiplyMatrixVector, multiplyMatrices, multiplyArrayOfMatrices, transformMatrix, make_transform, getPoint, getArea, isClockwise, getCentroid, getCentroidPro, hasNoneZeroValues, angle_between, angle_between_cw, angle_between_cw_te, isStraightLine_w_delta, isFacingTowardsUs, isVectorFacingTowardsUs, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_shape_matrix, get_transforms_from_bb, num_pts, compare_sides, sorted_sides_indices, adjustColorBrightness, lambertShader, stringify;\n'use native operators';\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\narraysEqual = function (arr1, arr2) {\n    for (var i = 0, il = arr1.length; i < il; i++) {\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n};\ngetNormal = function (pts, normalized) {\n    let dir = cross_vec(sub(pts[1], pts[0]), sub(pts[2], pts[0]));\n    let len_dir = len_vec(dir);\n    if (len_dir === 0) {\n        return [\n            0,\n            0,\n            0\n        ];\n    }\n    if (normalized) {\n        return div(dir, len_dir);\n    } else {\n        return dir;\n    }\n};\nget2D_projection = function (points) {\n    return points.map(v => [\n        v[0],\n        v[1]\n    ]);\n};\ngetBoundingBox = function (points) {\n    const boundingBox = {\n        left: Number.POSITIVE_INFINITY,\n        top: Number.POSITIVE_INFINITY,\n        right: Number.NEGATIVE_INFINITY,\n        bottom: Number.NEGATIVE_INFINITY,\n        width: undefined,\n        height: undefined,\n        center: undefined\n    };\n    points.forEach(point => {\n        boundingBox.left = Math.min(boundingBox.left, point[0]);\n        boundingBox.top = Math.min(boundingBox.top, point[1]);\n        boundingBox.right = Math.max(boundingBox.right, point[0]);\n        boundingBox.bottom = Math.max(boundingBox.bottom, point[1]);\n    });\n    boundingBox.width = sub(boundingBox.right, boundingBox.left);\n    boundingBox.height = sub(boundingBox.bottom, boundingBox.top);\n    boundingBox.center = [\n        add(boundingBox.left, $bm_div(boundingBox.width, 2)),\n        add(boundingBox.top, $bm_div(boundingBox.height, 2))\n    ];\n    boundingBox.left_top = [\n        boundingBox.left,\n        boundingBox.top\n    ];\n    boundingBox.left_bottom = [\n        boundingBox.left,\n        boundingBox.bottom\n    ];\n    boundingBox.right_top = [\n        boundingBox.right,\n        boundingBox.top\n    ];\n    boundingBox.right_bottom = [\n        boundingBox.right,\n        boundingBox.bottom\n    ];\n    return boundingBox;\n};\ngetPositionMatrix = function (value) {\n    return translate(getIdentity(), value[0], value[1], $bm_neg(value[2]));\n};\ngetRotationMatrix = function (angles) {\n    const angleX = angles[0];\n    const angleY = angles[1];\n    const angleZ = angles[2];\n    var matrix = getIdentity();\n    matrix = rotateZ(matrix, $bm_div($bm_mul(angleZ, Math.PI), 180));\n    matrix = rotateY(matrix, $bm_div($bm_mul(angleY, Math.PI), 180));\n    matrix = rotateX(matrix, $bm_div($bm_mul(angleX, Math.PI), 180));\n    return matrix;\n};\ngetScaleMatrix = function (sc) {\n    return [\n        sc,\n        0,\n        0,\n        0,\n        0,\n        sc,\n        0,\n        0,\n        0,\n        0,\n        sc,\n        0,\n        0,\n        0,\n        0,\n        1\n    ];\n};\ngetIdentity = function () {\n    return [\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n    ];\n};\ntranslate = function (matrix, x, y, z) {\n    return multiplyMatrices(matrix, [\n        1,\n        0,\n        0,\n        x,\n        0,\n        1,\n        0,\n        y,\n        0,\n        0,\n        1,\n        z,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateX = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        1,\n        0,\n        0,\n        0,\n        0,\n        cos_th,\n        $bm_neg(sin_th),\n        0,\n        0,\n        sin_th,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateY = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        cos_th,\n        0,\n        sin_th,\n        0,\n        0,\n        1,\n        0,\n        0,\n        $bm_neg(sin_th),\n        0,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateZ = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        cos_th,\n        $bm_neg(sin_th),\n        0,\n        0,\n        sin_th,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nmultiplyMatrixVector = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 4; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 4; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 4), j)], vector[j]));\n        }\n    }\n    return result;\n};\nmultiplyMatrices = function (matrixB, matrixA) {\n    let result = new Array(16).fill(0);\n    for (let i = 0; i < 4; i++) {\n        for (let j = 0; j < 4; j++) {\n            for (let k = 0; k < 4; k++) {\n                result[$bm_sum($bm_mul(i, 4), j)] = $bm_sum(result[$bm_sum($bm_mul(i, 4), j)], $bm_mul(matrixA[$bm_sum($bm_mul(i, 4), k)], matrixB[$bm_sum($bm_mul(k, 4), j)]));\n            }\n        }\n    }\n    return result;\n};\nmultiplyArrayOfMatrices = function (matrices) {\n    var result = matrices[0];\n    for (var i = 1, il = matrices.length; i < il; i++) {\n        result = multiplyMatrices(result, matrices[i]);\n    }\n    return result;\n};\ntransformMatrix = function (move, sc, pivot, pitch_angles, anch, orbit_angles) {\n    var mat_array = [];\n    if (sc !== 1) {\n        if (!arraysEqual(pivot, [\n                0,\n                0,\n                0\n            ])) {\n            mat_array = mat_array.concat([\n                getPositionMatrix(pivot.map(i => -i)),\n                getScaleMatrix(sc),\n                getPositionMatrix(pivot)\n            ]);\n        } else {\n            mat_array.push(getScaleMatrix(sc));\n        }\n    }\n    mat_array.push(getPositionMatrix(move));\n    if (!arraysEqual(pitch_angles, [\n            0,\n            0,\n            0\n        ])) {\n        if (!arraysEqual(pivot, [\n                0,\n                0,\n                0\n            ])) {\n            mat_array = mat_array.concat([\n                getPositionMatrix(pivot.map(i => -i)),\n                getRotationMatrix(pitch_angles),\n                getPositionMatrix(pivot)\n            ]);\n        } else {\n            mat_array.push(getRotationMatrix(pitch_angles));\n        }\n    }\n    if (!arraysEqual(anch, [\n            0,\n            0,\n            0\n        ])) {\n        mat_array.push(getPositionMatrix(anch.map(i => -i)));\n    }\n    if (!arraysEqual(orbit_angles, [\n            0,\n            0,\n            0\n        ])) {\n        mat_array.push(getRotationMatrix(orbit_angles));\n    }\n    return multiplyArrayOfMatrices(mat_array);\n};\nmake_transform = function (transform_matrix, vector) {\n    if (vector.length == 2) {\n        vector = [\n            ...vector,\n            0,\n            1\n        ];\n    } else if (vector.length == 3) {\n        vector = [\n            ...vector,\n            1\n        ];\n    }\n    var result_vector_4d = multiplyMatrixVector(transform_matrix, vector);\n    return result_vector_4d.slice(0, 3);\n};\ngetPoint = function (p1, cp1, cp2, p2, t) {\n    const x = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[0]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[0])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[0])), $bm_mul(Math.pow(t, 3), p2[0]));\n    const y = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[1]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[1])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[1])), $bm_mul(Math.pow(t, 3), p2[1]));\n    return [\n        x,\n        y\n    ];\n};\ngetArea = function (points) {\n    var area = 0;\n    for (var i = 0, il = points.length; i < il; i++) {\n        var p1 = points[i];\n        var p2 = points[(i + 1) % il];\n        area = $bm_sum(area, $bm_sub($bm_mul(p1[0], p2[1]), $bm_mul(p2[0], p1[1])));\n    }\n    return $bm_div(area, 2);\n};\nisClockwise = function (points) {\n    return getArea(points) > 0;\n};\ngetCentroid = function (vertices) {\n    var area = getArea(vertices);\n    if (area === 0) {\n        function findCenter(points) {\n            let sumX = 0;\n            let sumY = 0;\n            for (let i = 0, il = points.length; i < il; i++) {\n                const point = points[i];\n                sumX = $bm_sum(sumX, point[0]);\n                sumY = $bm_sum(sumY, point[1]);\n            }\n            const meanX = $bm_div(sumX, points.length);\n            const meanY = $bm_div(sumY, points.length);\n            return [\n                meanX,\n                meanY\n            ];\n        }\n        return findCenter(vertices);\n    }\n    let centroidX = 0;\n    let centroidY = 0;\n    const numVertices = vertices.length;\n    for (var i = 0; i < numVertices; i++) {\n        var currentVertex = vertices[i];\n        var nextVertex = vertices[(i + 1) % numVertices];\n        var commonFactor = $bm_sub($bm_mul(currentVertex[0], nextVertex[1]), $bm_mul(nextVertex[0], currentVertex[1]));\n        centroidX = $bm_sum(centroidX, $bm_mul($bm_sum(currentVertex[0], nextVertex[0]), commonFactor));\n        centroidY = $bm_sum(centroidY, $bm_mul($bm_sum(currentVertex[1], nextVertex[1]), commonFactor));\n    }\n    var scaleFactor = $bm_div(1, $bm_mul(6, area));\n    centroidX *= scaleFactor;\n    centroidY *= scaleFactor;\n    return [\n        centroidX,\n        centroidY\n    ];\n};\ngetCentroidPro = function (vertices) {\n    const bb = getBoundingBox(vertices);\n    return {\n        0: bb.left_top,\n        1: [\n            (bb.left_top[0] + bb.right_top[0]) / 2,\n            bb.left_top[1]\n        ],\n        2: bb.right_top,\n        3: [\n            (bb.left_top[0] + bb.left_bottom[0]) / 2,\n            (bb.left_top[1] + bb.left_bottom[1]) / 2\n        ],\n        4: getCentroid(vertices),\n        5: [\n            (bb.right_top[0] + bb.right_bottom[0]) / 2,\n            (bb.right_top[1] + bb.right_bottom[1]) / 2\n        ],\n        6: bb.left_bottom,\n        7: [\n            (bb.left_bottom[0] + bb.right_bottom[0]) / 2,\n            bb.left_bottom[1]\n        ],\n        8: bb.right_bottom\n    };\n};\nhasNoneZeroValues = function (array2D) {\n    return array2D.some(array => array.some(value => value !== 0));\n};\nangle_between = function (a, b) {\n    const dot_prod = dot_(a, b);\n    const mag_a = len_vec(a);\n    const mag_b = len_vec(b);\n    const cos_ = $bm_div(dot_prod, $bm_mul(mag_a, mag_b));\n    return cos_;\n};\nangle_between_cw = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    angle = angle >= 0 ? angle : $bm_sum($bm_mul(2, Math.PI), angle);\n    const degrees = $bm_mul(angle, $bm_div(180, Math.PI));\n    return degrees;\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nisStraightLine_w_delta = function (cp1, cp2, delta) {\n    return angle_between(cp1, cp2) <= -delta;\n};\nisFacingTowardsUs = function (p1, p2) {\n    return dot_(sub(p2, p1), [\n        0,\n        0,\n        1\n    ]) > 0;\n};\nisVectorFacingTowardsUs = function (v) {\n    return dot_(v, [\n        0,\n        0,\n        -1\n    ]) > 0;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_shape_matrix = function (anchor, pos, scale, rot, skew, skew_axis) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (skew !== 0) {\n        const sk_angle = $bm_div($bm_mul(skew, Math.PI), 180);\n        const Sk = [\n            1,\n            Math.tan(-sk_angle),\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            1\n        ];\n        if (skew_axis !== 0) {\n            const sk_axis_angle = $bm_div($bm_mul(skew_axis, Math.PI), 180);\n            const cos_sk = Math.cos(sk_axis_angle);\n            const sin_sk = Math.sin(sk_axis_angle);\n            const Rz = [\n                cos_sk,\n                -sin_sk,\n                0,\n                sin_sk,\n                cos_sk,\n                0,\n                0,\n                0,\n                1\n            ];\n            const Rz_inv = [\n                cos_sk,\n                sin_sk,\n                0,\n                -sin_sk,\n                cos_sk,\n                0,\n                0,\n                0,\n                1\n            ];\n            const SkM = multiplyArrayOfMatrices3x3([\n                Rz_inv,\n                Sk,\n                Rz\n            ]);\n            mat_array.push(SkM);\n        } else {\n            mat_array.push(Sk);\n        }\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nget_transforms_from_bb = function (bb, extr_transform_matrix, layer_transform_matrix, parent_transform_matrix, is_front, front_facing_towards_us, mode) {\n    let bb_transformed_3D = [];\n    if (front_facing_towards_us) {\n        bb_transformed_3D = [\n            bb.left_top,\n            bb.right_top,\n            bb.left_bottom,\n            bb.right_bottom\n        ];\n    } else {\n        bb_transformed_3D = [\n            bb.right_top,\n            bb.left_top,\n            bb.right_bottom,\n            bb.left_bottom\n        ];\n    }\n    bb_transformed_3D = bb_transformed_3D.map(pnt => make_transform(extr_transform_matrix, pnt));\n    let bb_transformed_2D = get2D_projection(bb_transformed_3D);\n    bb_transformed_2D = bb_transformed_2D.map(p => transform2D_apply(layer_transform_matrix, p));\n    if (parent_transform_matrix) {\n        bb_transformed_2D = bb_transformed_2D.map(p => transform2D_apply(parent_transform_matrix, p));\n    }\n    const ex_left_top = bb_transformed_2D[0], ex_right_top = bb_transformed_2D[1], ex_left_bottom = bb_transformed_2D[2], ex_right_bottom = bb_transformed_2D[3];\n    let transform_effect_controls = [];\n    if (mode & 1) {\n        const bb_pos = ex_left_top;\n        const ex_AD = sub(ex_left_bottom, ex_left_top);\n        const rot = angle_between_cw_te(ex_AD, [\n            0,\n            1\n        ]);\n        const ex_AB = sub(ex_right_top, ex_left_top);\n        const rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\n        const x_rot = [\n            Math.cos(rot_rad),\n            Math.sin(rot_rad)\n        ];\n        let skw = angle_between_cw_te(ex_AB, x_rot);\n        if (!front_facing_towards_us) {\n            skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n            skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n        }\n        ;\n        let extra_skew_arr = [];\n        if (Math.abs(skw) > 70) {\n            const max_count = 7;\n            let count = 1;\n            let skew_ = Math.abs(skw);\n            const tan_70 = Math.tan(degreesToRadians(70));\n            while (skew_ > 70 && count < max_count) {\n                skew_ = radiansToDegrees(Math.atan($bm_sub(Math.tan(degreesToRadians(skew_)), tan_70)));\n                extra_skew_arr.push(skw > 0 ? skew_ : -skew_);\n                count++;\n            }\n        }\n        const scaleY = $bm_mul(100, len_vec(ex_AD));\n        const angle_AB_AD = angle_between_cw_te(ex_AD, ex_AB);\n        const beta = $bm_sub($bm_sub(180, angle_AB_AD), skw);\n        const scaleX_coeff = $bm_div(Math.sin($bm_div($bm_mul(beta, Math.PI), 180)), Math.sin($bm_div($bm_mul(angle_AB_AD, Math.PI), 180)));\n        let scaleX = $bm_div($bm_mul(100, len_vec(ex_AB)), scaleX_coeff);\n        if (!front_facing_towards_us) {\n            scaleX = $bm_neg(scaleX);\n        }\n        transform_effect_controls = [\n            bb_pos,\n            rot,\n            skw,\n            scaleY,\n            scaleX,\n            extra_skew_arr\n        ];\n    }\n    let transform_layer_controls = [];\n    if (mode & 2) {\n        const tl_AB = sub(bb.right_top, bb.left_top);\n        const tl_AD = sub(bb.left_bottom, bb.left_top);\n        const tl_scaleX_coeff = 100;\n        const tl_scaleY_coeff = 100;\n        const tl_bb_anchor = bb.left_top;\n        let tl_bb_pos = ex_left_top;\n        const tl_ex_AB = sub(ex_right_top, ex_left_top);\n        let tl_bb_theta = angle_between_cw(tl_AB, tl_ex_AB);\n        let tl_bb_scx = $bm_div($bm_mul(tl_scaleX_coeff, len_vec(tl_ex_AB)), len_vec(tl_AB));\n        const tl_ex_AD = sub(ex_left_bottom, ex_left_top);\n        const tl_bb_th_rad = $bm_mul(tl_bb_theta, $bm_div(Math.PI, 180));\n        const tl_cos_th = Math.cos(tl_bb_th_rad);\n        const tl_sin_th = Math.sin(tl_bb_th_rad);\n        const tl_AD_rot = [\n            tl_AD[0] * tl_cos_th - tl_AD[1] * tl_sin_th,\n            tl_AD[0] * tl_sin_th + tl_AD[1] * tl_cos_th\n        ];\n        let tl_skew = angle_between_cw(tl_AD_rot, tl_ex_AD);\n        tl_skew = tl_skew < 90 ? tl_skew : $bm_sub(tl_skew, 360);\n        const tl_sk_rad = $bm_div($bm_mul(tl_skew, Math.PI), 180);\n        const tl_AD_skew = [\n            tl_AD[0] + Math.tan(-tl_sk_rad) * tl_AD[1],\n            tl_AD[1]\n        ];\n        const tl_bb_scy = $bm_div($bm_mul(tl_scaleY_coeff, len_vec(tl_ex_AD)), len_vec(tl_AD_skew));\n        if (front_facing_towards_us && !is_front || !front_facing_towards_us && is_front) {\n            tl_bb_scx = $bm_neg(tl_bb_scx);\n            tl_bb_pos = $bm_sum(tl_bb_pos, tl_ex_AB);\n        }\n        transform_layer_controls = [\n            tl_bb_anchor[0],\n            tl_bb_anchor[1],\n            tl_bb_pos[0],\n            tl_bb_pos[1],\n            tl_bb_theta,\n            tl_bb_scx,\n            tl_bb_scy,\n            tl_skew\n        ];\n    }\n    return {\n        'boundingBoxTransformed': bb_transformed_2D,\n        'transformEffectControls': transform_effect_controls,\n        'transformLayerControls': transform_layer_controls\n    };\n};\nconst shape_layer = thisComp.layer('square_1');\nconst shape = shape_layer(2)(1);\nconst shape_contents = shape(2);\nconst targetPath = shape_contents(1)(2);\nconst is_path_closed = targetPath.isClosed();\nconst extrudalizer = shape_layer('ADBE Effect Parade')('Pseudo/Extrudalizer');\nconst depth = extrudalizer('Extrusion depth').value;\nlet anchor = extrudalizer('Position').value;\nanchor = [\n    $bm_neg(anchor[0]),\n    anchor[1],\n    anchor[2]\n];\nconst angleX = extrudalizer('X Rotation').value;\nconst angleY = extrudalizer('Y Rotation').value;\nconst angleZ = extrudalizer('Z Rotation').value;\nconst pivot_angleX = extrudalizer('Pitch (x)').value;\nconst pivot_angleY = extrudalizer('Yaw (y)').value;\nconst pivot_angleZ = extrudalizer('Roll (z)').value;\nconst scale_front = $bm_div(extrudalizer('Front scale').value, 100);\nconst scale_back = $bm_div(extrudalizer('Back scale').value, 100);\nconst use_bb_front = extrudalizer('Compute 3D front bounding box').value;\nconst use_bb_back = extrudalizer('Compute 3D back bounding box').value;\nlet pnts = targetPath.points();\nlet inTangents = targetPath.inTangents();\nlet outTangents = targetPath.outTangents();\nconst is_front_clockwise = isClockwise(pnts);\nconst shape_transform = shape.transform;\nconst s_anchor = shape_transform.anchorPoint;\nconst s_pos = shape_transform.position;\nconst s_scale = shape_transform.scale;\nconst s_rot = shape_transform.rotation;\nconst s_skew = shape_transform.skew;\nconst s_skew_axis = shape_transform.skewAxis;\nconst shape_transform_matrix = get_transform_shape_matrix(s_anchor, s_pos, s_scale, s_rot, s_skew, s_skew_axis);\nconst layer_transform = shape_layer.transform;\nconst l_anchor = layer_transform.anchorPoint;\nconst l_pos = layer_transform.position;\nconst l_scale = layer_transform.scale;\nconst l_rot = layer_transform.rotation;\nconst layer_transform_matrix = get_transform_shape_matrix(l_anchor, l_pos, l_scale, l_rot, 0, 0);\nlet subdivs = 1;\nlet num_pnts = pnts.length;\nif (hasNoneZeroValues(inTangents) || hasNoneZeroValues(outTangents)) {\n    subdivs = 5;\n    let pointsF = [];\n    for (var i = 0; i < num_pnts; i++) {\n        pointsF.push(pnts[i]);\n        if (!is_path_closed && i == num_pnts - 1) {\n            break;\n        }\n        var p1 = pnts[i], p2 = pnts[(i + 1) % num_pnts];\n        var out1 = outTangents[i], in2 = inTangents[(i + 1) % num_pnts];\n        var cp1 = add(p1, out1), cp2 = add(p2, in2);\n        var len_out1 = len_vec(out1), len_in2 = len_vec(in2);\n        var len_p1p2 = len_vec(sub(p2, p1));\n        if (len_out1 !== 0 || len_in2 !== 0) {\n            var a = len_out1 === 0 ? sub(p2, p1) : out1;\n            var b = len_in2 === 0 ? sub(p1, p2) : in2;\n            if (!isStraightLine_w_delta(a, b, 0.999) && (len_out1 > len_p1p2 * 0.02 || len_in2 > len_p1p2 * 0.02)) {\n                for (var j = 1; j < subdivs; j++) {\n                    var t = $bm_div(j, subdivs);\n                    pointsF.push(getPoint(p1, cp1, cp2, p2, t));\n                }\n            }\n        }\n    }\n    pnts = pointsF;\n}\npnts = pnts.map(p => transform2D_apply(shape_transform_matrix, p));\nnum_pts = pnts.length;\nconst zero_center_point = getCentroidPro(pnts)[4];\nlet z_coord = 0;\nswitch (1) {\ncase 0:\n    z_coord = $bm_div($bm_neg(depth), 2);\n    break;\ncase 1:\n    z_coord = 0;\n    break;\ncase 2:\n    z_coord = $bm_div(depth, 2);\n    break;\n}\n;\nconst zero_center_point_3D = [\n    ...zero_center_point,\n    z_coord\n];\nconst pivot_matrix = transformMatrix([\n    0,\n    0,\n    z_coord\n], 1, [\n    0,\n    0,\n    0\n], [\n    0,\n    0,\n    0\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst pivot_position = make_transform(pivot_matrix, zero_center_point);\nconst tr_front_mat = transformMatrix([\n    0,\n    0,\n    $bm_div($bm_neg(depth), 2)\n], scale_front, zero_center_point_3D, [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst tr_back_mat = transformMatrix([\n    0,\n    0,\n    $bm_div(depth, 2)\n], scale_back, zero_center_point_3D, [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst rot_matrix = transformMatrix([\n    0,\n    0,\n    0\n], 1, [\n    0,\n    0,\n    0\n], [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], [\n    0,\n    0,\n    0\n], [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst z1_transformed = make_transform(rot_matrix, [\n    0,\n    0,\n    -1\n]);\nconst front_facing_towards_us = isVectorFacingTowardsUs(z1_transformed);\nlet points_front_3D = pnts.map(pnt => make_transform(tr_front_mat, pnt));\nlet points_back_3D = pnts.map(pnt => make_transform(tr_back_mat, pnt));\nlet winding_sides = [];\nlet sorted_sides = [];\nlet sorted_side_colors = [];\nlet num_sides_towards_us = 0;\nfor (var i = 0; i < num_pts; i++) {\n    if (!is_path_closed && i == num_pts - 1) {\n        break;\n    }\n    var F1 = points_front_3D[i], F2 = points_front_3D[(i + 1) % num_pts];\n    var B1 = points_back_3D[i], B2 = points_back_3D[(i + 1) % num_pts];\n    let abs_side_normal = getNormal([\n        F2,\n        F1,\n        B1\n    ], true);\n    let real_side_normal = !is_front_clockwise ? mul(abs_side_normal, -1) : abs_side_normal;\n    const sideIsFacingUs = isFacingTowardsUs([\n        0,\n        0,\n        0\n    ], real_side_normal);\n    if (sideIsFacingUs) {\n        num_sides_towards_us++;\n    }\n    winding_sides.push(sideIsFacingUs);\n    let side_sorted = [\n        F2,\n        F1,\n        B1,\n        B2\n    ];\n    side_sorted.sort((a, b) => b[2] - a[2]);\n    sorted_sides.push([\n        side_sorted,\n        i,\n        $bm_mod($bm_sum(i, 1), num_pts),\n        abs_side_normal\n    ]);\n}\ncompare_sides = function (side1, side2) {\n    const s1_vertices_z = side1[0].map(v => v[2]), s2_vertices_z = side2[0].map(v => v[2]);\n    for (var i = 0, il = side1[0].length; i < il; i++) {\n        if (s1_vertices_z[i] != s2_vertices_z[i]) {\n            return $bm_sub(s2_vertices_z[i], s1_vertices_z[i]);\n        }\n    }\n};\nsorted_sides.sort((a, b) => compare_sides(a, b));\nsorted_sides.sort(function (a, b) {\n    const fa = winding_sides[a[1]], fb = winding_sides[b[1]];\n    if (fa && !fb) {\n        return -1;\n    } else if (!fa && fb) {\n        return 1;\n    } else {\n        return 0;\n    }\n});\nsorted_sides_indices = sorted_sides.map(p => [\n    p[1],\n    p[2]\n]);\nif (true) {\n    const lambert_max = extrudalizer('Sides fill shadow opacity').value;\n    const rgba = extrudalizer('Sides color').value;\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    lambertShader = function (normal, max_value, multiplier) {\n        return $bm_div($bm_mul($bm_mul(multiplier, $bm_sub(100, max_value)), Math.abs(dot_(normal, [\n            0,\n            0,\n            1\n        ]))), 100);\n    };\n    sorted_side_colors = sorted_sides.map(p => adjustColorBrightness(rgba, lambertShader(p[3], lambert_max, 2)));\n}\nconst front_normal = div(z1_transformed, len_vec(z1_transformed));\nlet bb_front_2D = [], bb_back_2D = [], bb_front_transforms_te = [], bb_back_transforms_te = [], bb_front_transforms_tl = [], bb_back_transforms_tl = [];\nif (use_bb_back || use_bb_front) {\n    const bb = getBoundingBox(pnts);\n    let hasParent = shape_layer.hasParent;\n    let parent_transform_matrix = null;\n    if (hasParent) {\n        let p_pos = shape_layer.parent.transform.position;\n        let p_anchor = shape_layer.parent.transform.anchorPoint;\n        let p_rot = shape_layer.parent.transform.rotation;\n        let p_sca = shape_layer.parent.transform.scale;\n        parent_transform_matrix = get_transform_shape_matrix(p_anchor, p_pos, p_sca, p_rot, 0, 0);\n    }\n    if (use_bb_front) {\n        const bb_front_data = get_transforms_from_bb(bb, tr_front_mat, layer_transform_matrix, parent_transform_matrix, true, front_facing_towards_us, 3);\n        bb_front_2D = bb_front_data['boundingBoxTransformed'];\n        bb_front_transforms_te = bb_front_data['transformEffectControls'];\n        bb_front_transforms_tl = bb_front_data['transformLayerControls'];\n    }\n    if (use_bb_back) {\n        const bb_back_data = get_transforms_from_bb(bb, tr_back_mat, layer_transform_matrix, parent_transform_matrix, false, front_facing_towards_us, 3);\n        bb_back_2D = bb_back_data['boundingBoxTransformed'];\n        bb_back_transforms_te = bb_back_data['transformEffectControls'];\n        bb_back_transforms_tl = bb_back_data['transformLayerControls'];\n    }\n}\nlet grad_property = null;\ntry {\n    grad_property = shape_contents('ADBE Vector Graphic - G-Fill');\n} catch (e) {\n}\nlet grad_start_front_new = [\n    0,\n    0\n];\nlet grad_end_front_new = [\n    0,\n    0\n];\nlet grad_start_back_new = [\n    0,\n    0\n];\nlet grad_end_back_new = [\n    0,\n    0\n];\nif (grad_property != null) {\n    let grad_start = grad_property.startPoint.value;\n    let grad_end = grad_property.endPoint.value;\n    grad_start = transform2D_apply(shape_transform_matrix, grad_start);\n    grad_end = transform2D_apply(shape_transform_matrix, grad_end);\n    const grad_start_front = make_transform(tr_front_mat, grad_start);\n    const grad_end_front = make_transform(tr_front_mat, grad_end);\n    const grad_start_back = make_transform(tr_back_mat, grad_start);\n    const grad_end_back = make_transform(tr_back_mat, grad_end);\n    grad_start_front_new = grad_start_front;\n    grad_end_front_new = grad_end_front;\n    grad_start_back_new = grad_start_back;\n    grad_end_back_new = grad_end_back;\n    const grad_front_rot = $bm_div($bm_mul(extrudalizer('Front gradient direction').value, Math.PI), 180);\n    const grad_back_rot = $bm_div($bm_mul(extrudalizer('Back gradient direction').value, Math.PI), 180);\n    if (!arraysEqual([\n            grad_front_rot,\n            grad_back_rot\n        ], [\n            0,\n            0\n        ])) {\n        const grad_origin_front = div(add(grad_end_front, grad_start_front), 2);\n        const grad_origin_back = div(add(grad_end_back, grad_start_back), 2);\n        const grad_p_st_front = sub(grad_start_front, grad_origin_front);\n        const grad_p_end_front = sub(grad_end_front, grad_origin_front);\n        const grad_p_st_back = sub(grad_start_back, grad_origin_back);\n        const grad_p_end_back = sub(grad_end_back, grad_origin_back);\n        if (grad_front_rot != 0) {\n            const cos_st = Math.cos(grad_front_rot), sin_st = Math.sin(grad_front_rot);\n            grad_start_front_new[0] = $bm_sum($bm_sub($bm_mul(cos_st, grad_p_st_front[0]), $bm_mul(sin_st, grad_p_st_front[1])), grad_origin_front[0]);\n            grad_start_front_new[1] = $bm_sum($bm_sum($bm_mul(sin_st, grad_p_st_front[0]), $bm_mul(cos_st, grad_p_st_front[1])), grad_origin_front[1]);\n            grad_end_front_new[0] = $bm_sum($bm_sub($bm_mul(cos_st, grad_p_end_front[0]), $bm_mul(sin_st, grad_p_end_front[1])), grad_origin_front[0]);\n            grad_end_front_new[1] = $bm_sum($bm_sum($bm_mul(sin_st, grad_p_end_front[0]), $bm_mul(cos_st, grad_p_end_front[1])), grad_origin_front[1]);\n        }\n        if (grad_back_rot != 0) {\n            const cos_st_b = Math.cos(grad_back_rot), sin_st_b = Math.sin(grad_back_rot);\n            grad_start_back_new[0] = $bm_sum($bm_sub($bm_mul(cos_st_b, grad_p_st_back[0]), $bm_mul(sin_st_b, grad_p_st_back[1])), grad_origin_back[0]);\n            grad_start_back_new[1] = $bm_sum($bm_sum($bm_mul(sin_st_b, grad_p_st_back[0]), $bm_mul(cos_st_b, grad_p_st_back[1])), grad_origin_back[1]);\n            grad_end_back_new[0] = $bm_sum($bm_sub($bm_mul(cos_st_b, grad_p_end_back[0]), $bm_mul(sin_st_b, grad_p_end_back[1])), grad_origin_back[0]);\n            grad_end_back_new[1] = $bm_sum($bm_sum($bm_mul(sin_st_b, grad_p_end_back[0]), $bm_mul(cos_st_b, grad_p_end_back[1])), grad_origin_back[1]);\n        }\n    }\n}\nconst extr_data = [\n    tr_front_mat,\n    tr_back_mat,\n    shape_transform_matrix,\n    subdivs,\n    is_path_closed,\n    points_front_3D,\n    points_back_3D,\n    sorted_sides_indices,\n    front_facing_towards_us,\n    is_front_clockwise,\n    num_sides_towards_us,\n    sorted_side_colors,\n    pivot_position,\n    front_normal,\n    bb_front_2D,\n    bb_back_2D,\n    bb_front_transforms_te,\n    bb_back_transforms_te,\n    bb_front_transforms_tl,\n    bb_back_transforms_tl,\n    grad_start_front_new,\n    grad_end_front_new,\n    grad_start_back_new,\n    grad_end_back_new\n];\nvar txt = '';\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'] = extr_data;\n} catch (err) {\n    stringify = function (data, separator) {\n        return data.map(item => Array.isArray(item) ? item.join(',') : item.toString()).join(separator);\n    };\n    txt = stringify(extr_data, ';');\n}\n$bm_rt = txt;"},"p":{},"m":{"g":1,"a":{"a":0,"k":[0,0],"ix":2}},"a":[]},"ip":0,"op":300,"st":0,"ct":1,"bm":0}]},{"id":"comp_11","nm":"Slap_Face","fr":30,"layers":[{"ddd":0,"ind":1,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [3]","refId":"comp_1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [2]","refId":"comp_2","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":3,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [1]","refId":"comp_3","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":4,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [0]","refId":"comp_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":5,"ty":0,"nm":"MAP || Dice || square_1 || BACK","refId":"comp_5","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('square_1').effect('Extrudalizer')('Back opacity readout');"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[150,150],"ix":1,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst is_front = false;\nconst precomp_width = 300;\nlet extr_data_arr = [];\nlet is_facing_us = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    $bm_rt = is_facing_us = extr_data_arr[8];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    $bm_rt = is_facing_us = extr_data_arr[8] == 'true';\n}\nfunction logicalXOR(input1, input2) {\n    return input1 && !input2 || !input1 && input2;\n}\nif (logicalXOR(is_front, is_facing_us)) {\n    $bm_rt = value = [\n        precomp_width,\n        0\n    ];\n} else {\n    $bm_rt = value = [\n        0,\n        0\n    ];\n}"}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst POS_INDEX_LOTTIE = 0;\nconst POS_INDEX_1 = 0;\nconst POS_INDEX_2 = 1;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let pos = [\n        0,\n        0\n    ];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        $bm_rt = pos = transform_effect_controls[POS_INDEX_LOTTIE];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        $bm_rt = pos = [\n            transform_effect_controls[POS_INDEX_1],\n            transform_effect_controls[POS_INDEX_2]\n        ];\n    }\n}"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 3;\nconst control_index_ae = 4;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.height;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 4;\nconst control_index_ae = 5;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = $bm_neg(thisLayer.width);\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 2;\nconst control_index_ae = 3;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 1;\nconst control_index_ae = 2;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'Back';\nconst face_opacity = ex_layer.effect('Extrudalizer')(face + ' opacity readout').value;\n$bm_rt = face_opacity;"}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":6,"ty":0,"nm":"MAP || Dice || square_1 || FRONT","refId":"comp_6","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('square_1').effect('Extrudalizer')('Front opacity readout');"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[150,150],"ix":1,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst is_front = true;\nconst precomp_width = 300;\nlet extr_data_arr = [];\nlet is_facing_us = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    $bm_rt = is_facing_us = extr_data_arr[8];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    $bm_rt = is_facing_us = extr_data_arr[8] == 'true';\n}\nfunction logicalXOR(input1, input2) {\n    return input1 && !input2 || !input1 && input2;\n}\nif (logicalXOR(is_front, is_facing_us)) {\n    $bm_rt = value = [\n        precomp_width,\n        0\n    ];\n} else {\n    $bm_rt = value = [\n        0,\n        0\n    ];\n}"}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst POS_INDEX_LOTTIE = 0;\nconst POS_INDEX_1 = 0;\nconst POS_INDEX_2 = 1;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let pos = [\n        0,\n        0\n    ];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        $bm_rt = pos = transform_effect_controls[POS_INDEX_LOTTIE];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        $bm_rt = pos = [\n            transform_effect_controls[POS_INDEX_1],\n            transform_effect_controls[POS_INDEX_2]\n        ];\n    }\n}"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 3;\nconst control_index_ae = 4;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.height;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 4;\nconst control_index_ae = 5;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.width;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 2;\nconst control_index_ae = 3;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 1;\nconst control_index_ae = 2;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'Front';\nconst face_opacity = ex_layer.effect('Extrudalizer')(face + ' opacity readout').value;\n$bm_rt = face_opacity;"}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":7,"ty":4,"nm":"square_1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[540,540,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":1,"k":[{"i":{"x":[0.667,0.667,0.667],"y":[1,1,1]},"o":{"x":[0.333,0.333,0.333],"y":[0,0,0]},"t":60,"s":[100,100,100]},{"t":90,"s":[180,180,100]}],"ix":6,"l":2}},"ao":0,"ef":[{"ty":5,"nm":"Extrudalizer","np":70,"mn":"Pseudo/Extrudalizer","ix":1,"en":1,"ef":[{"ty":6,"nm":"3D Transform","mn":"Pseudo/Extrudalizer-0001","ix":1,"v":0},{"ty":0,"nm":"Extrusion depth","mn":"Pseudo/Extrudalizer-0002","ix":2,"v":{"a":0,"k":300,"ix":2}},{"ty":3,"nm":"Position","mn":"Pseudo/Extrudalizer-0003","ix":3,"v":{"a":0,"k":[0,0,0],"ix":3}},{"ty":6,"nm":"Scale","mn":"Pseudo/Extrudalizer-0004","ix":4,"v":0},{"ty":0,"nm":"Front scale","mn":"Pseudo/Extrudalizer-0005","ix":5,"v":{"a":0,"k":100,"ix":5}},{"ty":0,"nm":"Back scale","mn":"Pseudo/Extrudalizer-0006","ix":6,"v":{"a":0,"k":100,"ix":6}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0007","ix":7,"v":0},{"ty":6,"nm":"Pitch/Roll/Yaw","mn":"Pseudo/Extrudalizer-0008","ix":8,"v":0},{"ty":0,"nm":"Pitch (x)","mn":"Pseudo/Extrudalizer-0009","ix":9,"v":{"a":1,"k":[{"i":{"x":[0.401],"y":[1]},"o":{"x":[0.333],"y":[0]},"t":0,"s":[-30]},{"t":60,"s":[-180]}],"ix":9}},{"ty":0,"nm":"Yaw (y)","mn":"Pseudo/Extrudalizer-0010","ix":10,"v":{"a":1,"k":[{"i":{"x":[0.401],"y":[1]},"o":{"x":[0.333],"y":[0]},"t":0,"s":[30]},{"t":60,"s":[810]}],"ix":10}},{"ty":0,"nm":"Roll (z)","mn":"Pseudo/Extrudalizer-0011","ix":11,"v":{"a":1,"k":[{"i":{"x":[0.401],"y":[1]},"o":{"x":[0.333],"y":[0]},"t":0,"s":[0]},{"t":60,"s":[-360]}],"ix":11}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0012","ix":12,"v":0},{"ty":6,"nm":"Orbit control","mn":"Pseudo/Extrudalizer-0013","ix":13,"v":0},{"ty":0,"nm":"X Rotation","mn":"Pseudo/Extrudalizer-0014","ix":14,"v":{"a":0,"k":0,"ix":14}},{"ty":0,"nm":"Y Rotation","mn":"Pseudo/Extrudalizer-0015","ix":15,"v":{"a":0,"k":0,"ix":15}},{"ty":0,"nm":"Z Rotation","mn":"Pseudo/Extrudalizer-0016","ix":16,"v":{"a":0,"k":0,"ix":16}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0017","ix":17,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0018","ix":18,"v":0},{"ty":6,"nm":"Appearance","mn":"Pseudo/Extrudalizer-0019","ix":19,"v":0},{"ty":7,"nm":"Hide anchor point","mn":"Pseudo/Extrudalizer-0020","ix":20,"v":{"a":0,"k":1,"ix":20}},{"ty":7,"nm":"Wireframe mode","mn":"Pseudo/Extrudalizer-0021","ix":21,"v":{"a":0,"k":0,"ix":21}},{"ty":2,"nm":"Edge stroke color","mn":"Pseudo/Extrudalizer-0022","ix":22,"v":{"a":0,"k":[0.996078491211,0.98431378603,0.917647123337,1],"ix":22}},{"ty":0,"nm":"Edge stroke width","mn":"Pseudo/Extrudalizer-0023","ix":23,"v":{"a":0,"k":0,"ix":23}},{"ty":0,"nm":"Translucency","mn":"Pseudo/Extrudalizer-0024","ix":24,"v":{"a":0,"k":0,"ix":24}},{"ty":6,"nm":"Front & Back ","mn":"Pseudo/Extrudalizer-0025","ix":25,"v":0},{"ty":2,"nm":"Front color","mn":"Pseudo/Extrudalizer-0026","ix":26,"v":{"a":0,"k":[0.996078491211,0.98431378603,0.917647123337,1],"ix":26}},{"ty":0,"nm":"Front opacity","mn":"Pseudo/Extrudalizer-0027","ix":27,"v":{"a":0,"k":100,"ix":27}},{"ty":0,"nm":"Front gradient opacity","mn":"Pseudo/Extrudalizer-0028","ix":28,"v":{"a":0,"k":0,"ix":28}},{"ty":0,"nm":"Front gradient direction","mn":"Pseudo/Extrudalizer-0029","ix":29,"v":{"a":0,"k":0,"ix":29}},{"ty":6,"nm":"   ","mn":"Pseudo/Extrudalizer-0030","ix":30,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0031","ix":31,"v":0},{"ty":2,"nm":"Back color","mn":"Pseudo/Extrudalizer-0032","ix":32,"v":{"a":0,"k":[0.945098102093,0.917647123337,0.776470661163,1],"ix":32}},{"ty":0,"nm":"Back opacity","mn":"Pseudo/Extrudalizer-0033","ix":33,"v":{"a":0,"k":100,"ix":33}},{"ty":0,"nm":"Back gradient opacity","mn":"Pseudo/Extrudalizer-0034","ix":34,"v":{"a":0,"k":0,"ix":34}},{"ty":0,"nm":"Back gradient direction","mn":"Pseudo/Extrudalizer-0035","ix":35,"v":{"a":0,"k":0,"ix":35}},{"ty":6,"nm":"    ","mn":"Pseudo/Extrudalizer-0036","ix":36,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0037","ix":37,"v":0},{"ty":3,"nm":"Gradient start point","mn":"Pseudo/Extrudalizer-0038","ix":38,"v":{"a":0,"k":[0,0],"ix":38}},{"ty":3,"nm":"Gradient end point","mn":"Pseudo/Extrudalizer-0039","ix":39,"v":{"a":0,"k":[0,0],"ix":39}},{"ty":6,"nm":"Edit gradient start/end points o","mn":"Pseudo/Extrudalizer-0040","ix":40,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0041","ix":41,"v":0},{"ty":6,"nm":"at 3D rotation set to [0,0,0]","mn":"Pseudo/Extrudalizer-0042","ix":42,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0043","ix":43,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0044","ix":44,"v":0},{"ty":6,"nm":"Sides","mn":"Pseudo/Extrudalizer-0045","ix":45,"v":0},{"ty":2,"nm":"Sides color","mn":"Pseudo/Extrudalizer-0046","ix":46,"v":{"a":0,"k":[0,1,1,1],"ix":46}},{"ty":0,"nm":"Sides opacity","mn":"Pseudo/Extrudalizer-0047","ix":47,"v":{"a":0,"k":100,"ix":47}},{"ty":0,"nm":"Sides gradient opacity","mn":"Pseudo/Extrudalizer-0048","ix":48,"v":{"a":0,"k":25,"ix":48}},{"ty":0,"nm":"Sides gradient direction","mn":"Pseudo/Extrudalizer-0049","ix":49,"v":{"a":0,"k":0,"ix":49}},{"ty":0,"nm":"Sides gradient length","mn":"Pseudo/Extrudalizer-0050","ix":50,"v":{"a":0,"k":0,"ix":50}},{"ty":2,"nm":"Sides fill shadow color","mn":"Pseudo/Extrudalizer-0051","ix":51,"v":{"a":0,"k":[0,0,0,1],"ix":51}},{"ty":0,"nm":"Sides fill shadow opacity","mn":"Pseudo/Extrudalizer-0052","ix":52,"v":{"a":0,"k":50,"ix":52}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0053","ix":53,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0054","ix":54,"v":0},{"ty":6,"nm":"Parenting Data","mn":"Pseudo/Extrudalizer-0055","ix":55,"v":0},{"ty":0,"nm":"Front opacity readout","mn":"Pseudo/Extrudalizer-0056","ix":56,"v":{"a":0,"k":100,"ix":56,"x":"var $bm_rt;\ntry {\n    $bm_rt = content('--- EXTRUDALIZER ---').content('FRONT').transform.opacity;\n} catch (e) {\n    $bm_rt = 0;\n}"}},{"ty":0,"nm":"Back opacity readout","mn":"Pseudo/Extrudalizer-0057","ix":57,"v":{"a":0,"k":100,"ix":57,"x":"var $bm_rt;\ntry {\n    $bm_rt = content('--- EXTRUDALIZER ---').content('BACK').transform.opacity;\n} catch (e) {\n    $bm_rt = 0;\n}"}},{"ty":7,"nm":"Compute 3D front bounding box","mn":"Pseudo/Extrudalizer-0058","ix":58,"v":{"a":0,"k":1,"ix":58}},{"ty":3,"nm":"Front upper left","mn":"Pseudo/Extrudalizer-0059","ix":59,"v":{"a":0,"k":[0,0],"ix":59,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[0];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[0],\n            front_bb[1]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front upper right","mn":"Pseudo/Extrudalizer-0060","ix":60,"v":{"a":0,"k":[0,0],"ix":60,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[1];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[2],\n            front_bb[3]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front lower left","mn":"Pseudo/Extrudalizer-0061","ix":61,"v":{"a":0,"k":[0,0],"ix":61,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[2];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[4],\n            front_bb[5]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front lower right","mn":"Pseudo/Extrudalizer-0062","ix":62,"v":{"a":0,"k":[0,0],"ix":62,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[3];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[6],\n            front_bb[7]\n        ];\n    }\n}"}},{"ty":7,"nm":"Compute 3D back bounding box","mn":"Pseudo/Extrudalizer-0063","ix":63,"v":{"a":0,"k":1,"ix":63}},{"ty":3,"nm":"Back upper left","mn":"Pseudo/Extrudalizer-0064","ix":64,"v":{"a":0,"k":[0,0],"ix":64,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[0];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[0],\n            back_bb[1]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back upper right","mn":"Pseudo/Extrudalizer-0065","ix":65,"v":{"a":0,"k":[0,0],"ix":65,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[1];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[2],\n            back_bb[3]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back lower left","mn":"Pseudo/Extrudalizer-0066","ix":66,"v":{"a":0,"k":[0,0],"ix":66,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[2];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[4],\n            back_bb[5]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back lower right","mn":"Pseudo/Extrudalizer-0067","ix":67,"v":{"a":0,"k":[0,0],"ix":67,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[3];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[6],\n            back_bb[7]\n        ];\n    }\n}"}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0068","ix":68,"v":0}]},{"ty":5,"nm":"FACE 0","np":3,"mn":"ADBE Color Control","ix":2,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.945098042488,0.919524788857,0.774609744549,1],"ix":1}}]},{"ty":5,"nm":"FACE 1","np":3,"mn":"ADBE Color Control","ix":3,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.996078431606,0.984313726425,0.917647063732,1],"ix":1}}]},{"ty":5,"nm":"FACE 2","np":3,"mn":"ADBE Color Control","ix":4,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.945098042488,0.919524788857,0.774609744549,1],"ix":1}}]},{"ty":5,"nm":"FACE 3","np":3,"mn":"ADBE Color Control","ix":5,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.996078431606,0.984313726425,0.917647063732,1],"ix":1}}]}],"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[150,-150],[150,150],[-150,150],[-150,-150]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":true},{"ty":"st","c":{"a":0,"k":[0,0.925924921971,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":78,"ix":5},"lc":2,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"ORIGIN SHAPE","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nlet extr_data_arr;\nlet points_3D = [];\nlet isPathClosed;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_3D = extr_data_arr[5];\n    isPathClosed = extr_data_arr[4] === true;\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let points_arr = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    isPathClosed = extr_data_arr[4] === 'true';\n    for (var i = 0, il = points_arr.length / 3; i < il; i++) {\n        points_3D.push(points_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst points_2D = points_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst num_pts = points_2D.length;\nconst zeroArr = Array(num_pts).fill([\n    0,\n    0\n]);\n$bm_rt = createPath(points_2D, zeroArr, zeroArr, isPathClosed);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Front color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":2,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Front color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nlet extr_data_arr;\nlet is_facing_towards_us;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    is_facing_towards_us = extr_data_arr[8] === true;\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    is_facing_towards_us = extr_data_arr[8] === 'true';\n}\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = $bm_div(effect('Extrudalizer')('Translucency').value, 2);\nconst opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    if (is_facing_towards_us > 0) {\n        $bm_rt = opacity_value;\n    } else {\n        $bm_rt = transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"FRONT","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nlet extr_data_arr;\nlet points_3D = [];\nlet isPathClosed;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_3D = extr_data_arr[6];\n    isPathClosed = extr_data_arr[4] === true;\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let points_arr = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    isPathClosed = extr_data_arr[4] === 'true';\n    for (var i = 0, il = points_arr.length / 3; i < il; i++) {\n        points_3D.push(points_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst points_2D = points_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst num_pts = points_2D.length;\nconst zeroArr = Array(num_pts).fill([\n    0,\n    0\n]);\n$bm_rt = createPath(points_2D, zeroArr, zeroArr, isPathClosed);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Back color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Back color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    try {\n        const frontOpacity = content('--- EXTRUDALIZER ---').content('FRONT').transform.opacity.value;\n        $bm_rt = value = $bm_sub(100, frontOpacity);\n    } catch (e) {\n        $bm_rt = 100;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"BACK","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 0;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = true ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[0][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[0];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = false ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[0][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[0];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 0 - 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 1;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = true ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[1][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[1];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = false ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[1][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[1];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 1 - 2","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDES","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"--- EXTRUDALIZER ---","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":300,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":8,"ty":5,"nm":"EXTRUDALIZER DATA || square_1","hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[540,540,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"t":{"d":{"k":[{"s":{"s":36,"f":"TrajanPro-Bold","t":"","ca":0,"j":0,"tr":0,"lh":43.2000007629395,"ls":0,"fc":[0.267,0.722,0.765]},"t":0}],"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, arraysEqual, getNormal, get2D_projection, getBoundingBox, getPositionMatrix, getRotationMatrix, getScaleMatrix, getIdentity, translate, rotateX, rotateY, rotateZ, multiplyMatrixVector, multiplyMatrices, multiplyArrayOfMatrices, transformMatrix, make_transform, getPoint, getArea, isClockwise, getCentroid, getCentroidPro, hasNoneZeroValues, angle_between, angle_between_cw, angle_between_cw_te, isStraightLine_w_delta, isFacingTowardsUs, isVectorFacingTowardsUs, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_shape_matrix, get_transforms_from_bb, num_pts, compare_sides, sorted_sides_indices, adjustColorBrightness, lambertShader, stringify;\n'use native operators';\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\narraysEqual = function (arr1, arr2) {\n    for (var i = 0, il = arr1.length; i < il; i++) {\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n};\ngetNormal = function (pts, normalized) {\n    let dir = cross_vec(sub(pts[1], pts[0]), sub(pts[2], pts[0]));\n    let len_dir = len_vec(dir);\n    if (len_dir === 0) {\n        return [\n            0,\n            0,\n            0\n        ];\n    }\n    if (normalized) {\n        return div(dir, len_dir);\n    } else {\n        return dir;\n    }\n};\nget2D_projection = function (points) {\n    return points.map(v => [\n        v[0],\n        v[1]\n    ]);\n};\ngetBoundingBox = function (points) {\n    const boundingBox = {\n        left: Number.POSITIVE_INFINITY,\n        top: Number.POSITIVE_INFINITY,\n        right: Number.NEGATIVE_INFINITY,\n        bottom: Number.NEGATIVE_INFINITY,\n        width: undefined,\n        height: undefined,\n        center: undefined\n    };\n    points.forEach(point => {\n        boundingBox.left = Math.min(boundingBox.left, point[0]);\n        boundingBox.top = Math.min(boundingBox.top, point[1]);\n        boundingBox.right = Math.max(boundingBox.right, point[0]);\n        boundingBox.bottom = Math.max(boundingBox.bottom, point[1]);\n    });\n    boundingBox.width = sub(boundingBox.right, boundingBox.left);\n    boundingBox.height = sub(boundingBox.bottom, boundingBox.top);\n    boundingBox.center = [\n        add(boundingBox.left, $bm_div(boundingBox.width, 2)),\n        add(boundingBox.top, $bm_div(boundingBox.height, 2))\n    ];\n    boundingBox.left_top = [\n        boundingBox.left,\n        boundingBox.top\n    ];\n    boundingBox.left_bottom = [\n        boundingBox.left,\n        boundingBox.bottom\n    ];\n    boundingBox.right_top = [\n        boundingBox.right,\n        boundingBox.top\n    ];\n    boundingBox.right_bottom = [\n        boundingBox.right,\n        boundingBox.bottom\n    ];\n    return boundingBox;\n};\ngetPositionMatrix = function (value) {\n    return translate(getIdentity(), value[0], value[1], $bm_neg(value[2]));\n};\ngetRotationMatrix = function (angles) {\n    const angleX = angles[0];\n    const angleY = angles[1];\n    const angleZ = angles[2];\n    var matrix = getIdentity();\n    matrix = rotateZ(matrix, $bm_div($bm_mul(angleZ, Math.PI), 180));\n    matrix = rotateY(matrix, $bm_div($bm_mul(angleY, Math.PI), 180));\n    matrix = rotateX(matrix, $bm_div($bm_mul(angleX, Math.PI), 180));\n    return matrix;\n};\ngetScaleMatrix = function (sc) {\n    return [\n        sc,\n        0,\n        0,\n        0,\n        0,\n        sc,\n        0,\n        0,\n        0,\n        0,\n        sc,\n        0,\n        0,\n        0,\n        0,\n        1\n    ];\n};\ngetIdentity = function () {\n    return [\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n    ];\n};\ntranslate = function (matrix, x, y, z) {\n    return multiplyMatrices(matrix, [\n        1,\n        0,\n        0,\n        x,\n        0,\n        1,\n        0,\n        y,\n        0,\n        0,\n        1,\n        z,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateX = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        1,\n        0,\n        0,\n        0,\n        0,\n        cos_th,\n        $bm_neg(sin_th),\n        0,\n        0,\n        sin_th,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateY = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        cos_th,\n        0,\n        sin_th,\n        0,\n        0,\n        1,\n        0,\n        0,\n        $bm_neg(sin_th),\n        0,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateZ = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        cos_th,\n        $bm_neg(sin_th),\n        0,\n        0,\n        sin_th,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nmultiplyMatrixVector = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 4; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 4; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 4), j)], vector[j]));\n        }\n    }\n    return result;\n};\nmultiplyMatrices = function (matrixB, matrixA) {\n    let result = new Array(16).fill(0);\n    for (let i = 0; i < 4; i++) {\n        for (let j = 0; j < 4; j++) {\n            for (let k = 0; k < 4; k++) {\n                result[$bm_sum($bm_mul(i, 4), j)] = $bm_sum(result[$bm_sum($bm_mul(i, 4), j)], $bm_mul(matrixA[$bm_sum($bm_mul(i, 4), k)], matrixB[$bm_sum($bm_mul(k, 4), j)]));\n            }\n        }\n    }\n    return result;\n};\nmultiplyArrayOfMatrices = function (matrices) {\n    var result = matrices[0];\n    for (var i = 1, il = matrices.length; i < il; i++) {\n        result = multiplyMatrices(result, matrices[i]);\n    }\n    return result;\n};\ntransformMatrix = function (move, sc, pivot, pitch_angles, anch, orbit_angles) {\n    var mat_array = [];\n    if (sc !== 1) {\n        if (!arraysEqual(pivot, [\n                0,\n                0,\n                0\n            ])) {\n            mat_array = mat_array.concat([\n                getPositionMatrix(pivot.map(i => -i)),\n                getScaleMatrix(sc),\n                getPositionMatrix(pivot)\n            ]);\n        } else {\n            mat_array.push(getScaleMatrix(sc));\n        }\n    }\n    mat_array.push(getPositionMatrix(move));\n    if (!arraysEqual(pitch_angles, [\n            0,\n            0,\n            0\n        ])) {\n        if (!arraysEqual(pivot, [\n                0,\n                0,\n                0\n            ])) {\n            mat_array = mat_array.concat([\n                getPositionMatrix(pivot.map(i => -i)),\n                getRotationMatrix(pitch_angles),\n                getPositionMatrix(pivot)\n            ]);\n        } else {\n            mat_array.push(getRotationMatrix(pitch_angles));\n        }\n    }\n    if (!arraysEqual(anch, [\n            0,\n            0,\n            0\n        ])) {\n        mat_array.push(getPositionMatrix(anch.map(i => -i)));\n    }\n    if (!arraysEqual(orbit_angles, [\n            0,\n            0,\n            0\n        ])) {\n        mat_array.push(getRotationMatrix(orbit_angles));\n    }\n    return multiplyArrayOfMatrices(mat_array);\n};\nmake_transform = function (transform_matrix, vector) {\n    if (vector.length == 2) {\n        vector = [\n            ...vector,\n            0,\n            1\n        ];\n    } else if (vector.length == 3) {\n        vector = [\n            ...vector,\n            1\n        ];\n    }\n    var result_vector_4d = multiplyMatrixVector(transform_matrix, vector);\n    return result_vector_4d.slice(0, 3);\n};\ngetPoint = function (p1, cp1, cp2, p2, t) {\n    const x = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[0]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[0])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[0])), $bm_mul(Math.pow(t, 3), p2[0]));\n    const y = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[1]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[1])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[1])), $bm_mul(Math.pow(t, 3), p2[1]));\n    return [\n        x,\n        y\n    ];\n};\ngetArea = function (points) {\n    var area = 0;\n    for (var i = 0, il = points.length; i < il; i++) {\n        var p1 = points[i];\n        var p2 = points[(i + 1) % il];\n        area = $bm_sum(area, $bm_sub($bm_mul(p1[0], p2[1]), $bm_mul(p2[0], p1[1])));\n    }\n    return $bm_div(area, 2);\n};\nisClockwise = function (points) {\n    return getArea(points) > 0;\n};\ngetCentroid = function (vertices) {\n    var area = getArea(vertices);\n    if (area === 0) {\n        function findCenter(points) {\n            let sumX = 0;\n            let sumY = 0;\n            for (let i = 0, il = points.length; i < il; i++) {\n                const point = points[i];\n                sumX = $bm_sum(sumX, point[0]);\n                sumY = $bm_sum(sumY, point[1]);\n            }\n            const meanX = $bm_div(sumX, points.length);\n            const meanY = $bm_div(sumY, points.length);\n            return [\n                meanX,\n                meanY\n            ];\n        }\n        return findCenter(vertices);\n    }\n    let centroidX = 0;\n    let centroidY = 0;\n    const numVertices = vertices.length;\n    for (var i = 0; i < numVertices; i++) {\n        var currentVertex = vertices[i];\n        var nextVertex = vertices[(i + 1) % numVertices];\n        var commonFactor = $bm_sub($bm_mul(currentVertex[0], nextVertex[1]), $bm_mul(nextVertex[0], currentVertex[1]));\n        centroidX = $bm_sum(centroidX, $bm_mul($bm_sum(currentVertex[0], nextVertex[0]), commonFactor));\n        centroidY = $bm_sum(centroidY, $bm_mul($bm_sum(currentVertex[1], nextVertex[1]), commonFactor));\n    }\n    var scaleFactor = $bm_div(1, $bm_mul(6, area));\n    centroidX *= scaleFactor;\n    centroidY *= scaleFactor;\n    return [\n        centroidX,\n        centroidY\n    ];\n};\ngetCentroidPro = function (vertices) {\n    const bb = getBoundingBox(vertices);\n    return {\n        0: bb.left_top,\n        1: [\n            (bb.left_top[0] + bb.right_top[0]) / 2,\n            bb.left_top[1]\n        ],\n        2: bb.right_top,\n        3: [\n            (bb.left_top[0] + bb.left_bottom[0]) / 2,\n            (bb.left_top[1] + bb.left_bottom[1]) / 2\n        ],\n        4: getCentroid(vertices),\n        5: [\n            (bb.right_top[0] + bb.right_bottom[0]) / 2,\n            (bb.right_top[1] + bb.right_bottom[1]) / 2\n        ],\n        6: bb.left_bottom,\n        7: [\n            (bb.left_bottom[0] + bb.right_bottom[0]) / 2,\n            bb.left_bottom[1]\n        ],\n        8: bb.right_bottom\n    };\n};\nhasNoneZeroValues = function (array2D) {\n    return array2D.some(array => array.some(value => value !== 0));\n};\nangle_between = function (a, b) {\n    const dot_prod = dot_(a, b);\n    const mag_a = len_vec(a);\n    const mag_b = len_vec(b);\n    const cos_ = $bm_div(dot_prod, $bm_mul(mag_a, mag_b));\n    return cos_;\n};\nangle_between_cw = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    angle = angle >= 0 ? angle : $bm_sum($bm_mul(2, Math.PI), angle);\n    const degrees = $bm_mul(angle, $bm_div(180, Math.PI));\n    return degrees;\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nisStraightLine_w_delta = function (cp1, cp2, delta) {\n    return angle_between(cp1, cp2) <= -delta;\n};\nisFacingTowardsUs = function (p1, p2) {\n    return dot_(sub(p2, p1), [\n        0,\n        0,\n        1\n    ]) > 0;\n};\nisVectorFacingTowardsUs = function (v) {\n    return dot_(v, [\n        0,\n        0,\n        -1\n    ]) > 0;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_shape_matrix = function (anchor, pos, scale, rot, skew, skew_axis) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (skew !== 0) {\n        const sk_angle = $bm_div($bm_mul(skew, Math.PI), 180);\n        const Sk = [\n            1,\n            Math.tan(-sk_angle),\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            1\n        ];\n        if (skew_axis !== 0) {\n            const sk_axis_angle = $bm_div($bm_mul(skew_axis, Math.PI), 180);\n            const cos_sk = Math.cos(sk_axis_angle);\n            const sin_sk = Math.sin(sk_axis_angle);\n            const Rz = [\n                cos_sk,\n                -sin_sk,\n                0,\n                sin_sk,\n                cos_sk,\n                0,\n                0,\n                0,\n                1\n            ];\n            const Rz_inv = [\n                cos_sk,\n                sin_sk,\n                0,\n                -sin_sk,\n                cos_sk,\n                0,\n                0,\n                0,\n                1\n            ];\n            const SkM = multiplyArrayOfMatrices3x3([\n                Rz_inv,\n                Sk,\n                Rz\n            ]);\n            mat_array.push(SkM);\n        } else {\n            mat_array.push(Sk);\n        }\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nget_transforms_from_bb = function (bb, extr_transform_matrix, layer_transform_matrix, parent_transform_matrix, is_front, front_facing_towards_us, mode) {\n    let bb_transformed_3D = [];\n    if (front_facing_towards_us) {\n        bb_transformed_3D = [\n            bb.left_top,\n            bb.right_top,\n            bb.left_bottom,\n            bb.right_bottom\n        ];\n    } else {\n        bb_transformed_3D = [\n            bb.right_top,\n            bb.left_top,\n            bb.right_bottom,\n            bb.left_bottom\n        ];\n    }\n    bb_transformed_3D = bb_transformed_3D.map(pnt => make_transform(extr_transform_matrix, pnt));\n    let bb_transformed_2D = get2D_projection(bb_transformed_3D);\n    bb_transformed_2D = bb_transformed_2D.map(p => transform2D_apply(layer_transform_matrix, p));\n    if (parent_transform_matrix) {\n        bb_transformed_2D = bb_transformed_2D.map(p => transform2D_apply(parent_transform_matrix, p));\n    }\n    const ex_left_top = bb_transformed_2D[0], ex_right_top = bb_transformed_2D[1], ex_left_bottom = bb_transformed_2D[2], ex_right_bottom = bb_transformed_2D[3];\n    let transform_effect_controls = [];\n    if (mode & 1) {\n        const bb_pos = ex_left_top;\n        const ex_AD = sub(ex_left_bottom, ex_left_top);\n        const rot = angle_between_cw_te(ex_AD, [\n            0,\n            1\n        ]);\n        const ex_AB = sub(ex_right_top, ex_left_top);\n        const rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\n        const x_rot = [\n            Math.cos(rot_rad),\n            Math.sin(rot_rad)\n        ];\n        let skw = angle_between_cw_te(ex_AB, x_rot);\n        if (!front_facing_towards_us) {\n            skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n            skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n        }\n        ;\n        let extra_skew_arr = [];\n        if (Math.abs(skw) > 70) {\n            const max_count = 7;\n            let count = 1;\n            let skew_ = Math.abs(skw);\n            const tan_70 = Math.tan(degreesToRadians(70));\n            while (skew_ > 70 && count < max_count) {\n                skew_ = radiansToDegrees(Math.atan($bm_sub(Math.tan(degreesToRadians(skew_)), tan_70)));\n                extra_skew_arr.push(skw > 0 ? skew_ : -skew_);\n                count++;\n            }\n        }\n        const scaleY = $bm_mul(100, len_vec(ex_AD));\n        const angle_AB_AD = angle_between_cw_te(ex_AD, ex_AB);\n        const beta = $bm_sub($bm_sub(180, angle_AB_AD), skw);\n        const scaleX_coeff = $bm_div(Math.sin($bm_div($bm_mul(beta, Math.PI), 180)), Math.sin($bm_div($bm_mul(angle_AB_AD, Math.PI), 180)));\n        let scaleX = $bm_div($bm_mul(100, len_vec(ex_AB)), scaleX_coeff);\n        if (!front_facing_towards_us) {\n            scaleX = $bm_neg(scaleX);\n        }\n        transform_effect_controls = [\n            bb_pos,\n            rot,\n            skw,\n            scaleY,\n            scaleX,\n            extra_skew_arr\n        ];\n    }\n    let transform_layer_controls = [];\n    if (mode & 2) {\n        const tl_AB = sub(bb.right_top, bb.left_top);\n        const tl_AD = sub(bb.left_bottom, bb.left_top);\n        const tl_scaleX_coeff = 100;\n        const tl_scaleY_coeff = 100;\n        const tl_bb_anchor = bb.left_top;\n        let tl_bb_pos = ex_left_top;\n        const tl_ex_AB = sub(ex_right_top, ex_left_top);\n        let tl_bb_theta = angle_between_cw(tl_AB, tl_ex_AB);\n        let tl_bb_scx = $bm_div($bm_mul(tl_scaleX_coeff, len_vec(tl_ex_AB)), len_vec(tl_AB));\n        const tl_ex_AD = sub(ex_left_bottom, ex_left_top);\n        const tl_bb_th_rad = $bm_mul(tl_bb_theta, $bm_div(Math.PI, 180));\n        const tl_cos_th = Math.cos(tl_bb_th_rad);\n        const tl_sin_th = Math.sin(tl_bb_th_rad);\n        const tl_AD_rot = [\n            tl_AD[0] * tl_cos_th - tl_AD[1] * tl_sin_th,\n            tl_AD[0] * tl_sin_th + tl_AD[1] * tl_cos_th\n        ];\n        let tl_skew = angle_between_cw(tl_AD_rot, tl_ex_AD);\n        tl_skew = tl_skew < 90 ? tl_skew : $bm_sub(tl_skew, 360);\n        const tl_sk_rad = $bm_div($bm_mul(tl_skew, Math.PI), 180);\n        const tl_AD_skew = [\n            tl_AD[0] + Math.tan(-tl_sk_rad) * tl_AD[1],\n            tl_AD[1]\n        ];\n        const tl_bb_scy = $bm_div($bm_mul(tl_scaleY_coeff, len_vec(tl_ex_AD)), len_vec(tl_AD_skew));\n        if (front_facing_towards_us && !is_front || !front_facing_towards_us && is_front) {\n            tl_bb_scx = $bm_neg(tl_bb_scx);\n            tl_bb_pos = $bm_sum(tl_bb_pos, tl_ex_AB);\n        }\n        transform_layer_controls = [\n            tl_bb_anchor[0],\n            tl_bb_anchor[1],\n            tl_bb_pos[0],\n            tl_bb_pos[1],\n            tl_bb_theta,\n            tl_bb_scx,\n            tl_bb_scy,\n            tl_skew\n        ];\n    }\n    return {\n        'boundingBoxTransformed': bb_transformed_2D,\n        'transformEffectControls': transform_effect_controls,\n        'transformLayerControls': transform_layer_controls\n    };\n};\nconst shape_layer = thisComp.layer('square_1');\nconst shape = shape_layer(2)(1);\nconst shape_contents = shape(2);\nconst targetPath = shape_contents(1)(2);\nconst is_path_closed = targetPath.isClosed();\nconst extrudalizer = shape_layer('ADBE Effect Parade')('Pseudo/Extrudalizer');\nconst depth = extrudalizer('Extrusion depth').value;\nlet anchor = extrudalizer('Position').value;\nanchor = [\n    $bm_neg(anchor[0]),\n    anchor[1],\n    anchor[2]\n];\nconst angleX = extrudalizer('X Rotation').value;\nconst angleY = extrudalizer('Y Rotation').value;\nconst angleZ = extrudalizer('Z Rotation').value;\nconst pivot_angleX = extrudalizer('Pitch (x)').value;\nconst pivot_angleY = extrudalizer('Yaw (y)').value;\nconst pivot_angleZ = extrudalizer('Roll (z)').value;\nconst scale_front = $bm_div(extrudalizer('Front scale').value, 100);\nconst scale_back = $bm_div(extrudalizer('Back scale').value, 100);\nconst use_bb_front = extrudalizer('Compute 3D front bounding box').value;\nconst use_bb_back = extrudalizer('Compute 3D back bounding box').value;\nlet pnts = targetPath.points();\nlet inTangents = targetPath.inTangents();\nlet outTangents = targetPath.outTangents();\nconst is_front_clockwise = isClockwise(pnts);\nconst shape_transform = shape.transform;\nconst s_anchor = shape_transform.anchorPoint;\nconst s_pos = shape_transform.position;\nconst s_scale = shape_transform.scale;\nconst s_rot = shape_transform.rotation;\nconst s_skew = shape_transform.skew;\nconst s_skew_axis = shape_transform.skewAxis;\nconst shape_transform_matrix = get_transform_shape_matrix(s_anchor, s_pos, s_scale, s_rot, s_skew, s_skew_axis);\nconst layer_transform = shape_layer.transform;\nconst l_anchor = layer_transform.anchorPoint;\nconst l_pos = layer_transform.position;\nconst l_scale = layer_transform.scale;\nconst l_rot = layer_transform.rotation;\nconst layer_transform_matrix = get_transform_shape_matrix(l_anchor, l_pos, l_scale, l_rot, 0, 0);\nlet subdivs = 1;\nlet num_pnts = pnts.length;\nif (hasNoneZeroValues(inTangents) || hasNoneZeroValues(outTangents)) {\n    subdivs = 5;\n    let pointsF = [];\n    for (var i = 0; i < num_pnts; i++) {\n        pointsF.push(pnts[i]);\n        if (!is_path_closed && i == num_pnts - 1) {\n            break;\n        }\n        var p1 = pnts[i], p2 = pnts[(i + 1) % num_pnts];\n        var out1 = outTangents[i], in2 = inTangents[(i + 1) % num_pnts];\n        var cp1 = add(p1, out1), cp2 = add(p2, in2);\n        var len_out1 = len_vec(out1), len_in2 = len_vec(in2);\n        var len_p1p2 = len_vec(sub(p2, p1));\n        if (len_out1 !== 0 || len_in2 !== 0) {\n            var a = len_out1 === 0 ? sub(p2, p1) : out1;\n            var b = len_in2 === 0 ? sub(p1, p2) : in2;\n            if (!isStraightLine_w_delta(a, b, 0.999) && (len_out1 > len_p1p2 * 0.02 || len_in2 > len_p1p2 * 0.02)) {\n                for (var j = 1; j < subdivs; j++) {\n                    var t = $bm_div(j, subdivs);\n                    pointsF.push(getPoint(p1, cp1, cp2, p2, t));\n                }\n            }\n        }\n    }\n    pnts = pointsF;\n}\npnts = pnts.map(p => transform2D_apply(shape_transform_matrix, p));\nnum_pts = pnts.length;\nconst zero_center_point = getCentroidPro(pnts)[4];\nlet z_coord = 0;\nswitch (1) {\ncase 0:\n    z_coord = $bm_div($bm_neg(depth), 2);\n    break;\ncase 1:\n    z_coord = 0;\n    break;\ncase 2:\n    z_coord = $bm_div(depth, 2);\n    break;\n}\n;\nconst zero_center_point_3D = [\n    ...zero_center_point,\n    z_coord\n];\nconst pivot_matrix = transformMatrix([\n    0,\n    0,\n    z_coord\n], 1, [\n    0,\n    0,\n    0\n], [\n    0,\n    0,\n    0\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst pivot_position = make_transform(pivot_matrix, zero_center_point);\nconst tr_front_mat = transformMatrix([\n    0,\n    0,\n    $bm_div($bm_neg(depth), 2)\n], scale_front, zero_center_point_3D, [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst tr_back_mat = transformMatrix([\n    0,\n    0,\n    $bm_div(depth, 2)\n], scale_back, zero_center_point_3D, [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst rot_matrix = transformMatrix([\n    0,\n    0,\n    0\n], 1, [\n    0,\n    0,\n    0\n], [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], [\n    0,\n    0,\n    0\n], [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst z1_transformed = make_transform(rot_matrix, [\n    0,\n    0,\n    -1\n]);\nconst front_facing_towards_us = isVectorFacingTowardsUs(z1_transformed);\nlet points_front_3D = pnts.map(pnt => make_transform(tr_front_mat, pnt));\nlet points_back_3D = pnts.map(pnt => make_transform(tr_back_mat, pnt));\nlet winding_sides = [];\nlet sorted_sides = [];\nlet sorted_side_colors = [];\nlet num_sides_towards_us = 0;\nfor (var i = 0; i < num_pts; i++) {\n    if (!is_path_closed && i == num_pts - 1) {\n        break;\n    }\n    var F1 = points_front_3D[i], F2 = points_front_3D[(i + 1) % num_pts];\n    var B1 = points_back_3D[i], B2 = points_back_3D[(i + 1) % num_pts];\n    let abs_side_normal = getNormal([\n        F2,\n        F1,\n        B1\n    ], true);\n    let real_side_normal = !is_front_clockwise ? mul(abs_side_normal, -1) : abs_side_normal;\n    const sideIsFacingUs = isFacingTowardsUs([\n        0,\n        0,\n        0\n    ], real_side_normal);\n    if (sideIsFacingUs) {\n        num_sides_towards_us++;\n    }\n    winding_sides.push(sideIsFacingUs);\n    let side_sorted = [\n        F2,\n        F1,\n        B1,\n        B2\n    ];\n    side_sorted.sort((a, b) => b[2] - a[2]);\n    sorted_sides.push([\n        side_sorted,\n        i,\n        $bm_mod($bm_sum(i, 1), num_pts),\n        abs_side_normal\n    ]);\n}\ncompare_sides = function (side1, side2) {\n    const s1_vertices_z = side1[0].map(v => v[2]), s2_vertices_z = side2[0].map(v => v[2]);\n    for (var i = 0, il = side1[0].length; i < il; i++) {\n        if (s1_vertices_z[i] != s2_vertices_z[i]) {\n            return $bm_sub(s2_vertices_z[i], s1_vertices_z[i]);\n        }\n    }\n};\nsorted_sides.sort((a, b) => compare_sides(a, b));\nsorted_sides.sort(function (a, b) {\n    const fa = winding_sides[a[1]], fb = winding_sides[b[1]];\n    if (fa && !fb) {\n        return -1;\n    } else if (!fa && fb) {\n        return 1;\n    } else {\n        return 0;\n    }\n});\nsorted_sides_indices = sorted_sides.map(p => [\n    p[1],\n    p[2]\n]);\nif (true) {\n    const lambert_max = extrudalizer('Sides fill shadow opacity').value;\n    const rgba = extrudalizer('Sides color').value;\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    lambertShader = function (normal, max_value, multiplier) {\n        return $bm_div($bm_mul($bm_mul(multiplier, $bm_sub(100, max_value)), Math.abs(dot_(normal, [\n            0,\n            0,\n            1\n        ]))), 100);\n    };\n    sorted_side_colors = sorted_sides.map(p => adjustColorBrightness(rgba, lambertShader(p[3], lambert_max, 2)));\n}\nconst front_normal = div(z1_transformed, len_vec(z1_transformed));\nlet bb_front_2D = [], bb_back_2D = [], bb_front_transforms_te = [], bb_back_transforms_te = [], bb_front_transforms_tl = [], bb_back_transforms_tl = [];\nif (use_bb_back || use_bb_front) {\n    const bb = getBoundingBox(pnts);\n    let hasParent = shape_layer.hasParent;\n    let parent_transform_matrix = null;\n    if (hasParent) {\n        let p_pos = shape_layer.parent.transform.position;\n        let p_anchor = shape_layer.parent.transform.anchorPoint;\n        let p_rot = shape_layer.parent.transform.rotation;\n        let p_sca = shape_layer.parent.transform.scale;\n        parent_transform_matrix = get_transform_shape_matrix(p_anchor, p_pos, p_sca, p_rot, 0, 0);\n    }\n    if (use_bb_front) {\n        const bb_front_data = get_transforms_from_bb(bb, tr_front_mat, layer_transform_matrix, parent_transform_matrix, true, front_facing_towards_us, 3);\n        bb_front_2D = bb_front_data['boundingBoxTransformed'];\n        bb_front_transforms_te = bb_front_data['transformEffectControls'];\n        bb_front_transforms_tl = bb_front_data['transformLayerControls'];\n    }\n    if (use_bb_back) {\n        const bb_back_data = get_transforms_from_bb(bb, tr_back_mat, layer_transform_matrix, parent_transform_matrix, false, front_facing_towards_us, 3);\n        bb_back_2D = bb_back_data['boundingBoxTransformed'];\n        bb_back_transforms_te = bb_back_data['transformEffectControls'];\n        bb_back_transforms_tl = bb_back_data['transformLayerControls'];\n    }\n}\nlet grad_property = null;\ntry {\n    grad_property = shape_contents('ADBE Vector Graphic - G-Fill');\n} catch (e) {\n}\nlet grad_start_front_new = [\n    0,\n    0\n];\nlet grad_end_front_new = [\n    0,\n    0\n];\nlet grad_start_back_new = [\n    0,\n    0\n];\nlet grad_end_back_new = [\n    0,\n    0\n];\nif (grad_property != null) {\n    let grad_start = grad_property.startPoint.value;\n    let grad_end = grad_property.endPoint.value;\n    grad_start = transform2D_apply(shape_transform_matrix, grad_start);\n    grad_end = transform2D_apply(shape_transform_matrix, grad_end);\n    const grad_start_front = make_transform(tr_front_mat, grad_start);\n    const grad_end_front = make_transform(tr_front_mat, grad_end);\n    const grad_start_back = make_transform(tr_back_mat, grad_start);\n    const grad_end_back = make_transform(tr_back_mat, grad_end);\n    grad_start_front_new = grad_start_front;\n    grad_end_front_new = grad_end_front;\n    grad_start_back_new = grad_start_back;\n    grad_end_back_new = grad_end_back;\n    const grad_front_rot = $bm_div($bm_mul(extrudalizer('Front gradient direction').value, Math.PI), 180);\n    const grad_back_rot = $bm_div($bm_mul(extrudalizer('Back gradient direction').value, Math.PI), 180);\n    if (!arraysEqual([\n            grad_front_rot,\n            grad_back_rot\n        ], [\n            0,\n            0\n        ])) {\n        const grad_origin_front = div(add(grad_end_front, grad_start_front), 2);\n        const grad_origin_back = div(add(grad_end_back, grad_start_back), 2);\n        const grad_p_st_front = sub(grad_start_front, grad_origin_front);\n        const grad_p_end_front = sub(grad_end_front, grad_origin_front);\n        const grad_p_st_back = sub(grad_start_back, grad_origin_back);\n        const grad_p_end_back = sub(grad_end_back, grad_origin_back);\n        if (grad_front_rot != 0) {\n            const cos_st = Math.cos(grad_front_rot), sin_st = Math.sin(grad_front_rot);\n            grad_start_front_new[0] = $bm_sum($bm_sub($bm_mul(cos_st, grad_p_st_front[0]), $bm_mul(sin_st, grad_p_st_front[1])), grad_origin_front[0]);\n            grad_start_front_new[1] = $bm_sum($bm_sum($bm_mul(sin_st, grad_p_st_front[0]), $bm_mul(cos_st, grad_p_st_front[1])), grad_origin_front[1]);\n            grad_end_front_new[0] = $bm_sum($bm_sub($bm_mul(cos_st, grad_p_end_front[0]), $bm_mul(sin_st, grad_p_end_front[1])), grad_origin_front[0]);\n            grad_end_front_new[1] = $bm_sum($bm_sum($bm_mul(sin_st, grad_p_end_front[0]), $bm_mul(cos_st, grad_p_end_front[1])), grad_origin_front[1]);\n        }\n        if (grad_back_rot != 0) {\n            const cos_st_b = Math.cos(grad_back_rot), sin_st_b = Math.sin(grad_back_rot);\n            grad_start_back_new[0] = $bm_sum($bm_sub($bm_mul(cos_st_b, grad_p_st_back[0]), $bm_mul(sin_st_b, grad_p_st_back[1])), grad_origin_back[0]);\n            grad_start_back_new[1] = $bm_sum($bm_sum($bm_mul(sin_st_b, grad_p_st_back[0]), $bm_mul(cos_st_b, grad_p_st_back[1])), grad_origin_back[1]);\n            grad_end_back_new[0] = $bm_sum($bm_sub($bm_mul(cos_st_b, grad_p_end_back[0]), $bm_mul(sin_st_b, grad_p_end_back[1])), grad_origin_back[0]);\n            grad_end_back_new[1] = $bm_sum($bm_sum($bm_mul(sin_st_b, grad_p_end_back[0]), $bm_mul(cos_st_b, grad_p_end_back[1])), grad_origin_back[1]);\n        }\n    }\n}\nconst extr_data = [\n    tr_front_mat,\n    tr_back_mat,\n    shape_transform_matrix,\n    subdivs,\n    is_path_closed,\n    points_front_3D,\n    points_back_3D,\n    sorted_sides_indices,\n    front_facing_towards_us,\n    is_front_clockwise,\n    num_sides_towards_us,\n    sorted_side_colors,\n    pivot_position,\n    front_normal,\n    bb_front_2D,\n    bb_back_2D,\n    bb_front_transforms_te,\n    bb_back_transforms_te,\n    bb_front_transforms_tl,\n    bb_back_transforms_tl,\n    grad_start_front_new,\n    grad_end_front_new,\n    grad_start_back_new,\n    grad_end_back_new\n];\nvar txt = '';\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'] = extr_data;\n} catch (err) {\n    stringify = function (data, separator) {\n        return data.map(item => Array.isArray(item) ? item.join(',') : item.toString()).join(separator);\n    };\n    txt = stringify(extr_data, ';');\n}\n$bm_rt = txt;"},"p":{},"m":{"g":1,"a":{"a":0,"k":[0,0],"ix":2}},"a":[]},"ip":0,"op":300,"st":0,"ct":1,"bm":0}]},{"id":"comp_12","nm":"Dice","fr":30,"layers":[{"ddd":0,"ind":1,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [3]","refId":"comp_1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    3,\n    0\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [2]","refId":"comp_2","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    2,\n    3\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":3,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [1]","refId":"comp_3","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    1,\n    2\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":4,"ty":0,"nm":"MAP || Dice || square_1 || SIDE  [0]","refId":"comp_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\nvar findIndex;\n'use native operators';\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst ex_layer = thisComp.layer('square_1');\nconst transparency_value = ex_layer.effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nlet extr_data_arr;\nlet srt_ind = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\n$bm_rt = value = is_side_visible ? opacity_value : transparency_value;"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[0,0],"ix":1}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n}\n$bm_rt = C;"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet AB = sub(B, A);\nlet scaleX = $bm_div($bm_mul(100, len_vec(AB)), thisLayer.height);\n$bm_rt = scaleX;"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, len_vec, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix;\n'use native operators';\ndot_ = function (a, b) {\n    return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfunction findIndex(arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n;\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet D = vertices[3];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nD = transform2D_apply(layer_transform_matrix, D);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    D = transform2D_apply(parent_transform_matrix, D);\n}\nlet AD = sub(D, A);\nlet w = thisLayer.width;\nlet skw = effect('Transform')('ADBE Geometry2-0005').value;\nlet cos_sk = Math.cos($bm_div($bm_mul(skw, Math.PI), 180));\nlet scaleY = $bm_div($bm_mul(100, len_vec(AD)), $bm_div(w, cos_sk));\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    scaleY = $bm_neg(scaleY);\n}\n$bm_rt = scaleY;"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\nvar angle_between_cw_te, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, findIndex;\n'use native operators';\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nfindIndex = function (arr, target) {\n    for (var i = 0; i < arr.length; i++) {\n        var innerArray = arr[i];\n        if (innerArray[0] === target[0] && innerArray[1] === target[1]) {\n            return i;\n        }\n    }\n    return -1;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet srt_ind = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    srt_ind = extr_data_arr[7];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    let sorted_indices = extr_data_arr[7];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet C = vertices[2];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nC = transform2D_apply(layer_transform_matrix, C);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    C = transform2D_apply(parent_transform_matrix, C);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet CB = sub(B, C);\nconst rot = effect('Transform')('ADBE Geometry2-0007').value;\nconst rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\nconst x_rot = [\n    Math.cos(rot_rad),\n    Math.sin(rot_rad)\n];\nlet skw = angle_between_cw_te(CB, x_rot);\nvar side_index = findIndex(srt_ind, front_vertex_indices);\nconst num_facing_sides = extr_data_arr[10];\nconst is_side_visible = side_index <= $bm_sub(num_facing_sides, 1);\nif (!is_side_visible) {\n    skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n    skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n}\n;\n$bm_rt = skw;"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_matrix, angle_between_cw_te;\n'use native operators';\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_matrix = function (anchor, pos, scale, rot) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nlet ex_layer = thisComp.layer('square_1');\nlet extr_data_arr;\nlet points_front_3D = [];\nlet points_back_3D = [];\nlet is_clockwise = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n    is_clockwise = extr_data_arr[9];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n    is_clockwise = extr_data_arr[9] == 'true';\n}\nconst front_vertex_indices = [\n    0,\n    1\n];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\nlet vertices = [\n    points_front_2D[front_vertex_indices[1]],\n    points_front_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[0]],\n    points_back_2D[front_vertex_indices[1]]\n];\nif (is_clockwise) {\n    vertices = [\n        vertices[1],\n        vertices[0],\n        vertices[3],\n        vertices[2]\n    ];\n}\nlet A = vertices[0];\nlet B = vertices[1];\nvar l_pos = ex_layer.transform.position;\nvar l_anchor = ex_layer.transform.anchorPoint;\nvar l_rot = ex_layer.transform.rotation;\nvar l_sca = ex_layer.transform.scale;\nconst layer_transform_matrix = get_transform_matrix(l_anchor, l_pos, l_sca, l_rot);\nA = transform2D_apply(layer_transform_matrix, A);\nB = transform2D_apply(layer_transform_matrix, B);\nvar hasParent = ex_layer.hasParent;\nif (hasParent) {\n    var p_pos = ex_layer.parent.transform.position;\n    var p_anchor = ex_layer.parent.transform.anchorPoint;\n    var p_rot = ex_layer.parent.transform.rotation;\n    var p_sca = ex_layer.parent.transform.scale;\n    const parent_transform_matrix = get_transform_matrix(p_anchor, p_pos, p_sca, p_rot);\n    A = transform2D_apply(parent_transform_matrix, A);\n    B = transform2D_apply(parent_transform_matrix, B);\n}\nlet BA = sub(A, B);\n$bm_rt = angle_between_cw_te(BA, [\n    0,\n    1\n]);"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":5,"ty":0,"nm":"MAP || Dice || square_1 || BACK","refId":"comp_5","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('square_1').effect('Extrudalizer')('Back opacity readout');"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[150,150],"ix":1,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst is_front = false;\nconst precomp_width = 300;\nlet extr_data_arr = [];\nlet is_facing_us = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    $bm_rt = is_facing_us = extr_data_arr[8];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    $bm_rt = is_facing_us = extr_data_arr[8] == 'true';\n}\nfunction logicalXOR(input1, input2) {\n    return input1 && !input2 || !input1 && input2;\n}\nif (logicalXOR(is_front, is_facing_us)) {\n    $bm_rt = value = [\n        precomp_width,\n        0\n    ];\n} else {\n    $bm_rt = value = [\n        0,\n        0\n    ];\n}"}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst POS_INDEX_LOTTIE = 0;\nconst POS_INDEX_1 = 0;\nconst POS_INDEX_2 = 1;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let pos = [\n        0,\n        0\n    ];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        $bm_rt = pos = transform_effect_controls[POS_INDEX_LOTTIE];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        $bm_rt = pos = [\n            transform_effect_controls[POS_INDEX_1],\n            transform_effect_controls[POS_INDEX_2]\n        ];\n    }\n}"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 3;\nconst control_index_ae = 4;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.height;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 4;\nconst control_index_ae = 5;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = $bm_neg(thisLayer.width);\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 2;\nconst control_index_ae = 3;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 1;\nconst control_index_ae = 2;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'Back';\nconst face_opacity = ex_layer.effect('Extrudalizer')(face + ' opacity readout').value;\n$bm_rt = face_opacity;"}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":6,"ty":0,"nm":"MAP || Dice || square_1 || FRONT","refId":"comp_6","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('square_1').effect('Extrudalizer')('Front opacity readout');"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[150,150],"ix":1,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst is_front = true;\nconst precomp_width = 300;\nlet extr_data_arr = [];\nlet is_facing_us = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    $bm_rt = is_facing_us = extr_data_arr[8];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    $bm_rt = is_facing_us = extr_data_arr[8] == 'true';\n}\nfunction logicalXOR(input1, input2) {\n    return input1 && !input2 || !input1 && input2;\n}\nif (logicalXOR(is_front, is_facing_us)) {\n    $bm_rt = value = [\n        precomp_width,\n        0\n    ];\n} else {\n    $bm_rt = value = [\n        0,\n        0\n    ];\n}"}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst POS_INDEX_LOTTIE = 0;\nconst POS_INDEX_1 = 0;\nconst POS_INDEX_2 = 1;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let pos = [\n        0,\n        0\n    ];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        $bm_rt = pos = transform_effect_controls[POS_INDEX_LOTTIE];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        $bm_rt = pos = [\n            transform_effect_controls[POS_INDEX_1],\n            transform_effect_controls[POS_INDEX_2]\n        ];\n    }\n}"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 3;\nconst control_index_ae = 4;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.height;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 4;\nconst control_index_ae = 5;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.width;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 2;\nconst control_index_ae = 3;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 1;\nconst control_index_ae = 2;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('square_1');\nconst face = 'Front';\nconst face_opacity = ex_layer.effect('Extrudalizer')(face + ' opacity readout').value;\n$bm_rt = face_opacity;"}},{"ty":7,"nm":"Use Compositionâ€™s Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":300,"st":0,"bm":0},{"ddd":0,"ind":7,"ty":4,"nm":"square_1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[540,540,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":5,"nm":"Extrudalizer","np":70,"mn":"Pseudo/Extrudalizer","ix":1,"en":1,"ef":[{"ty":6,"nm":"3D Transform","mn":"Pseudo/Extrudalizer-0001","ix":1,"v":0},{"ty":0,"nm":"Extrusion depth","mn":"Pseudo/Extrudalizer-0002","ix":2,"v":{"a":0,"k":300,"ix":2}},{"ty":3,"nm":"Position","mn":"Pseudo/Extrudalizer-0003","ix":3,"v":{"a":0,"k":[0,0,0],"ix":3}},{"ty":6,"nm":"Scale","mn":"Pseudo/Extrudalizer-0004","ix":4,"v":0},{"ty":0,"nm":"Front scale","mn":"Pseudo/Extrudalizer-0005","ix":5,"v":{"a":0,"k":100,"ix":5}},{"ty":0,"nm":"Back scale","mn":"Pseudo/Extrudalizer-0006","ix":6,"v":{"a":0,"k":100,"ix":6}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0007","ix":7,"v":0},{"ty":6,"nm":"Pitch/Roll/Yaw","mn":"Pseudo/Extrudalizer-0008","ix":8,"v":0},{"ty":0,"nm":"Pitch (x)","mn":"Pseudo/Extrudalizer-0009","ix":9,"v":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-30]},{"t":180,"s":[330]}],"ix":9}},{"ty":0,"nm":"Yaw (y)","mn":"Pseudo/Extrudalizer-0010","ix":10,"v":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[30]},{"t":180,"s":[750]}],"ix":10}},{"ty":0,"nm":"Roll (z)","mn":"Pseudo/Extrudalizer-0011","ix":11,"v":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[0]},{"t":180,"s":[-720]}],"ix":11}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0012","ix":12,"v":0},{"ty":6,"nm":"Orbit control","mn":"Pseudo/Extrudalizer-0013","ix":13,"v":0},{"ty":0,"nm":"X Rotation","mn":"Pseudo/Extrudalizer-0014","ix":14,"v":{"a":0,"k":0,"ix":14}},{"ty":0,"nm":"Y Rotation","mn":"Pseudo/Extrudalizer-0015","ix":15,"v":{"a":0,"k":0,"ix":15}},{"ty":0,"nm":"Z Rotation","mn":"Pseudo/Extrudalizer-0016","ix":16,"v":{"a":0,"k":0,"ix":16}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0017","ix":17,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0018","ix":18,"v":0},{"ty":6,"nm":"Appearance","mn":"Pseudo/Extrudalizer-0019","ix":19,"v":0},{"ty":7,"nm":"Hide anchor point","mn":"Pseudo/Extrudalizer-0020","ix":20,"v":{"a":0,"k":1,"ix":20}},{"ty":7,"nm":"Wireframe mode","mn":"Pseudo/Extrudalizer-0021","ix":21,"v":{"a":0,"k":0,"ix":21}},{"ty":2,"nm":"Edge stroke color","mn":"Pseudo/Extrudalizer-0022","ix":22,"v":{"a":0,"k":[0.996078491211,0.98431378603,0.917647123337,1],"ix":22}},{"ty":0,"nm":"Edge stroke width","mn":"Pseudo/Extrudalizer-0023","ix":23,"v":{"a":0,"k":0,"ix":23}},{"ty":0,"nm":"Translucency","mn":"Pseudo/Extrudalizer-0024","ix":24,"v":{"a":0,"k":0,"ix":24}},{"ty":6,"nm":"Front & Back ","mn":"Pseudo/Extrudalizer-0025","ix":25,"v":0},{"ty":2,"nm":"Front color","mn":"Pseudo/Extrudalizer-0026","ix":26,"v":{"a":0,"k":[0.996078491211,0.98431378603,0.917647123337,1],"ix":26}},{"ty":0,"nm":"Front opacity","mn":"Pseudo/Extrudalizer-0027","ix":27,"v":{"a":0,"k":100,"ix":27}},{"ty":0,"nm":"Front gradient opacity","mn":"Pseudo/Extrudalizer-0028","ix":28,"v":{"a":0,"k":0,"ix":28}},{"ty":0,"nm":"Front gradient direction","mn":"Pseudo/Extrudalizer-0029","ix":29,"v":{"a":0,"k":0,"ix":29}},{"ty":6,"nm":"   ","mn":"Pseudo/Extrudalizer-0030","ix":30,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0031","ix":31,"v":0},{"ty":2,"nm":"Back color","mn":"Pseudo/Extrudalizer-0032","ix":32,"v":{"a":0,"k":[0.996078491211,0.98431378603,0.917647123337,1],"ix":32}},{"ty":0,"nm":"Back opacity","mn":"Pseudo/Extrudalizer-0033","ix":33,"v":{"a":0,"k":100,"ix":33}},{"ty":0,"nm":"Back gradient opacity","mn":"Pseudo/Extrudalizer-0034","ix":34,"v":{"a":0,"k":0,"ix":34}},{"ty":0,"nm":"Back gradient direction","mn":"Pseudo/Extrudalizer-0035","ix":35,"v":{"a":0,"k":0,"ix":35}},{"ty":6,"nm":"    ","mn":"Pseudo/Extrudalizer-0036","ix":36,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0037","ix":37,"v":0},{"ty":3,"nm":"Gradient start point","mn":"Pseudo/Extrudalizer-0038","ix":38,"v":{"a":0,"k":[0,0],"ix":38}},{"ty":3,"nm":"Gradient end point","mn":"Pseudo/Extrudalizer-0039","ix":39,"v":{"a":0,"k":[0,0],"ix":39}},{"ty":6,"nm":"Edit gradient start/end points o","mn":"Pseudo/Extrudalizer-0040","ix":40,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0041","ix":41,"v":0},{"ty":6,"nm":"at 3D rotation set to [0,0,0]","mn":"Pseudo/Extrudalizer-0042","ix":42,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0043","ix":43,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0044","ix":44,"v":0},{"ty":6,"nm":"Sides","mn":"Pseudo/Extrudalizer-0045","ix":45,"v":0},{"ty":2,"nm":"Sides color","mn":"Pseudo/Extrudalizer-0046","ix":46,"v":{"a":0,"k":[0,1,1,1],"ix":46}},{"ty":0,"nm":"Sides opacity","mn":"Pseudo/Extrudalizer-0047","ix":47,"v":{"a":0,"k":100,"ix":47}},{"ty":0,"nm":"Sides gradient opacity","mn":"Pseudo/Extrudalizer-0048","ix":48,"v":{"a":0,"k":25,"ix":48}},{"ty":0,"nm":"Sides gradient direction","mn":"Pseudo/Extrudalizer-0049","ix":49,"v":{"a":0,"k":0,"ix":49}},{"ty":0,"nm":"Sides gradient length","mn":"Pseudo/Extrudalizer-0050","ix":50,"v":{"a":0,"k":0,"ix":50}},{"ty":2,"nm":"Sides fill shadow color","mn":"Pseudo/Extrudalizer-0051","ix":51,"v":{"a":0,"k":[0,0,0,1],"ix":51}},{"ty":0,"nm":"Sides fill shadow opacity","mn":"Pseudo/Extrudalizer-0052","ix":52,"v":{"a":0,"k":50,"ix":52}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0053","ix":53,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0054","ix":54,"v":0},{"ty":6,"nm":"Parenting Data","mn":"Pseudo/Extrudalizer-0055","ix":55,"v":0},{"ty":0,"nm":"Front opacity readout","mn":"Pseudo/Extrudalizer-0056","ix":56,"v":{"a":0,"k":100,"ix":56,"x":"var $bm_rt;\ntry {\n    $bm_rt = content('--- EXTRUDALIZER ---').content('FRONT').transform.opacity;\n} catch (e) {\n    $bm_rt = 0;\n}"}},{"ty":0,"nm":"Back opacity readout","mn":"Pseudo/Extrudalizer-0057","ix":57,"v":{"a":0,"k":100,"ix":57,"x":"var $bm_rt;\ntry {\n    $bm_rt = content('--- EXTRUDALIZER ---').content('BACK').transform.opacity;\n} catch (e) {\n    $bm_rt = 0;\n}"}},{"ty":7,"nm":"Compute 3D front bounding box","mn":"Pseudo/Extrudalizer-0058","ix":58,"v":{"a":0,"k":1,"ix":58}},{"ty":3,"nm":"Front upper left","mn":"Pseudo/Extrudalizer-0059","ix":59,"v":{"a":0,"k":[0,0],"ix":59,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[0];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[0],\n            front_bb[1]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front upper right","mn":"Pseudo/Extrudalizer-0060","ix":60,"v":{"a":0,"k":[0,0],"ix":60,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[1];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[2],\n            front_bb[3]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front lower left","mn":"Pseudo/Extrudalizer-0061","ix":61,"v":{"a":0,"k":[0,0],"ix":61,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[2];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[4],\n            front_bb[5]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front lower right","mn":"Pseudo/Extrudalizer-0062","ix":62,"v":{"a":0,"k":[0,0],"ix":62,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[3];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[6],\n            front_bb[7]\n        ];\n    }\n}"}},{"ty":7,"nm":"Compute 3D back bounding box","mn":"Pseudo/Extrudalizer-0063","ix":63,"v":{"a":0,"k":1,"ix":63}},{"ty":3,"nm":"Back upper left","mn":"Pseudo/Extrudalizer-0064","ix":64,"v":{"a":0,"k":[0,0],"ix":64,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[0];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[0],\n            back_bb[1]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back upper right","mn":"Pseudo/Extrudalizer-0065","ix":65,"v":{"a":0,"k":[0,0],"ix":65,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[1];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[2],\n            back_bb[3]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back lower left","mn":"Pseudo/Extrudalizer-0066","ix":66,"v":{"a":0,"k":[0,0],"ix":66,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[2];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[4],\n            back_bb[5]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back lower right","mn":"Pseudo/Extrudalizer-0067","ix":67,"v":{"a":0,"k":[0,0],"ix":67,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[3];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[6],\n            back_bb[7]\n        ];\n    }\n}"}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0068","ix":68,"v":0}]},{"ty":5,"nm":"FACE 0","np":3,"mn":"ADBE Color Control","ix":2,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.945098042488,0.919524788857,0.774609744549,1],"ix":1}}]},{"ty":5,"nm":"FACE 1","np":3,"mn":"ADBE Color Control","ix":3,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.996078431606,0.984313726425,0.917647063732,1],"ix":1}}]},{"ty":5,"nm":"FACE 2","np":3,"mn":"ADBE Color Control","ix":4,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.945098042488,0.919524788857,0.774609744549,1],"ix":1}}]},{"ty":5,"nm":"FACE 3","np":3,"mn":"ADBE Color Control","ix":5,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.996078431606,0.984313726425,0.917647063732,1],"ix":1}}]}],"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[150,-150],[150,150],[-150,150],[-150,-150]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":true},{"ty":"st","c":{"a":0,"k":[0,0.925924921971,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":78,"ix":5},"lc":2,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"ORIGIN SHAPE","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nlet extr_data_arr;\nlet points_3D = [];\nlet isPathClosed;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_3D = extr_data_arr[5];\n    isPathClosed = extr_data_arr[4] === true;\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let points_arr = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    isPathClosed = extr_data_arr[4] === 'true';\n    for (var i = 0, il = points_arr.length / 3; i < il; i++) {\n        points_3D.push(points_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst points_2D = points_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst num_pts = points_2D.length;\nconst zeroArr = Array(num_pts).fill([\n    0,\n    0\n]);\n$bm_rt = createPath(points_2D, zeroArr, zeroArr, isPathClosed);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Front color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":2,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Front color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nlet extr_data_arr;\nlet is_facing_towards_us;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    is_facing_towards_us = extr_data_arr[8] === true;\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    is_facing_towards_us = extr_data_arr[8] === 'true';\n}\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = $bm_div(effect('Extrudalizer')('Translucency').value, 2);\nconst opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    if (is_facing_towards_us > 0) {\n        $bm_rt = opacity_value;\n    } else {\n        $bm_rt = transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"FRONT","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nlet extr_data_arr;\nlet points_3D = [];\nlet isPathClosed;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    points_3D = extr_data_arr[6];\n    isPathClosed = extr_data_arr[4] === true;\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let points_arr = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    isPathClosed = extr_data_arr[4] === 'true';\n    for (var i = 0, il = points_arr.length / 3; i < il; i++) {\n        points_3D.push(points_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst points_2D = points_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst num_pts = points_2D.length;\nconst zeroArr = Array(num_pts).fill([\n    0,\n    0\n]);\n$bm_rt = createPath(points_2D, zeroArr, zeroArr, isPathClosed);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Back color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Back color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    try {\n        const frontOpacity = content('--- EXTRUDALIZER ---').content('FRONT').transform.opacity.value;\n        $bm_rt = value = $bm_sub(100, frontOpacity);\n    } catch (e) {\n        $bm_rt = 100;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"BACK","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 0;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = true ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[0][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[0];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = false ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[0][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[0];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 0 - 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 1;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[255,255,0,1],"ix":3,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = true ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[1][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[1];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[255,0,255,1],"ix":4,"x":"var $bm_rt;\nvar sorted_indices;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = false ? effect('Extrudalizer')('Edge stroke color').value : [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let sidecolors = [];\n    let srt_ind = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'];\n        sidecolors = extr_data_arr[11];\n        srt_ind = extr_data_arr[7];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || square_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        let sidecolors_arr = extr_data_arr[11].split(',').map(p => parseFloat(p));\n        for (var i = 0, il = sidecolors_arr.length / 4; i < il; i++) {\n            sidecolors.push(sidecolors_arr.slice($bm_mul(4, i), $bm_sum($bm_mul(4, i), 4)));\n        }\n        sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n        for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n            srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n        }\n    }\n    try {\n        effect('FACE ' + '0');\n        const currentIndex = srt_ind[1][0];\n        color = effect('FACE ' + currentIndex)('ADBE Color Control-0001').value;\n    } catch (e) {\n        color = sidecolors[1];\n    }\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 1 - 2","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDES","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"--- EXTRUDALIZER ---","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":300,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":8,"ty":5,"nm":"EXTRUDALIZER DATA || square_1","hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[540,540,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"t":{"d":{"k":[{"s":{"s":36,"f":"TrajanPro-Bold","t":"","ca":0,"j":0,"tr":0,"lh":43.2000007629395,"ls":0,"fc":[0.267,0.722,0.765]},"t":0}],"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, arraysEqual, getNormal, get2D_projection, getBoundingBox, getPositionMatrix, getRotationMatrix, getScaleMatrix, getIdentity, translate, rotateX, rotateY, rotateZ, multiplyMatrixVector, multiplyMatrices, multiplyArrayOfMatrices, transformMatrix, make_transform, getPoint, getArea, isClockwise, getCentroid, getCentroidPro, hasNoneZeroValues, angle_between, angle_between_cw, angle_between_cw_te, isStraightLine_w_delta, isFacingTowardsUs, isVectorFacingTowardsUs, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_shape_matrix, get_transforms_from_bb, num_pts, compare_sides, sorted_sides_indices, adjustColorBrightness, lambertShader, stringify;\n'use native operators';\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\narraysEqual = function (arr1, arr2) {\n    for (var i = 0, il = arr1.length; i < il; i++) {\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n};\ngetNormal = function (pts, normalized) {\n    let dir = cross_vec(sub(pts[1], pts[0]), sub(pts[2], pts[0]));\n    let len_dir = len_vec(dir);\n    if (len_dir === 0) {\n        return [\n            0,\n            0,\n            0\n        ];\n    }\n    if (normalized) {\n        return div(dir, len_dir);\n    } else {\n        return dir;\n    }\n};\nget2D_projection = function (points) {\n    return points.map(v => [\n        v[0],\n        v[1]\n    ]);\n};\ngetBoundingBox = function (points) {\n    const boundingBox = {\n        left: Number.POSITIVE_INFINITY,\n        top: Number.POSITIVE_INFINITY,\n        right: Number.NEGATIVE_INFINITY,\n        bottom: Number.NEGATIVE_INFINITY,\n        width: undefined,\n        height: undefined,\n        center: undefined\n    };\n    points.forEach(point => {\n        boundingBox.left = Math.min(boundingBox.left, point[0]);\n        boundingBox.top = Math.min(boundingBox.top, point[1]);\n        boundingBox.right = Math.max(boundingBox.right, point[0]);\n        boundingBox.bottom = Math.max(boundingBox.bottom, point[1]);\n    });\n    boundingBox.width = sub(boundingBox.right, boundingBox.left);\n    boundingBox.height = sub(boundingBox.bottom, boundingBox.top);\n    boundingBox.center = [\n        add(boundingBox.left, $bm_div(boundingBox.width, 2)),\n        add(boundingBox.top, $bm_div(boundingBox.height, 2))\n    ];\n    boundingBox.left_top = [\n        boundingBox.left,\n        boundingBox.top\n    ];\n    boundingBox.left_bottom = [\n        boundingBox.left,\n        boundingBox.bottom\n    ];\n    boundingBox.right_top = [\n        boundingBox.right,\n        boundingBox.top\n    ];\n    boundingBox.right_bottom = [\n        boundingBox.right,\n        boundingBox.bottom\n    ];\n    return boundingBox;\n};\ngetPositionMatrix = function (value) {\n    return translate(getIdentity(), value[0], value[1], $bm_neg(value[2]));\n};\ngetRotationMatrix = function (angles) {\n    const angleX = angles[0];\n    const angleY = angles[1];\n    const angleZ = angles[2];\n    var matrix = getIdentity();\n    matrix = rotateZ(matrix, $bm_div($bm_mul(angleZ, Math.PI), 180));\n    matrix = rotateY(matrix, $bm_div($bm_mul(angleY, Math.PI), 180));\n    matrix = rotateX(matrix, $bm_div($bm_mul(angleX, Math.PI), 180));\n    return matrix;\n};\ngetScaleMatrix = function (sc) {\n    return [\n        sc,\n        0,\n        0,\n        0,\n        0,\n        sc,\n        0,\n        0,\n        0,\n        0,\n        sc,\n        0,\n        0,\n        0,\n        0,\n        1\n    ];\n};\ngetIdentity = function () {\n    return [\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n    ];\n};\ntranslate = function (matrix, x, y, z) {\n    return multiplyMatrices(matrix, [\n        1,\n        0,\n        0,\n        x,\n        0,\n        1,\n        0,\n        y,\n        0,\n        0,\n        1,\n        z,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateX = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        1,\n        0,\n        0,\n        0,\n        0,\n        cos_th,\n        $bm_neg(sin_th),\n        0,\n        0,\n        sin_th,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateY = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        cos_th,\n        0,\n        sin_th,\n        0,\n        0,\n        1,\n        0,\n        0,\n        $bm_neg(sin_th),\n        0,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateZ = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        cos_th,\n        $bm_neg(sin_th),\n        0,\n        0,\n        sin_th,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nmultiplyMatrixVector = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 4; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 4; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 4), j)], vector[j]));\n        }\n    }\n    return result;\n};\nmultiplyMatrices = function (matrixB, matrixA) {\n    let result = new Array(16).fill(0);\n    for (let i = 0; i < 4; i++) {\n        for (let j = 0; j < 4; j++) {\n            for (let k = 0; k < 4; k++) {\n                result[$bm_sum($bm_mul(i, 4), j)] = $bm_sum(result[$bm_sum($bm_mul(i, 4), j)], $bm_mul(matrixA[$bm_sum($bm_mul(i, 4), k)], matrixB[$bm_sum($bm_mul(k, 4), j)]));\n            }\n        }\n    }\n    return result;\n};\nmultiplyArrayOfMatrices = function (matrices) {\n    var result = matrices[0];\n    for (var i = 1, il = matrices.length; i < il; i++) {\n        result = multiplyMatrices(result, matrices[i]);\n    }\n    return result;\n};\ntransformMatrix = function (move, sc, pivot, pitch_angles, anch, orbit_angles) {\n    var mat_array = [];\n    if (sc !== 1) {\n        if (!arraysEqual(pivot, [\n                0,\n                0,\n                0\n            ])) {\n            mat_array = mat_array.concat([\n                getPositionMatrix(pivot.map(i => -i)),\n                getScaleMatrix(sc),\n                getPositionMatrix(pivot)\n            ]);\n        } else {\n            mat_array.push(getScaleMatrix(sc));\n        }\n    }\n    mat_array.push(getPositionMatrix(move));\n    if (!arraysEqual(pitch_angles, [\n            0,\n            0,\n            0\n        ])) {\n        if (!arraysEqual(pivot, [\n                0,\n                0,\n                0\n            ])) {\n            mat_array = mat_array.concat([\n                getPositionMatrix(pivot.map(i => -i)),\n                getRotationMatrix(pitch_angles),\n                getPositionMatrix(pivot)\n            ]);\n        } else {\n            mat_array.push(getRotationMatrix(pitch_angles));\n        }\n    }\n    if (!arraysEqual(anch, [\n            0,\n            0,\n            0\n        ])) {\n        mat_array.push(getPositionMatrix(anch.map(i => -i)));\n    }\n    if (!arraysEqual(orbit_angles, [\n            0,\n            0,\n            0\n        ])) {\n        mat_array.push(getRotationMatrix(orbit_angles));\n    }\n    return multiplyArrayOfMatrices(mat_array);\n};\nmake_transform = function (transform_matrix, vector) {\n    if (vector.length == 2) {\n        vector = [\n            ...vector,\n            0,\n            1\n        ];\n    } else if (vector.length == 3) {\n        vector = [\n            ...vector,\n            1\n        ];\n    }\n    var result_vector_4d = multiplyMatrixVector(transform_matrix, vector);\n    return result_vector_4d.slice(0, 3);\n};\ngetPoint = function (p1, cp1, cp2, p2, t) {\n    const x = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[0]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[0])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[0])), $bm_mul(Math.pow(t, 3), p2[0]));\n    const y = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[1]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[1])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[1])), $bm_mul(Math.pow(t, 3), p2[1]));\n    return [\n        x,\n        y\n    ];\n};\ngetArea = function (points) {\n    var area = 0;\n    for (var i = 0, il = points.length; i < il; i++) {\n        var p1 = points[i];\n        var p2 = points[(i + 1) % il];\n        area = $bm_sum(area, $bm_sub($bm_mul(p1[0], p2[1]), $bm_mul(p2[0], p1[1])));\n    }\n    return $bm_div(area, 2);\n};\nisClockwise = function (points) {\n    return getArea(points) > 0;\n};\ngetCentroid = function (vertices) {\n    var area = getArea(vertices);\n    if (area === 0) {\n        function findCenter(points) {\n            let sumX = 0;\n            let sumY = 0;\n            for (let i = 0, il = points.length; i < il; i++) {\n                const point = points[i];\n                sumX = $bm_sum(sumX, point[0]);\n                sumY = $bm_sum(sumY, point[1]);\n            }\n            const meanX = $bm_div(sumX, points.length);\n            const meanY = $bm_div(sumY, points.length);\n            return [\n                meanX,\n                meanY\n            ];\n        }\n        return findCenter(vertices);\n    }\n    let centroidX = 0;\n    let centroidY = 0;\n    const numVertices = vertices.length;\n    for (var i = 0; i < numVertices; i++) {\n        var currentVertex = vertices[i];\n        var nextVertex = vertices[(i + 1) % numVertices];\n        var commonFactor = $bm_sub($bm_mul(currentVertex[0], nextVertex[1]), $bm_mul(nextVertex[0], currentVertex[1]));\n        centroidX = $bm_sum(centroidX, $bm_mul($bm_sum(currentVertex[0], nextVertex[0]), commonFactor));\n        centroidY = $bm_sum(centroidY, $bm_mul($bm_sum(currentVertex[1], nextVertex[1]), commonFactor));\n    }\n    var scaleFactor = $bm_div(1, $bm_mul(6, area));\n    centroidX *= scaleFactor;\n    centroidY *= scaleFactor;\n    return [\n        centroidX,\n        centroidY\n    ];\n};\ngetCentroidPro = function (vertices) {\n    const bb = getBoundingBox(vertices);\n    return {\n        0: bb.left_top,\n        1: [\n            (bb.left_top[0] + bb.right_top[0]) / 2,\n            bb.left_top[1]\n        ],\n        2: bb.right_top,\n        3: [\n            (bb.left_top[0] + bb.left_bottom[0]) / 2,\n            (bb.left_top[1] + bb.left_bottom[1]) / 2\n        ],\n        4: getCentroid(vertices),\n        5: [\n            (bb.right_top[0] + bb.right_bottom[0]) / 2,\n            (bb.right_top[1] + bb.right_bottom[1]) / 2\n        ],\n        6: bb.left_bottom,\n        7: [\n            (bb.left_bottom[0] + bb.right_bottom[0]) / 2,\n            bb.left_bottom[1]\n        ],\n        8: bb.right_bottom\n    };\n};\nhasNoneZeroValues = function (array2D) {\n    return array2D.some(array => array.some(value => value !== 0));\n};\nangle_between = function (a, b) {\n    const dot_prod = dot_(a, b);\n    const mag_a = len_vec(a);\n    const mag_b = len_vec(b);\n    const cos_ = $bm_div(dot_prod, $bm_mul(mag_a, mag_b));\n    return cos_;\n};\nangle_between_cw = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    angle = angle >= 0 ? angle : $bm_sum($bm_mul(2, Math.PI), angle);\n    const degrees = $bm_mul(angle, $bm_div(180, Math.PI));\n    return degrees;\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nisStraightLine_w_delta = function (cp1, cp2, delta) {\n    return angle_between(cp1, cp2) <= -delta;\n};\nisFacingTowardsUs = function (p1, p2) {\n    return dot_(sub(p2, p1), [\n        0,\n        0,\n        1\n    ]) > 0;\n};\nisVectorFacingTowardsUs = function (v) {\n    return dot_(v, [\n        0,\n        0,\n        -1\n    ]) > 0;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_shape_matrix = function (anchor, pos, scale, rot, skew, skew_axis) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (skew !== 0) {\n        const sk_angle = $bm_div($bm_mul(skew, Math.PI), 180);\n        const Sk = [\n            1,\n            Math.tan(-sk_angle),\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            1\n        ];\n        if (skew_axis !== 0) {\n            const sk_axis_angle = $bm_div($bm_mul(skew_axis, Math.PI), 180);\n            const cos_sk = Math.cos(sk_axis_angle);\n            const sin_sk = Math.sin(sk_axis_angle);\n            const Rz = [\n                cos_sk,\n                -sin_sk,\n                0,\n                sin_sk,\n                cos_sk,\n                0,\n                0,\n                0,\n                1\n            ];\n            const Rz_inv = [\n                cos_sk,\n                sin_sk,\n                0,\n                -sin_sk,\n                cos_sk,\n                0,\n                0,\n                0,\n                1\n            ];\n            const SkM = multiplyArrayOfMatrices3x3([\n                Rz_inv,\n                Sk,\n                Rz\n            ]);\n            mat_array.push(SkM);\n        } else {\n            mat_array.push(Sk);\n        }\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nget_transforms_from_bb = function (bb, extr_transform_matrix, layer_transform_matrix, parent_transform_matrix, is_front, front_facing_towards_us, mode) {\n    let bb_transformed_3D = [];\n    if (front_facing_towards_us) {\n        bb_transformed_3D = [\n            bb.left_top,\n            bb.right_top,\n            bb.left_bottom,\n            bb.right_bottom\n        ];\n    } else {\n        bb_transformed_3D = [\n            bb.right_top,\n            bb.left_top,\n            bb.right_bottom,\n            bb.left_bottom\n        ];\n    }\n    bb_transformed_3D = bb_transformed_3D.map(pnt => make_transform(extr_transform_matrix, pnt));\n    let bb_transformed_2D = get2D_projection(bb_transformed_3D);\n    bb_transformed_2D = bb_transformed_2D.map(p => transform2D_apply(layer_transform_matrix, p));\n    if (parent_transform_matrix) {\n        bb_transformed_2D = bb_transformed_2D.map(p => transform2D_apply(parent_transform_matrix, p));\n    }\n    const ex_left_top = bb_transformed_2D[0], ex_right_top = bb_transformed_2D[1], ex_left_bottom = bb_transformed_2D[2], ex_right_bottom = bb_transformed_2D[3];\n    let transform_effect_controls = [];\n    if (mode & 1) {\n        const bb_pos = ex_left_top;\n        const ex_AD = sub(ex_left_bottom, ex_left_top);\n        const rot = angle_between_cw_te(ex_AD, [\n            0,\n            1\n        ]);\n        const ex_AB = sub(ex_right_top, ex_left_top);\n        const rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\n        const x_rot = [\n            Math.cos(rot_rad),\n            Math.sin(rot_rad)\n        ];\n        let skw = angle_between_cw_te(ex_AB, x_rot);\n        if (!front_facing_towards_us) {\n            skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n            skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n        }\n        ;\n        let extra_skew_arr = [];\n        if (Math.abs(skw) > 70) {\n            const max_count = 7;\n            let count = 1;\n            let skew_ = Math.abs(skw);\n            const tan_70 = Math.tan(degreesToRadians(70));\n            while (skew_ > 70 && count < max_count) {\n                skew_ = radiansToDegrees(Math.atan($bm_sub(Math.tan(degreesToRadians(skew_)), tan_70)));\n                extra_skew_arr.push(skw > 0 ? skew_ : -skew_);\n                count++;\n            }\n        }\n        const scaleY = $bm_mul(100, len_vec(ex_AD));\n        const angle_AB_AD = angle_between_cw_te(ex_AD, ex_AB);\n        const beta = $bm_sub($bm_sub(180, angle_AB_AD), skw);\n        const scaleX_coeff = $bm_div(Math.sin($bm_div($bm_mul(beta, Math.PI), 180)), Math.sin($bm_div($bm_mul(angle_AB_AD, Math.PI), 180)));\n        let scaleX = $bm_div($bm_mul(100, len_vec(ex_AB)), scaleX_coeff);\n        if (!front_facing_towards_us) {\n            scaleX = $bm_neg(scaleX);\n        }\n        transform_effect_controls = [\n            bb_pos,\n            rot,\n            skw,\n            scaleY,\n            scaleX,\n            extra_skew_arr\n        ];\n    }\n    let transform_layer_controls = [];\n    if (mode & 2) {\n        const tl_AB = sub(bb.right_top, bb.left_top);\n        const tl_AD = sub(bb.left_bottom, bb.left_top);\n        const tl_scaleX_coeff = 100;\n        const tl_scaleY_coeff = 100;\n        const tl_bb_anchor = bb.left_top;\n        let tl_bb_pos = ex_left_top;\n        const tl_ex_AB = sub(ex_right_top, ex_left_top);\n        let tl_bb_theta = angle_between_cw(tl_AB, tl_ex_AB);\n        let tl_bb_scx = $bm_div($bm_mul(tl_scaleX_coeff, len_vec(tl_ex_AB)), len_vec(tl_AB));\n        const tl_ex_AD = sub(ex_left_bottom, ex_left_top);\n        const tl_bb_th_rad = $bm_mul(tl_bb_theta, $bm_div(Math.PI, 180));\n        const tl_cos_th = Math.cos(tl_bb_th_rad);\n        const tl_sin_th = Math.sin(tl_bb_th_rad);\n        const tl_AD_rot = [\n            tl_AD[0] * tl_cos_th - tl_AD[1] * tl_sin_th,\n            tl_AD[0] * tl_sin_th + tl_AD[1] * tl_cos_th\n        ];\n        let tl_skew = angle_between_cw(tl_AD_rot, tl_ex_AD);\n        tl_skew = tl_skew < 90 ? tl_skew : $bm_sub(tl_skew, 360);\n        const tl_sk_rad = $bm_div($bm_mul(tl_skew, Math.PI), 180);\n        const tl_AD_skew = [\n            tl_AD[0] + Math.tan(-tl_sk_rad) * tl_AD[1],\n            tl_AD[1]\n        ];\n        const tl_bb_scy = $bm_div($bm_mul(tl_scaleY_coeff, len_vec(tl_ex_AD)), len_vec(tl_AD_skew));\n        if (front_facing_towards_us && !is_front || !front_facing_towards_us && is_front) {\n            tl_bb_scx = $bm_neg(tl_bb_scx);\n            tl_bb_pos = $bm_sum(tl_bb_pos, tl_ex_AB);\n        }\n        transform_layer_controls = [\n            tl_bb_anchor[0],\n            tl_bb_anchor[1],\n            tl_bb_pos[0],\n            tl_bb_pos[1],\n            tl_bb_theta,\n            tl_bb_scx,\n            tl_bb_scy,\n            tl_skew\n        ];\n    }\n    return {\n        'boundingBoxTransformed': bb_transformed_2D,\n        'transformEffectControls': transform_effect_controls,\n        'transformLayerControls': transform_layer_controls\n    };\n};\nconst shape_layer = thisComp.layer('square_1');\nconst shape = shape_layer(2)(1);\nconst shape_contents = shape(2);\nconst targetPath = shape_contents(1)(2);\nconst is_path_closed = targetPath.isClosed();\nconst extrudalizer = shape_layer('ADBE Effect Parade')('Pseudo/Extrudalizer');\nconst depth = extrudalizer('Extrusion depth').value;\nlet anchor = extrudalizer('Position').value;\nanchor = [\n    $bm_neg(anchor[0]),\n    anchor[1],\n    anchor[2]\n];\nconst angleX = extrudalizer('X Rotation').value;\nconst angleY = extrudalizer('Y Rotation').value;\nconst angleZ = extrudalizer('Z Rotation').value;\nconst pivot_angleX = extrudalizer('Pitch (x)').value;\nconst pivot_angleY = extrudalizer('Yaw (y)').value;\nconst pivot_angleZ = extrudalizer('Roll (z)').value;\nconst scale_front = $bm_div(extrudalizer('Front scale').value, 100);\nconst scale_back = $bm_div(extrudalizer('Back scale').value, 100);\nconst use_bb_front = extrudalizer('Compute 3D front bounding box').value;\nconst use_bb_back = extrudalizer('Compute 3D back bounding box').value;\nlet pnts = targetPath.points();\nlet inTangents = targetPath.inTangents();\nlet outTangents = targetPath.outTangents();\nconst is_front_clockwise = isClockwise(pnts);\nconst shape_transform = shape.transform;\nconst s_anchor = shape_transform.anchorPoint;\nconst s_pos = shape_transform.position;\nconst s_scale = shape_transform.scale;\nconst s_rot = shape_transform.rotation;\nconst s_skew = shape_transform.skew;\nconst s_skew_axis = shape_transform.skewAxis;\nconst shape_transform_matrix = get_transform_shape_matrix(s_anchor, s_pos, s_scale, s_rot, s_skew, s_skew_axis);\nconst layer_transform = shape_layer.transform;\nconst l_anchor = layer_transform.anchorPoint;\nconst l_pos = layer_transform.position;\nconst l_scale = layer_transform.scale;\nconst l_rot = layer_transform.rotation;\nconst layer_transform_matrix = get_transform_shape_matrix(l_anchor, l_pos, l_scale, l_rot, 0, 0);\nlet subdivs = 1;\nlet num_pnts = pnts.length;\nif (hasNoneZeroValues(inTangents) || hasNoneZeroValues(outTangents)) {\n    subdivs = 5;\n    let pointsF = [];\n    for (var i = 0; i < num_pnts; i++) {\n        pointsF.push(pnts[i]);\n        if (!is_path_closed && i == num_pnts - 1) {\n            break;\n        }\n        var p1 = pnts[i], p2 = pnts[(i + 1) % num_pnts];\n        var out1 = outTangents[i], in2 = inTangents[(i + 1) % num_pnts];\n        var cp1 = add(p1, out1), cp2 = add(p2, in2);\n        var len_out1 = len_vec(out1), len_in2 = len_vec(in2);\n        var len_p1p2 = len_vec(sub(p2, p1));\n        if (len_out1 !== 0 || len_in2 !== 0) {\n            var a = len_out1 === 0 ? sub(p2, p1) : out1;\n            var b = len_in2 === 0 ? sub(p1, p2) : in2;\n            if (!isStraightLine_w_delta(a, b, 0.999) && (len_out1 > len_p1p2 * 0.02 || len_in2 > len_p1p2 * 0.02)) {\n                for (var j = 1; j < subdivs; j++) {\n                    var t = $bm_div(j, subdivs);\n                    pointsF.push(getPoint(p1, cp1, cp2, p2, t));\n                }\n            }\n        }\n    }\n    pnts = pointsF;\n}\npnts = pnts.map(p => transform2D_apply(shape_transform_matrix, p));\nnum_pts = pnts.length;\nconst zero_center_point = getCentroidPro(pnts)[4];\nlet z_coord = 0;\nswitch (1) {\ncase 0:\n    z_coord = $bm_div($bm_neg(depth), 2);\n    break;\ncase 1:\n    z_coord = 0;\n    break;\ncase 2:\n    z_coord = $bm_div(depth, 2);\n    break;\n}\n;\nconst zero_center_point_3D = [\n    ...zero_center_point,\n    z_coord\n];\nconst pivot_matrix = transformMatrix([\n    0,\n    0,\n    z_coord\n], 1, [\n    0,\n    0,\n    0\n], [\n    0,\n    0,\n    0\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst pivot_position = make_transform(pivot_matrix, zero_center_point);\nconst tr_front_mat = transformMatrix([\n    0,\n    0,\n    $bm_div($bm_neg(depth), 2)\n], scale_front, zero_center_point_3D, [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst tr_back_mat = transformMatrix([\n    0,\n    0,\n    $bm_div(depth, 2)\n], scale_back, zero_center_point_3D, [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst rot_matrix = transformMatrix([\n    0,\n    0,\n    0\n], 1, [\n    0,\n    0,\n    0\n], [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], [\n    0,\n    0,\n    0\n], [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst z1_transformed = make_transform(rot_matrix, [\n    0,\n    0,\n    -1\n]);\nconst front_facing_towards_us = isVectorFacingTowardsUs(z1_transformed);\nlet points_front_3D = pnts.map(pnt => make_transform(tr_front_mat, pnt));\nlet points_back_3D = pnts.map(pnt => make_transform(tr_back_mat, pnt));\nlet winding_sides = [];\nlet sorted_sides = [];\nlet sorted_side_colors = [];\nlet num_sides_towards_us = 0;\nfor (var i = 0; i < num_pts; i++) {\n    if (!is_path_closed && i == num_pts - 1) {\n        break;\n    }\n    var F1 = points_front_3D[i], F2 = points_front_3D[(i + 1) % num_pts];\n    var B1 = points_back_3D[i], B2 = points_back_3D[(i + 1) % num_pts];\n    let abs_side_normal = getNormal([\n        F2,\n        F1,\n        B1\n    ], true);\n    let real_side_normal = !is_front_clockwise ? mul(abs_side_normal, -1) : abs_side_normal;\n    const sideIsFacingUs = isFacingTowardsUs([\n        0,\n        0,\n        0\n    ], real_side_normal);\n    if (sideIsFacingUs) {\n        num_sides_towards_us++;\n    }\n    winding_sides.push(sideIsFacingUs);\n    let side_sorted = [\n        F2,\n        F1,\n        B1,\n        B2\n    ];\n    side_sorted.sort((a, b) => b[2] - a[2]);\n    sorted_sides.push([\n        side_sorted,\n        i,\n        $bm_mod($bm_sum(i, 1), num_pts),\n        abs_side_normal\n    ]);\n}\ncompare_sides = function (side1, side2) {\n    const s1_vertices_z = side1[0].map(v => v[2]), s2_vertices_z = side2[0].map(v => v[2]);\n    for (var i = 0, il = side1[0].length; i < il; i++) {\n        if (s1_vertices_z[i] != s2_vertices_z[i]) {\n            return $bm_sub(s2_vertices_z[i], s1_vertices_z[i]);\n        }\n    }\n};\nsorted_sides.sort((a, b) => compare_sides(a, b));\nsorted_sides.sort(function (a, b) {\n    const fa = winding_sides[a[1]], fb = winding_sides[b[1]];\n    if (fa && !fb) {\n        return -1;\n    } else if (!fa && fb) {\n        return 1;\n    } else {\n        return 0;\n    }\n});\nsorted_sides_indices = sorted_sides.map(p => [\n    p[1],\n    p[2]\n]);\nif (true) {\n    const lambert_max = extrudalizer('Sides fill shadow opacity').value;\n    const rgba = extrudalizer('Sides color').value;\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    lambertShader = function (normal, max_value, multiplier) {\n        return $bm_div($bm_mul($bm_mul(multiplier, $bm_sub(100, max_value)), Math.abs(dot_(normal, [\n            0,\n            0,\n            1\n        ]))), 100);\n    };\n    sorted_side_colors = sorted_sides.map(p => adjustColorBrightness(rgba, lambertShader(p[3], lambert_max, 2)));\n}\nconst front_normal = div(z1_transformed, len_vec(z1_transformed));\nlet bb_front_2D = [], bb_back_2D = [], bb_front_transforms_te = [], bb_back_transforms_te = [], bb_front_transforms_tl = [], bb_back_transforms_tl = [];\nif (use_bb_back || use_bb_front) {\n    const bb = getBoundingBox(pnts);\n    let hasParent = shape_layer.hasParent;\n    let parent_transform_matrix = null;\n    if (hasParent) {\n        let p_pos = shape_layer.parent.transform.position;\n        let p_anchor = shape_layer.parent.transform.anchorPoint;\n        let p_rot = shape_layer.parent.transform.rotation;\n        let p_sca = shape_layer.parent.transform.scale;\n        parent_transform_matrix = get_transform_shape_matrix(p_anchor, p_pos, p_sca, p_rot, 0, 0);\n    }\n    if (use_bb_front) {\n        const bb_front_data = get_transforms_from_bb(bb, tr_front_mat, layer_transform_matrix, parent_transform_matrix, true, front_facing_towards_us, 3);\n        bb_front_2D = bb_front_data['boundingBoxTransformed'];\n        bb_front_transforms_te = bb_front_data['transformEffectControls'];\n        bb_front_transforms_tl = bb_front_data['transformLayerControls'];\n    }\n    if (use_bb_back) {\n        const bb_back_data = get_transforms_from_bb(bb, tr_back_mat, layer_transform_matrix, parent_transform_matrix, false, front_facing_towards_us, 3);\n        bb_back_2D = bb_back_data['boundingBoxTransformed'];\n        bb_back_transforms_te = bb_back_data['transformEffectControls'];\n        bb_back_transforms_tl = bb_back_data['transformLayerControls'];\n    }\n}\nlet grad_property = null;\ntry {\n    grad_property = shape_contents('ADBE Vector Graphic - G-Fill');\n} catch (e) {\n}\nlet grad_start_front_new = [\n    0,\n    0\n];\nlet grad_end_front_new = [\n    0,\n    0\n];\nlet grad_start_back_new = [\n    0,\n    0\n];\nlet grad_end_back_new = [\n    0,\n    0\n];\nif (grad_property != null) {\n    let grad_start = grad_property.startPoint.value;\n    let grad_end = grad_property.endPoint.value;\n    grad_start = transform2D_apply(shape_transform_matrix, grad_start);\n    grad_end = transform2D_apply(shape_transform_matrix, grad_end);\n    const grad_start_front = make_transform(tr_front_mat, grad_start);\n    const grad_end_front = make_transform(tr_front_mat, grad_end);\n    const grad_start_back = make_transform(tr_back_mat, grad_start);\n    const grad_end_back = make_transform(tr_back_mat, grad_end);\n    grad_start_front_new = grad_start_front;\n    grad_end_front_new = grad_end_front;\n    grad_start_back_new = grad_start_back;\n    grad_end_back_new = grad_end_back;\n    const grad_front_rot = $bm_div($bm_mul(extrudalizer('Front gradient direction').value, Math.PI), 180);\n    const grad_back_rot = $bm_div($bm_mul(extrudalizer('Back gradient direction').value, Math.PI), 180);\n    if (!arraysEqual([\n            grad_front_rot,\n            grad_back_rot\n        ], [\n            0,\n            0\n        ])) {\n        const grad_origin_front = div(add(grad_end_front, grad_start_front), 2);\n        const grad_origin_back = div(add(grad_end_back, grad_start_back), 2);\n        const grad_p_st_front = sub(grad_start_front, grad_origin_front);\n        const grad_p_end_front = sub(grad_end_front, grad_origin_front);\n        const grad_p_st_back = sub(grad_start_back, grad_origin_back);\n        const grad_p_end_back = sub(grad_end_back, grad_origin_back);\n        if (grad_front_rot != 0) {\n            const cos_st = Math.cos(grad_front_rot), sin_st = Math.sin(grad_front_rot);\n            grad_start_front_new[0] = $bm_sum($bm_sub($bm_mul(cos_st, grad_p_st_front[0]), $bm_mul(sin_st, grad_p_st_front[1])), grad_origin_front[0]);\n            grad_start_front_new[1] = $bm_sum($bm_sum($bm_mul(sin_st, grad_p_st_front[0]), $bm_mul(cos_st, grad_p_st_front[1])), grad_origin_front[1]);\n            grad_end_front_new[0] = $bm_sum($bm_sub($bm_mul(cos_st, grad_p_end_front[0]), $bm_mul(sin_st, grad_p_end_front[1])), grad_origin_front[0]);\n            grad_end_front_new[1] = $bm_sum($bm_sum($bm_mul(sin_st, grad_p_end_front[0]), $bm_mul(cos_st, grad_p_end_front[1])), grad_origin_front[1]);\n        }\n        if (grad_back_rot != 0) {\n            const cos_st_b = Math.cos(grad_back_rot), sin_st_b = Math.sin(grad_back_rot);\n            grad_start_back_new[0] = $bm_sum($bm_sub($bm_mul(cos_st_b, grad_p_st_back[0]), $bm_mul(sin_st_b, grad_p_st_back[1])), grad_origin_back[0]);\n            grad_start_back_new[1] = $bm_sum($bm_sum($bm_mul(sin_st_b, grad_p_st_back[0]), $bm_mul(cos_st_b, grad_p_st_back[1])), grad_origin_back[1]);\n            grad_end_back_new[0] = $bm_sum($bm_sub($bm_mul(cos_st_b, grad_p_end_back[0]), $bm_mul(sin_st_b, grad_p_end_back[1])), grad_origin_back[0]);\n            grad_end_back_new[1] = $bm_sum($bm_sum($bm_mul(sin_st_b, grad_p_end_back[0]), $bm_mul(cos_st_b, grad_p_end_back[1])), grad_origin_back[1]);\n        }\n    }\n}\nconst extr_data = [\n    tr_front_mat,\n    tr_back_mat,\n    shape_transform_matrix,\n    subdivs,\n    is_path_closed,\n    points_front_3D,\n    points_back_3D,\n    sorted_sides_indices,\n    front_facing_towards_us,\n    is_front_clockwise,\n    num_sides_towards_us,\n    sorted_side_colors,\n    pivot_position,\n    front_normal,\n    bb_front_2D,\n    bb_back_2D,\n    bb_front_transforms_te,\n    bb_back_transforms_te,\n    bb_front_transforms_tl,\n    bb_back_transforms_tl,\n    grad_start_front_new,\n    grad_end_front_new,\n    grad_start_back_new,\n    grad_end_back_new\n];\nvar txt = '';\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || square_1'] = extr_data;\n} catch (err) {\n    stringify = function (data, separator) {\n        return data.map(item => Array.isArray(item) ? item.join(',') : item.toString()).join(separator);\n    };\n    txt = stringify(extr_data, ';');\n}\n$bm_rt = txt;"},"p":{},"m":{"g":1,"a":{"a":0,"k":[0,0],"ix":2}},"a":[]},"ip":0,"op":300,"st":0,"ct":1,"bm":0}]}],"fonts":{"list":[{"origin":0,"fPath":"","fClass":"","fFamily":"Taxon","fWeight":"","fStyle":"Boldit","fName":"TrajanPro-Bold","ascent":64.2999389674515},{"origin":0,"fPath":"","fClass":"","fFamily":"Taxon-BoldIt","fWeight":"","fStyle":"Italic","fName":"Taxon-BoldIt","ascent":74.5986938476562}]},"layers":[{"ddd":0,"ind":1,"ty":3,"nm":"Null 1","sr":1,"ks":{"o":{"a":0,"k":0,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[540,540,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[130,130,100],"ix":6,"l":2}},"ao":0,"ip":0,"op":900,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":0,"nm":"Kiss_Face","parent":1,"refId":"comp_0","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[540,540,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"w":1080,"h":1080,"ip":180,"op":270,"st":180,"ct":1,"bm":0},{"ddd":0,"ind":3,"ty":0,"nm":"hug_Face","parent":1,"refId":"comp_7","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[540,540,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"w":1080,"h":1080,"ip":270,"op":360,"st":270,"ct":1,"bm":0},{"ddd":0,"ind":4,"ty":0,"nm":"Dare_Face","parent":1,"refId":"comp_8","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[540,540,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"w":1080,"h":1080,"ip":360,"op":450,"st":360,"ct":1,"bm":0},{"ddd":0,"ind":5,"ty":0,"nm":"Number_Face","parent":1,"refId":"comp_9","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[540,540,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"w":1080,"h":1080,"ip":450,"op":540,"st":450,"ct":1,"bm":0},{"ddd":0,"ind":6,"ty":0,"nm":"Selfie_Face","parent":1,"refId":"comp_10","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[540,540,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"w":1080,"h":1080,"ip":540,"op":630,"st":540,"ct":1,"bm":0},{"ddd":0,"ind":7,"ty":0,"nm":"Slap_Face","parent":1,"refId":"comp_11","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[540,540,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"w":1080,"h":1080,"ip":630,"op":729,"st":630,"ct":1,"bm":0},{"ddd":0,"ind":8,"ty":0,"nm":"Dice","parent":1,"refId":"comp_12","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2,"l":2},"a":{"a":0,"k":[540,540,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"w":1080,"h":1080,"ip":0,"op":181,"st":0,"ct":1,"bm":0}],"markers":[],"props":{}}